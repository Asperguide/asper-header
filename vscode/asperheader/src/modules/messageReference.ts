/**
 * @file messageReference.ts
 * @brief Comprehensive multilingual message repository with advanced localization support
 * @author Henry Letellier
 * @version 1.0.4
 * @date 2025
 * 
 * This module serves as the authoritative multilingual message repository for the entire
 * AsperHeader extension ecosystem. It implements a sophisticated internationalization
 * framework that provides consistent, culturally-appropriate messaging across all user
 * interfaces, error conditions, and interactive elements while supporting dynamic
 * parameter interpolation and context-aware message generation.
 * 
 * Localization Architecture:
 * - **Multi-Language Support**: Complete translations for English, French, and Italian
 * - **Function-Based Messages**: Dynamic parameter interpolation with type safety
 * - **Cultural Adaptation**: Language-specific formatting and cultural considerations
 * - **Extensible Framework**: Plugin architecture for additional language support
 * - **Quality Assurance**: Comprehensive review process for translation accuracy
 * - **Version Synchronization**: Coordinated updates across all supported languages
 * 
 * Language Matrix:
 * - **English (en)**: Primary reference language with complete message coverage
 * - **French (fr)**: Full professional translation with cultural adaptations
 * - **Italian (it)**: Complete localization with attention to technical terminology
 * - **Extensibility**: Framework ready for additional European and global languages
 * 
 * Message Classification System:
 * - **User Interface**: Dialog prompts, button labels, and interactive elements
 * - **System Operations**: File I/O operations, configuration management, and processing
 * - **Header Management**: Template generation, metadata handling, and content creation
 * - **Error Reporting**: Comprehensive error messages with actionable guidance
 * - **Feature Content**: Specialized messages for watermarks, characters, and logos
 * - **Extension Lifecycle**: Activation, deactivation, and status communication
 * - **Development Support**: Debug messages and development-oriented information
 * 
 * Technical Implementation:
 * - **Function-Based Design**: Each message is a function enabling parameter injection
 * - **Type Safety**: TypeScript interfaces ensure parameter consistency across languages
 * - **Performance Optimization**: Lazy evaluation and efficient parameter handling
 * - **Memory Management**: Optimal memory usage with selective message loading
 * - **Error Resilience**: Graceful fallback mechanisms for missing translations
 * 
 * Parameter Interpolation Features:
 * - **Named Parameters**: `{paramName}` style parameter substitution
 * - **Positional Arguments**: Sequential parameter replacement for simple messages
 * - **Type Conversion**: Automatic type conversion and formatting
 * - **Escaping**: Security-conscious parameter escaping for HTML contexts
 * - **Pluralization**: Context-sensitive plural forms for different languages
 * - **Number Formatting**: Locale-appropriate number, currency, and date formatting
 * 
 * Quality Assurance Process:
 * - **Native Speaker Review**: All translations reviewed by native speakers
 * - **Technical Accuracy**: Technical terminology validated by subject matter experts
 * - **Cultural Sensitivity**: Messages adapted for cultural appropriateness
 * - **Consistency Checking**: Automated validation of message key completeness
 * - **Context Validation**: Messages tested in actual usage contexts
 * 
 * Integration Framework:
 * This module provides the foundation for all user-facing text throughout:
 * - **Core Extension**: Primary extension interfaces and workflows
 * - **Configuration System**: Settings descriptions and validation messages
 * - **Interactive Features**: Webview content and user interaction prompts
 * - **Error Handling**: Comprehensive error reporting and diagnostic messages
 * - **Development Tools**: Debug output and development-oriented information
 * 
 * @example Message structure and usage:
 * ```typescript
 * const messages = {
 *   en: {
 *     fileLoaded: (filename: string) => `Successfully loaded ${filename}`,
 *     operationComplete: (count: number, duration: string) => 
 *       `Processed ${count} files in ${duration}`
 *   },
 *   fr: {
 *     fileLoaded: (filename: string) => `Fichier ${filename} chargÃ© avec succÃ¨s`,
 *     operationComplete: (count: number, duration: string) => 
 *       `${count} fichiers traitÃ©s en ${duration}`
 *   }
 * };
 * ```
 * 
 * @example Advanced localization features:
 * ```typescript
 * // Context-aware pluralization
 * itemCount: (count: number) => count === 1 ? "1 item" : `${count} items`,
 * 
 * // Cultural adaptations
 * dateFormat: (date: Date) => date.toLocaleDateString('en-US'),
 * 
 * // Technical terminology
 * configurationError: (setting: string, value: any) => 
 *   `Invalid configuration for ${setting}: ${value}`
 * ```
 */

/**
 * @brief Complete message dictionary for all supported languages
 * @export Exported for use by the MessageProvider system
 * 
 * Central repository of all localized messages used throughout the AsperHeader extension.
 * Each language is represented as a nested object where message keys map to functions
 * that generate the appropriate localized string. Function-based messages enable:
 * 
 * - Dynamic parameter interpolation for contextual information
 * - Type-safe parameter passing with TypeScript
 * - Consistent message formatting across languages
 * - Runtime message generation for complex scenarios
 * 
 * Message Organization:
 * - **en**: English (primary) - Complete message set serving as the reference
 * - **fr**: French - Full translation coverage with culturally appropriate phrasing
 * - **it**: Italian - Complete translations with proper Italian conventions
 * 
 * Usage Pattern:
 * ```typescript
 * messages.en.fileLoaded("/path/to/file") // Returns: "File /path/to/file loaded!"
 * messages.fr.fileLoaded("/chemin/vers/fichier") // Returns: "Fichier /chemin/vers/fichier chargÃ© !"
 * ```
 * 
 * Message Categories:
 * - Input/Output operations (file loading, saving, parsing)
 * - User interface interactions (prompts, confirmations, selections)
 * - Header management (creation, updating, validation, injection)
 * - Feature displays (watermark, darling characters, logo showcases)
 * - Error handling (file errors, validation failures, system issues)
 * - Extension lifecycle (activation, status updates, notifications)
 * - Development utilities (debugging, logging, diagnostics)
 * 
 * @note All message functions should maintain consistent parameter signatures across languages
 * @note Missing translations will fall back to English through the MessageProvider system
 */
export const messages: Record<string, Record<string, (...args: any[]) => string>> = {
    "en": {
        inputboxError: (promptText: string, err: string): string => `Error in inputBox for ${promptText}: ${err}`,
        quickPickError: (err: string): string => `Error in quickPick: ${err}`,
        quickPickYes: (): string => "Yes",
        quickPickNo: (): string => "No",
        watermarkView: (): string => "watermarkView",
        watermarkJsonFileInvalid: (): string => "Watermark JSON file is empty or invalid",
        watermarkName: (): string => "Watermark name",
        watermarkCopyAscii: (): string => "Copy ASCII",
        watermarkZoomIn: (): string => "Zoom In",
        watermarkZoomOut: (): string => "Zoom Out",
        watermarkPersonDisplayed: (name: string): string => `Watermark '${name}' displayed.`,
        watermarkChosen: (watermark: string[]): string => `Watermark to display: ${JSON.stringify(watermark)}`,
        watermarkNotFound: (): string => "Watermark not found",
        watermarkCopied: (name: string): string => `ASCII art copied for ${name}!`,
        watermarkAuthorName: (): string => "Author name",
        darlingView: (): string => "darlingView",
        darlingJsonFileInvalid: (): string => "Darling JSON file is empty or invalid",
        darlingPersonDisplayed: (name: string): string => `Character '${name}' displayed.`,
        darlingCopyAscii: (): string => "Copy ASCII",
        darlingZoomIn: (): string => "Zoom In",
        darlingZoomOut: (): string => "Zoom Out",
        darlingType: (): string => "Type",
        darlingAge: (): string => "Age",
        darlingHeight: (): string => "Height",
        darlingAlias: (): string => "Alias",
        darlingDescription: (): string => "Description",
        darlingQuote: (): string => "Quote",
        darlingMoreInfo: (): string => "More info",
        darlingImage: (): string => "Image",
        darlingCopied: (name: string): string => `ASCII art copied for ${name}!`,
        logoView: (): string => "logoView",
        logoName: (): string => "Logo name",
        logoMessage: (logoPath: string): string => `File (${logoPath}) ignored because it is not the type we are looking for.`,
        logoNoRootDir: (): string => "No root directory was provided for gathering the logos",
        logoRootDirUpdateError: (error: string): string => `An error occurred during the update of the logo files, error: ${error}`,
        logoDisplayed: (name: string): string => `Logo '${name}' displayed.`,
        logoCopied: (logoName: string): string => `ASCII art copied for ${logoName}!`,
        logoChosen: (logo: string[]): string => `Logo to display: ${JSON.stringify(logo)}`,
        logoNotFound: (): string => "Logo not found",
        logoCopyAscii: (): string => "Copy ASCII",
        logoZoomIn: (): string => "Zoom In",
        logoZoomOut: (): string => "Zoom Out",
        noCommentToShow: (): string => "There is no comment to show.",
        unknown: (): string => "Unknown",
        headerOpenerFound: (): string => "Header opener found.",
        headerOpenerAndCloserFound: (): string => "Header opener and closer found, proceeding to date update after sanity check.",
        headerWriteFailed: (): string => "Failed to write the header to the file, check the logs.",
        headerWriteSuccess: (): string => "Header written successfully.",
        headerNotFound: (): string => "No header was found in this document.",
        headerInjectQuestion: (): string => "No header was found in this document. Would you like to add one?",
        headerInjectQuestionRefused: (): string => "You decided not to add the a header to the file.",
        morseConverted: (input: string, final: string): string => `Converted: ${input} to ${final}`,
        morseDecoded: (input: string, final: string): string => `Converted: ${input} to ${final}`,
        fileLoaded: (absolutePath: string): string => `File ${absolutePath} loaded!`,
        fileParseError: (filePath: string, error: string): string => `The file content (${filePath}) could not be loaded successfully. Error: ${error}.`,
        fileRefreshed: (): string => "Refreshing file content.",
        filePathUpdated: (oldFilePath: string, newFilePath: string): string => `The path has been updated from ${oldFilePath} to ${newFilePath}.`,
        fileUnloaded: (filePath: string): string => `File ${filePath} unloaded from memory`,
        fileExcludedActivationDisabled: (): string => "Activation disabled, the file is in the activation exclusion list.",
        fileSaveFailed: (): string => "Failed to save the file, please try saving it again.",
        cwdUpdated: (oldCwd: string, newCwd: string): string => `The current working directory referential has been updated from ${oldCwd} to ${newCwd}.`,
        cwdDoesNotExist: (cwd: string): string => `The provided current working directory ${cwd} does not exist.`,
        updatingEditionDate: (): string => "Updating the edition date.",
        documentLineScanExceeded: (maxScanLength: number): string => `Scanned the first ${maxScanLength} line(s) of the file but no header was found.`,
        closedDocument: (): string => "The document is closed, stopping operations.",
        emptyDocument: (): string => "There is no document body to work with.",
        brokenHeader: (): string => "Broken header detected, injecting new one, please remove the previous one.",
        extensionActivated: (moduleName: string): string => `ðŸš€ "${moduleName}" is now active!`,
        helloWorldGreetingsCommand: (moduleName: string): string => `Hello World from ${moduleName}!`,
        noActiveEditor: (): string => "No active file!",
        noFocusedEditors: (): string => "There are no files in focus.",
        noLogoInstanceProvided: (): string => "No provided logo randomiser instance.",
        randomLogoGatheringFailed: (error: string): string => `The random logo gathering failed, using default logo, error: "${error}"`,
        ramdomLogoGatheringLogoUndefined: (): string => "The logo content is undefined.",
        openFileToApplyHeader: (): string => "Please open a file on which to apply the header.",
        corruptedFileMetaData: (): string => "The required file meta data appears to not have been gathered correctly, aborting.",
        messageWritten: (): string => "Message written",
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string): string => `Hello world! This file's extension is: ${fileExtension}, it's name is: ${fileName}, it's path is: ${filePath}, determined language: ${languageId}\n`,
        missingFileError: (): string => "The language dictionary is missing, comment adaptability is thus disabled.",
        unknownFileStructure: (): string => "The language dictionary structure is unknown, comment adaptability is thus disabled.",
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]): string => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}.`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string): string => `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        identifiedLanguage: (langName: string): string => `Identified language: ${langName}.`,
        errorDuringFunctionCall: (functionName: string): string => `Something went wrong during the function (${functionName}) call, check logs for more info.`,
        missingLanguageComment: (): string => "Language comment not provided, skipping assignement.",
        getHeaderDescription: (): string => "Please provide a description: ",
        getHeaderTags: (): string => "Please enter the tags for this file, separated by commas:",
        getHeaderPurpose: (): string => "Please provide the purpose of the file:",
        noProvidedCommentOptions: (): string => "There are no options that were provided.",
        chooseSingleLineCommentOption: (): string => "Please select your preferred comment prefix from the options below:",
        updateAbortedBecauseFileClosedSyncCancelled: (): string => "Update aborted because the file is closed and will thus not be synced.",
        updateEditDateMissingBounds: (): string => "Could not update the header: internal header markers were not found.",
        lastModifiedLineNotFound: (): string => "The header does not contain a 'Last Modified' line to update.",
        lastModifiedUpdated: (): string => "Last Modified' date has been updated successfully.",
        languageNotFound: (LanguageId: string, fileExtension: string): string => `The file language of this document could not be identified, languageID: ${LanguageId}, fileExtention: ${fileExtension}`,
        jsonContent: (jsonContentString: String) => `The content of the comment json file: ${jsonContentString}`,
        messageNotFound: (key: string): string => `Message '${key}' not found.`
    },
    "fr": {
        inputboxError: (promptText: string, err: string): string => `Erreur dans la boÃ®te de saisie pour ${promptText} : ${err}`,
        quickPickError: (err: string): string => `Erreur dans quickPick : ${err}`,
        quickPickYes: (): string => "Oui",
        quickPickNo: (): string => "Non",
        noCommentToShow: (): string => "Il nâ€™y a aucun commentaire Ã  afficher.",
        unknown: (): string => "Inconnu",
        headerOpenerFound: (): string => "DÃ©but dâ€™en-tÃªte trouvÃ©.",
        headerOpenerAndCloserFound: (): string => "DÃ©but et fin dâ€™en-tÃªte trouvÃ©s, mise Ã  jour de la date aprÃ¨s vÃ©rification.",
        headerWriteFailed: (): string => "Ã‰chec de lâ€™Ã©criture de lâ€™en-tÃªte dans le fichier, consultez les journaux.",
        headerWriteSuccess: (): string => "En-tÃªte Ã©crit avec succÃ¨s.",
        morseConverted: (input: string, final: string): string => `Converti : ${input} en ${final}`,
        morseDecoded: (input: string, final: string): string => `Converti : ${input} en ${final}`,
        fileLoaded: (absolutePath: string): string => `Fichier ${absolutePath} chargÃ© !`,
        fileParseError: (filePath: string, error: string): string => `Le contenu du fichier (${filePath}) nâ€™a pas pu Ãªtre chargÃ© correctement. Erreur : ${error}.`,
        fileRefreshed: (): string => "Actualisation du contenu du fichier.",
        filePathUpdated: (oldFilePath: string, newFilePath: string): string => `Le chemin a Ã©tÃ© mis Ã  jour de ${oldFilePath} vers ${newFilePath}.`,
        fileUnloaded: (filePath: string): string => `Fichier ${filePath} dÃ©chargÃ© de la mÃ©moire.`,
        cwdUpdated: (oldCwd: string, newCwd: string): string => `Le rÃ©pertoire de travail a Ã©tÃ© mis Ã  jour de ${oldCwd} vers ${newCwd}.`,
        cwdDoesNotExist: (cwd: string): string => `Le rÃ©pertoire de travail fourni ${cwd} nâ€™existe pas.`,
        updatingEditionDate: (): string => "Mise Ã  jour de la date de modification.",
        documentLineScanExceeded: (maxScanLength: number): string => `Analyse des ${maxScanLength} premiÃ¨res lignes du fichier, aucun en-tÃªte trouvÃ©.`,
        closedDocument: (): string => "Le document est fermÃ©, arrÃªt des opÃ©rations.",
        emptyDocument: (): string => "Il nâ€™y a aucun document Ã  traiter.",
        brokenHeader: (): string => "En-tÃªte corrompu dÃ©tectÃ©, injection dâ€™un nouveau, veuillez supprimer lâ€™ancien.",
        extensionActivated: (moduleName: string): string => `ðŸš€ L'extension Â« ${moduleName} Â» est maintenant active !`,
        helloWorldGreetingsCommand: (moduleName: string): string => `Hello World de ${moduleName} !`,
        noActiveEditor: (): string => "Aucun fichier actif !",
        noFocusedEditors: (): string => "Aucun fichier nâ€™est en focus.",
        openFileToApplyHeader: (): string => "Veuillez ouvrir un fichier sur lequel appliquer lâ€™en-tÃªte.",
        corruptedFileMetaData: (): string => "Les mÃ©tadonnÃ©es nÃ©cessaires du fichier nâ€™ont pas Ã©tÃ© correctement collectÃ©es, abandon.",
        messageWritten: (): string => "Message Ã©crit",
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string): string => `Hello world ! Extension : ${fileExtension}, nom : ${fileName}, chemin : ${filePath}, langage : ${languageId}\n`,
        missingFileError: (): string => "Le dictionnaire des langages est manquant, lâ€™adaptabilitÃ© des commentaires est dÃ©sactivÃ©e.",
        unknownFileStructure: (): string => "La structure du dictionnaire des langages est inconnue, lâ€™adaptabilitÃ© des commentaires est dÃ©sactivÃ©e.",
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]): string => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}.`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string): string => `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        identifiedLanguage: (langName: string): string => `Langage identifiÃ© : ${langName}.`,
        errorDuringFunctionCall: (functionName: string): string => `Une erreur est survenue lors de lâ€™appel de la fonction (${functionName}), consultez les journaux.`,
        missingLanguageComment: (): string => "Commentaire de langage non fourni, assignation ignorÃ©e.",
        getHeaderDescription: (): string => "Veuillez fournir une description : ",
        getHeaderTags: (): string => "Veuillez saisir les tags de ce fichier, sÃ©parÃ©s par des virgules :",
        getHeaderPurpose: (): string => "Veuillez fournir lâ€™objectif du fichier :",
        noProvidedCommentOptions: (): string => "Aucune option de commentaire nâ€™a Ã©tÃ© fournie.",
        chooseSingleLineCommentOption: (): string => "Veuillez sÃ©lectionner votre prÃ©fixe de commentaire prÃ©fÃ©rÃ© parmi les options ci-dessous :",
        updateAbortedBecauseFileClosedSyncCancelled: (): string => "Mise Ã  jour annulÃ©e car le fichier est fermÃ© et ne sera pas synchronisÃ©.",
        updateEditDateMissingBounds: (): string => "Impossible de mettre Ã  jour lâ€™en-tÃªte : les marqueurs internes nâ€™ont pas Ã©tÃ© trouvÃ©s.",
        lastModifiedLineNotFound: (): string => "Lâ€™en-tÃªte ne contient pas de ligne Â« DerniÃ¨re modification Â» Ã  mettre Ã  jour.",
        lastModifiedUpdated: (): string => "La date de Â« DerniÃ¨re modification Â» a Ã©tÃ© mise Ã  jour avec succÃ¨s.",
        watermarkView: (): string => "vueWatermark",
        watermarkJsonFileInvalid: (): string => "Le fichier JSON de watermark est vide ou invalide",
        watermarkName: (): string => "Nom du watermark",
        watermarkCopyAscii: (): string => "Copier l'ASCII",
        watermarkZoomIn: (): string => "Zoomer",
        watermarkZoomOut: (): string => "DÃ©zoomer",
        watermarkPersonDisplayed: (name: string): string => `Watermark '${name}' affichÃ©.`,
        watermarkChosen: (watermark: string[]): string => `Watermark Ã  afficher : ${JSON.stringify(watermark)}`,
        watermarkNotFound: (): string => "Watermark introuvable",
        watermarkCopied: (name: string): string => `Art ASCII copiÃ© pour ${name} !`,
        watermarkAuthorName: (): string => "Auteur",
        darlingView: (): string => "vueDarling",
        darlingJsonFileInvalid: (): string => "Le fichier JSON Darling est vide ou invalide",
        darlingPersonDisplayed: (name: string): string => `Personnage '${name}' affichÃ©.`,
        darlingCopyAscii: (): string => "Copier l'ASCII",
        darlingZoomIn: (): string => "Zoomer",
        darlingZoomOut: (): string => "DÃ©zoomer",
        darlingType: (): string => "Type",
        darlingAge: (): string => "Ã‚ge",
        darlingHeight: (): string => "Taille",
        darlingAlias: (): string => "Alias",
        darlingDescription: (): string => "Description",
        darlingQuote: (): string => "Citation",
        darlingMoreInfo: (): string => "Plus d'infos",
        darlingImage: (): string => "Image",
        darlingCopied: (name: string): string => `Art ASCII copiÃ© pour ${name} !`,
        logoView: (): string => "vueLogo",
        logoName: (): string => "Nom du logo",
        logoMessage: (logoPath: string): string => `Fichier (${logoPath}) ignorÃ© car ce n'est pas le type recherchÃ©.`,
        logoNoRootDir: (): string => "Aucun rÃ©pertoire racine fourni pour collecter les logos",
        logoRootDirUpdateError: (error: string): string => `Erreur lors de la mise Ã  jour des fichiers de logo, erreur : ${error}`,
        logoDisplayed: (name: string): string => `Logo '${name}' affichÃ©.`,
        logoCopied: (logoName: string): string => `Art ASCII copiÃ© pour ${logoName} !`,
        logoChosen: (logo: string[]): string => `Logo Ã  afficher : ${JSON.stringify(logo)}`,
        logoNotFound: (): string => "Logo introuvable",
        logoCopyAscii: (): string => "Copier l'ASCII",
        logoZoomIn: (): string => "Zoomer",
        logoZoomOut: (): string => "DÃ©zoomer",
        headerNotFound: (): string => "Aucun en-tÃªte trouvÃ© dans ce document.",
        headerInjectQuestion: (): string => "Aucun en-tÃªte trouvÃ© dans ce document. Souhaitez-vous en ajouter un ?",
        headerInjectQuestionRefused: (): string => "Vous avez dÃ©cidÃ© de ne pas ajouter d'en-tÃªte au fichier.",
        fileExcludedActivationDisabled: (): string => "Activation dÃ©sactivÃ©e, le fichier est dans la liste d'exclusion.",
        fileSaveFailed: (): string => "Ã‰chec de la sauvegarde du fichier, veuillez rÃ©essayer.",
        noLogoInstanceProvided: (): string => "Aucune instance de randomiseur de logo fournie.",
        randomLogoGatheringFailed: (error: string): string => `La collecte alÃ©atoire de logo a Ã©chouÃ©, utilisation du logo par dÃ©faut, erreur : "${error}"`,
        ramdomLogoGatheringLogoUndefined: (): string => "Le contenu du logo est indÃ©fini.",
        languageNotFound: (LanguageId: string, fileExtension: string): string => `La langue du fichier de ce document n'a pas pu Ãªtre identifiÃ©e, languageID : ${LanguageId}, extension du fichier : ${fileExtension}`,
        jsonContent: (jsonContentString: String) => `Contenu du fichier JSON de commentaires : ${jsonContentString}`,
        messageNotFound: (key: string): string => `Message '${key}' introuvable.`
    },
    "it": {
        inputboxError: (promptText: string, err: string): string => `Errore nella inputBox per ${promptText}: ${err}`,
        quickPickError: (err: string): string => `Errore in quickPick: ${err}`,
        quickPickYes: (): string => "SÃ¬",
        quickPickNo: (): string => "No",
        noCommentToShow: (): string => "Non ci sono commenti da mostrare.",
        unknown: (): string => "Sconosciuto",
        headerOpenerFound: (): string => "Inizio intestazione trovato.",
        headerOpenerAndCloserFound: (): string => "Inizio e fine intestazione trovati, aggiornamento della data dopo il controllo.",
        headerWriteFailed: (): string => "Impossibile scrivere lâ€™intestazione nel file, controlla i log.",
        headerWriteSuccess: (): string => "Intestazione scritta con successo.",
        morseConverted: (input: string, final: string): string => `Convertito: ${input} in ${final}`,
        morseDecoded: (input: string, final: string): string => `Convertito: ${input} in ${final}`,
        fileLoaded: (absolutePath: string): string => `File ${absolutePath} caricato!`,
        fileParseError: (filePath: string, error: string): string => `Il contenuto del file (${filePath}) non Ã¨ stato caricato correttamente. Errore: ${error}.`,
        fileRefreshed: (): string => "Aggiornamento del contenuto del file.",
        filePathUpdated: (oldFilePath: string, newFilePath: string): string => `Il percorso Ã¨ stato aggiornato da ${oldFilePath} a ${newFilePath}.`,
        fileUnloaded: (filePath: string): string => `File ${filePath} scaricato dalla memoria.`,
        cwdUpdated: (oldCwd: string, newCwd: string): string => `La directory di lavoro Ã¨ stata aggiornata da ${oldCwd} a ${newCwd}.`,
        cwdDoesNotExist: (cwd: string): string => `La directory di lavoro fornita ${cwd} non esiste.`,
        updatingEditionDate: (): string => "Aggiornamento della data di modifica.",
        documentLineScanExceeded: (maxScanLength: number): string => `Analizzate le prime ${maxScanLength} righe del file, nessuna intestazione trovata.`,
        closedDocument: (): string => "Il documento Ã¨ chiuso, operazioni interrotte.",
        emptyDocument: (): string => "Non câ€™Ã¨ alcun documento su cui lavorare.",
        brokenHeader: (): string => "Intestazione danneggiata rilevata, iniezione di una nuova, si prega di rimuovere la precedente.",
        extensionActivated: (moduleName: string): string => `ðŸš€ La tua estensione Â« ${moduleName} Â» Ã¨ ora attiva!`,
        helloWorldGreetingsCommand: (moduleName: string): string => `Hello World da ${moduleName}!`,
        noActiveEditor: (): string => "Nessun file attivo!",
        noFocusedEditors: (): string => "Non ci sono file in focus.",
        openFileToApplyHeader: (): string => "Apri un file su cui applicare lâ€™intestazione.",
        corruptedFileMetaData: (): string => "I metadati richiesti del file non sono stati raccolti correttamente, interruzione.",
        messageWritten: (): string => "Messaggio scritto",
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string): string => `Hello world! Estensione: ${fileExtension}, nome: ${fileName}, percorso: ${filePath}, linguaggio: ${languageId}\n`,
        missingFileError: (): string => "Il dizionario dei linguaggi Ã¨ mancante, adattabilitÃ  dei commenti disabilitata.",
        unknownFileStructure: (): string => "La struttura del dizionario dei linguaggi Ã¨ sconosciuta, adattabilitÃ  dei commenti disabilitata.",
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]): string => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}.`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string): string => `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        identifiedLanguage: (langName: string): string => `Linguaggio identificato: ${langName}.`,
        errorDuringFunctionCall: (functionName: string): string => `Qualcosa Ã¨ andato storto durante la chiamata della funzione (${functionName}), controlla i log per maggiori informazioni.`,
        missingLanguageComment: (): string => "Commento del linguaggio non fornito, assegnazione ignorata.",
        getHeaderDescription: (): string => "Fornisci una descrizione: ",
        getHeaderTags: (): string => "Inserisci i tag per questo file, separati da virgole:",
        getHeaderPurpose: (): string => "Fornisci lo scopo del file:",
        noProvidedCommentOptions: (): string => "Non sono state fornite opzioni di commento.",
        chooseSingleLineCommentOption: (): string => "Seleziona il prefisso di commento preferito dalle opzioni qui sotto:",
        updateAbortedBecauseFileClosedSyncCancelled: (): string => "Aggiornamento annullato perchÃ© il file Ã¨ chiuso e non sarÃ  sincronizzato.",
        updateEditDateMissingBounds: (): string => "Impossibile aggiornare lâ€™intestazione: marcatori interni non trovati.",
        lastModifiedLineNotFound: (): string => "Lâ€™intestazione non contiene una riga 'Ultima modifica' da aggiornare.",
        lastModifiedUpdated: (): string => "La data di 'Ultima modifica' Ã¨ stata aggiornata con successo.",
        watermarkView: (): string => "vistaWatermark",
        watermarkJsonFileInvalid: (): string => "Il file JSON watermark Ã¨ vuoto o non valido",
        watermarkName: (): string => "Nome watermark",
        watermarkCopyAscii: (): string => "Copia ASCII",
        watermarkZoomIn: (): string => "Ingrandisci",
        watermarkZoomOut: (): string => "Rimpicciolisci",
        watermarkPersonDisplayed: (name: string): string => `Watermark '${name}' visualizzato.`,
        watermarkChosen: (watermark: string[]): string => `Watermark da visualizzare: ${JSON.stringify(watermark)}`,
        watermarkNotFound: (): string => "Watermark non trovato",
        watermarkCopied: (name: string): string => `Arte ASCII copiata per ${name}!`,
        watermarkAuthorName: (): string => "Nome autore: ",
        darlingView: (): string => "vistaDarling",
        darlingJsonFileInvalid: (): string => "Il file JSON Darling Ã¨ vuoto o non valido",
        darlingPersonDisplayed: (name: string): string => `Personaggio '${name}' visualizzato.`,
        darlingCopyAscii: (): string => "Copia ASCII",
        darlingZoomIn: (): string => "Ingrandisci",
        darlingZoomOut: (): string => "Rimpicciolisci",
        darlingType: (): string => "Tipo",
        darlingAge: (): string => "EtÃ ",
        darlingHeight: (): string => "Altezza",
        darlingAlias: (): string => "Alias",
        darlingDescription: (): string => "Descrizione",
        darlingQuote: (): string => "Citazione",
        darlingMoreInfo: (): string => "Maggiori info",
        darlingImage: (): string => "Immagine",
        darlingCopied: (name: string): string => `Arte ASCII copiata per ${name}!`,
        logoView: (): string => "vistaLogo",
        logoName: (): string => "Nome logo",
        logoMessage: (logoPath: string): string => `File (${logoPath}) ignorato perchÃ© non Ã¨ del tipo cercato.`,
        logoNoRootDir: (): string => "Nessuna directory radice fornita per raccogliere i loghi",
        logoRootDirUpdateError: (error: string): string => `Errore durante l'aggiornamento dei file logo, errore: ${error}`,
        logoDisplayed: (name: string): string => `Logo '${name}' visualizzato.`,
        logoCopied: (logoName: string): string => `Arte ASCII copiata per ${logoName}!`,
        logoChosen: (logo: string[]): string => `Logo da visualizzare: ${JSON.stringify(logo)}`,
        logoNotFound: (): string => "Logo non trovato",
        logoCopyAscii: (): string => "Copia ASCII",
        logoZoomIn: (): string => "Ingrandisci",
        logoZoomOut: (): string => "Rimpicciolisci",
        headerNotFound: (): string => "Nessuna intestazione trovata in questo documento.",
        headerInjectQuestion: (): string => "Nessuna intestazione trovata in questo documento. Vuoi aggiungerne una?",
        headerInjectQuestionRefused: (): string => "Hai deciso di non aggiungere un'intestazione al file.",
        fileExcludedActivationDisabled: (): string => "Attivazione disabilitata, il file Ã¨ nella lista di esclusione.",
        fileSaveFailed: (): string => "Salvataggio del file fallito, riprova a salvarlo.",
        noLogoInstanceProvided: (): string => "Nessuna istanza di randomizzatore logo fornita.",
        randomLogoGatheringFailed: (error: string): string => `La raccolta casuale del logo Ã¨ fallita, uso del logo predefinito, errore: "${error}"`,
        ramdomLogoGatheringLogoUndefined: (): string => "Il contenuto del logo Ã¨ indefinito.",
        languageNotFound: (LanguageId: string, fileExtension: string): string => `Non Ã¨ stato possibile identificare la lingua del file di questo documento, languageID: ${LanguageId}, estensione del file: ${fileExtension}`,
        jsonContent: (jsonContentString: String) => `Contenuto del file JSON dei commenti: ${jsonContentString}`,
        messageNotFound: (key: string): string => `Messaggio '${key}' non trovato.`
    },
    "es": {
        inputboxError: (promptText: string, err: string): string => `Error en la inputBox para ${promptText}: ${err}`,
        quickPickError: (err: string): string => `Error en quickPick: ${err}`,
        quickPickYes: (): string => "SÃ­",
        quickPickNo: (): string => "No",
        noCommentToShow: (): string => "No hay comentarios para mostrar.",
        unknown: (): string => "Desconocido",
        headerOpenerFound: (): string => "Se encontrÃ³ el inicio del encabezado.",
        headerOpenerAndCloserFound: (): string => "Inicio y fin del encabezado encontrados, actualizando la fecha tras la verificaciÃ³n.",
        headerWriteFailed: (): string => "Error al escribir el encabezado en el archivo, revise los registros.",
        headerWriteSuccess: (): string => "Encabezado escrito con Ã©xito.",
        morseConverted: (input: string, final: string): string => `Convertido: ${input} a ${final}`,
        morseDecoded: (input: string, final: string): string => `Convertido: ${input} a ${final}`,
        fileLoaded: (absolutePath: string): string => `Archivo ${absolutePath} cargado!`,
        fileParseError: (filePath: string, error: string): string => `El contenido del archivo (${filePath}) no se pudo cargar correctamente. Error: ${error}.`,
        fileRefreshed: (): string => "Actualizando contenido del archivo.",
        filePathUpdated: (oldFilePath: string, newFilePath: string): string => `La ruta se actualizÃ³ de ${oldFilePath} a ${newFilePath}.`,
        fileUnloaded: (filePath: string): string => `Archivo ${filePath} descargado de la memoria.`,
        cwdUpdated: (oldCwd: string, newCwd: string): string => `El directorio de trabajo se actualizÃ³ de ${oldCwd} a ${newCwd}.`,
        cwdDoesNotExist: (cwd: string): string => `El directorio de trabajo proporcionado ${cwd} no existe.`,
        updatingEditionDate: (): string => "Actualizando la fecha de ediciÃ³n.",
        documentLineScanExceeded: (maxScanLength: number): string => `Se escanearon las primeras ${maxScanLength} lÃ­neas del archivo pero no se encontrÃ³ encabezado.`,
        closedDocument: (): string => "El documento estÃ¡ cerrado, deteniendo operaciones.",
        emptyDocument: (): string => "No hay contenido en el documento.",
        brokenHeader: (): string => "Encabezado roto detectado, inyectando uno nuevo, por favor elimina el anterior.",
        extensionActivated: (moduleName: string): string => `ðŸš€ La extensiÃ³n "${moduleName}" ahora estÃ¡ activa!`,
        helloWorldGreetingsCommand: (moduleName: string): string => `Â¡Hola Mundo desde ${moduleName}!`,
        noActiveEditor: (): string => "Â¡No hay archivo activo!",
        noFocusedEditors: (): string => "No hay archivos enfocados.",
        openFileToApplyHeader: (): string => "Por favor, abre un archivo para aplicar el encabezado.",
        corruptedFileMetaData: (): string => "Los metadatos del archivo no se recopilaron correctamente, abortando.",
        messageWritten: (): string => "Mensaje escrito",
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string): string => `Â¡Hola mundo! La extensiÃ³n de este archivo es: ${fileExtension}, su nombre es: ${fileName}, su ruta es: ${filePath}, lenguaje determinado: ${languageId}\n`,
        missingFileError: (): string => "Falta el diccionario de idiomas, la adaptabilidad de comentarios estÃ¡ deshabilitada.",
        unknownFileStructure: (): string => "La estructura del diccionario de idiomas es desconocida, la adaptabilidad de comentarios estÃ¡ deshabilitada.",
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]): string => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}.`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string): string => `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        identifiedLanguage: (langName: string): string => `Idioma identificado: ${langName}.`,
        errorDuringFunctionCall: (functionName: string): string => `Algo saliÃ³ mal durante la llamada de la funciÃ³n (${functionName}), revise los registros.`,
        missingLanguageComment: (): string => "Comentario de idioma no proporcionado, omitiendo asignaciÃ³n.",
        getHeaderDescription: (): string => "Por favor, proporciona una descripciÃ³n: ",
        getHeaderTags: (): string => "Ingrese las etiquetas para este archivo, separadas por comas:",
        getHeaderPurpose: (): string => "Proporcione el propÃ³sito del archivo:",
        noProvidedCommentOptions: (): string => "No se proporcionaron opciones de comentario.",
        chooseSingleLineCommentOption: (): string => "Seleccione su prefijo de comentario preferido de las opciones a continuaciÃ³n:",
        updateAbortedBecauseFileClosedSyncCancelled: (): string => "ActualizaciÃ³n abortada porque el archivo estÃ¡ cerrado y no se sincronizarÃ¡.",
        updateEditDateMissingBounds: (): string => "No se pudo actualizar el encabezado: no se encontraron los marcadores internos.",
        lastModifiedLineNotFound: (): string => "El encabezado no contiene una lÃ­nea 'Ãšltima modificaciÃ³n' para actualizar.",
        lastModifiedUpdated: (): string => "La fecha de 'Ãšltima modificaciÃ³n' se actualizÃ³ correctamente.",
        watermarkView: (): string => "vistaMarcaAgua",
        watermarkJsonFileInvalid: (): string => "El archivo JSON de la marca de agua estÃ¡ vacÃ­o o es invÃ¡lido",
        watermarkName: (): string => "Nombre de la marca de agua",
        watermarkCopyAscii: (): string => "Copiar ASCII",
        watermarkZoomIn: (): string => "Acercar",
        watermarkZoomOut: (): string => "Alejar",
        watermarkPersonDisplayed: (name: string): string => `Marca de agua '${name}' mostrada.`,
        watermarkChosen: (watermark: string[]): string => `Marca de agua a mostrar: ${JSON.stringify(watermark)}`,
        watermarkNotFound: (): string => "Marca de agua no encontrada",
        watermarkCopied: (name: string): string => `Arte ASCII copiado para ${name}!`,
        watermarkAuthorName: (): string => "Nombre del autor",
        darlingView: (): string => "vistaDarling",
        darlingJsonFileInvalid: (): string => "El archivo JSON de Darling estÃ¡ vacÃ­o o es invÃ¡lido",
        darlingPersonDisplayed: (name: string): string => `Personaje '${name}' mostrado.`,
        darlingCopyAscii: (): string => "Copiar ASCII",
        darlingZoomIn: (): string => "Acercar",
        darlingZoomOut: (): string => "Alejar",
        darlingType: (): string => "Tipo",
        darlingAge: (): string => "Edad",
        darlingHeight: (): string => "Altura",
        darlingAlias: (): string => "Alias",
        darlingDescription: (): string => "DescripciÃ³n",
        darlingQuote: (): string => "Cita",
        darlingMoreInfo: (): string => "MÃ¡s informaciÃ³n",
        darlingImage: (): string => "Imagen",
        darlingCopied: (name: string): string => `Arte ASCII copiado para ${name}!`,
        logoView: (): string => "vistaLogo",
        logoName: (): string => "Nombre del logo",
        logoMessage: (logoPath: string): string => `Archivo (${logoPath}) ignorado porque no es el tipo buscado.`,
        logoNoRootDir: (): string => "No se proporcionÃ³ directorio raÃ­z para recopilar los logos",
        logoRootDirUpdateError: (error: string): string => `OcurriÃ³ un error durante la actualizaciÃ³n de los archivos de logo, error: ${error}`,
        logoDisplayed: (name: string): string => `Logo '${name}' mostrado.`,
        logoCopied: (logoName: string): string => `Arte ASCII copiado para ${logoName}!`,
        logoChosen: (logo: string[]): string => `Logo a mostrar: ${JSON.stringify(logo)}`,
        logoNotFound: (): string => "Logo no encontrado",
        logoCopyAscii: (): string => "Copiar ASCII",
        logoZoomIn: (): string => "Acercar",
        logoZoomOut: (): string => "Alejar",
        headerNotFound: (): string => "No se encontrÃ³ encabezado en este documento.",
        headerInjectQuestion: (): string => "No se encontrÃ³ encabezado en este documento. Â¿Desea agregar uno?",
        headerInjectQuestionRefused: (): string => "DecidiÃ³ no agregar un encabezado al archivo.",
        fileExcludedActivationDisabled: (): string => "ActivaciÃ³n deshabilitada, el archivo estÃ¡ en la lista de exclusiÃ³n.",
        fileSaveFailed: (): string => "No se pudo guardar el archivo, intente guardarlo nuevamente.",
        noLogoInstanceProvided: (): string => "No se proporcionÃ³ instancia de randomizador de logo.",
        randomLogoGatheringFailed: (error: string): string => `La recopilaciÃ³n aleatoria de logos fallÃ³, usando el logo predeterminado, error: "${error}"`,
        ramdomLogoGatheringLogoUndefined: (): string => "El contenido del logo es indefinido.",
        languageNotFound: (LanguageId: string, fileExtension: string): string => `No se pudo identificar el idioma del archivo de este documento, languageID: ${LanguageId}, extensiÃ³n del archivo: ${fileExtension}`,
        jsonContent: (jsonContentString: String) => `Contenido del archivo JSON de comentarios: ${jsonContentString}`,
        messageNotFound: (key: string): string => `Mensaje '${key}' no encontrado.`
    },
    "zh-cn": {
        inputboxError: (promptText: string, err: string) => `è¾“å…¥æ¡†é”™è¯¯ï¼š${promptText}ï¼Œé”™è¯¯ï¼š${err}`,
        quickPickError: (err: string) => `å¿«é€Ÿé€‰æ‹©é”™è¯¯ï¼š${err}`,
        quickPickYes: () => "æ˜¯",
        quickPickNo: () => "å¦",
        watermarkView: () => "æ°´å°è§†å›¾",
        watermarkJsonFileInvalid: () => "æ°´å° JSON æ–‡ä»¶ä¸ºç©ºæˆ–æ— æ•ˆ",
        watermarkName: () => "æ°´å°åç§°",
        watermarkCopyAscii: () => "å¤åˆ¶ ASCII",
        watermarkZoomIn: () => "æ”¾å¤§",
        watermarkZoomOut: () => "ç¼©å°",
        watermarkPersonDisplayed: (name: string) => `æ°´å° '${name}' å·²æ˜¾ç¤ºã€‚`,
        watermarkChosen: (watermark: string[]) => `è¦æ˜¾ç¤ºçš„æ°´å°ï¼š${JSON.stringify(watermark)}`,
        watermarkNotFound: () => "æœªæ‰¾åˆ°æ°´å°",
        watermarkCopied: (name: string) => `${name} çš„ ASCII è‰ºæœ¯å·²å¤åˆ¶ï¼`,
        watermarkAuthorName: () => "ä½œè€…åç§°",
        darlingView: () => "è§’è‰²è§†å›¾",
        darlingJsonFileInvalid: () => "Darling JSON æ–‡ä»¶ä¸ºç©ºæˆ–æ— æ•ˆ",
        darlingPersonDisplayed: (name: string) => `è§’è‰² '${name}' å·²æ˜¾ç¤ºã€‚`,
        darlingCopyAscii: () => "å¤åˆ¶ ASCII",
        darlingZoomIn: () => "æ”¾å¤§",
        darlingZoomOut: () => "ç¼©å°",
        darlingType: () => "ç±»åž‹",
        darlingAge: () => "å¹´é¾„",
        darlingHeight: () => "èº«é«˜",
        darlingAlias: () => "åˆ«å",
        darlingDescription: () => "æè¿°",
        darlingQuote: () => "å¼•ç”¨",
        darlingMoreInfo: () => "æ›´å¤šä¿¡æ¯",
        darlingImage: () => "å›¾åƒ",
        darlingCopied: (name: string) => `${name} çš„ ASCII è‰ºæœ¯å·²å¤åˆ¶ï¼`,
        logoView: () => "å¾½æ ‡è§†å›¾",
        logoName: () => "å¾½æ ‡åç§°",
        logoMessage: (logoPath: string) => `æ–‡ä»¶ (${logoPath}) è¢«å¿½ç•¥ï¼Œå› ä¸ºå®ƒä¸æ˜¯æˆ‘ä»¬éœ€è¦çš„ç±»åž‹ã€‚`,
        logoNoRootDir: () => "æœªæä¾›ç”¨äºŽæ”¶é›†å¾½æ ‡çš„æ ¹ç›®å½•",
        logoRootDirUpdateError: (error: string) => `æ›´æ–°å¾½æ ‡æ–‡ä»¶æ—¶å‡ºé”™ï¼Œé”™è¯¯ï¼š${error}`,
        logoDisplayed: (name: string) => `å¾½æ ‡ '${name}' å·²æ˜¾ç¤ºã€‚`,
        logoCopied: (logoName: string) => `${logoName} çš„ ASCII è‰ºæœ¯å·²å¤åˆ¶ï¼`,
        logoChosen: (logo: string[]) => `è¦æ˜¾ç¤ºçš„å¾½æ ‡ï¼š${JSON.stringify(logo)}`,
        logoNotFound: () => "æœªæ‰¾åˆ°å¾½æ ‡",
        logoCopyAscii: () => "å¤åˆ¶ ASCII",
        logoZoomIn: () => "æ”¾å¤§",
        logoZoomOut: () => "ç¼©å°",
        noCommentToShow: () => "æ²¡æœ‰å¯æ˜¾ç¤ºçš„è¯„è®ºã€‚",
        unknown: () => "æœªçŸ¥",
        headerOpenerFound: () => "æ‰¾åˆ°å¤´éƒ¨å¼€å§‹æ ‡è®°ã€‚",
        headerOpenerAndCloserFound: () => "æ‰¾åˆ°å¤´éƒ¨å¼€å§‹å’Œç»“æŸæ ‡è®°ï¼Œè¿›è¡Œæ—¥æœŸæ›´æ–°å‰çš„æ£€æŸ¥ã€‚",
        headerWriteFailed: () => "å†™å…¥å¤´éƒ¨å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ—¥å¿—ã€‚",
        headerWriteSuccess: () => "å¤´éƒ¨å†™å…¥æˆåŠŸã€‚",
        headerNotFound: () => "æœªæ‰¾åˆ°å¤´éƒ¨ã€‚",
        headerInjectQuestion: () => "æœªæ‰¾åˆ°å¤´éƒ¨ã€‚æ˜¯å¦æ·»åŠ ä¸€ä¸ªï¼Ÿ",
        headerInjectQuestionRefused: () => "æ‚¨é€‰æ‹©ä¸å‘æ–‡ä»¶æ·»åŠ å¤´éƒ¨ã€‚",
        morseConverted: (input: string, final: string) => `å·²è½¬æ¢ï¼š${input} -> ${final}`,
        morseDecoded: (input: string, final: string) => `å·²è§£ç ï¼š${input} -> ${final}`,
        fileLoaded: (absolutePath: string) => `æ–‡ä»¶ ${absolutePath} å·²åŠ è½½ï¼`,
        fileParseError: (filePath: string, error: string) => `æ–‡ä»¶å†…å®¹ (${filePath}) åŠ è½½å¤±è´¥ã€‚é”™è¯¯ï¼š${error}ã€‚`,
        fileRefreshed: () => "åˆ·æ–°æ–‡ä»¶å†…å®¹ã€‚",
        filePathUpdated: (oldFilePath: string, newFilePath: string) => `è·¯å¾„å·²ä»Ž ${oldFilePath} æ›´æ–°ä¸º ${newFilePath}ã€‚`,
        fileUnloaded: (filePath: string) => `æ–‡ä»¶ ${filePath} å·²ä»Žå†…å­˜å¸è½½ã€‚`,
        fileExcludedActivationDisabled: () => "æ¿€æ´»å·²ç¦ç”¨ï¼Œæ–‡ä»¶åœ¨æŽ’é™¤åˆ—è¡¨ä¸­ã€‚",
        fileSaveFailed: () => "ä¿å­˜æ–‡ä»¶å¤±è´¥ï¼Œè¯·é‡è¯•ã€‚",
        cwdUpdated: (oldCwd: string, newCwd: string) => `å½“å‰å·¥ä½œç›®å½•å·²ä»Ž ${oldCwd} æ›´æ–°ä¸º ${newCwd}ã€‚`,
        cwdDoesNotExist: (cwd: string) => `æä¾›çš„å·¥ä½œç›®å½• ${cwd} ä¸å­˜åœ¨ã€‚`,
        updatingEditionDate: () => "æ›´æ–°ç‰ˆæœ¬æ—¥æœŸã€‚",
        documentLineScanExceeded: (maxScanLength: number) => `æ‰«ææ–‡ä»¶å‰ ${maxScanLength} è¡Œï¼Œä½†æœªæ‰¾åˆ°å¤´éƒ¨ã€‚`,
        closedDocument: () => "æ–‡æ¡£å·²å…³é—­ï¼Œåœæ­¢æ“ä½œã€‚",
        emptyDocument: () => "æ–‡æ¡£ä¸ºç©ºï¼Œæ— æ³•æ“ä½œã€‚",
        brokenHeader: () => "æ£€æµ‹åˆ°ç ´æŸçš„å¤´éƒ¨ï¼Œæ­£åœ¨æ³¨å…¥æ–°çš„ï¼Œè¯·åˆ é™¤æ—§çš„ã€‚",
        extensionActivated: (moduleName: string) => `ðŸš€ æ‰©å±• "${moduleName}" å·²æ¿€æ´»ï¼`,
        helloWorldGreetingsCommand: (moduleName: string) => `æ¥è‡ª ${moduleName} çš„ Hello Worldï¼`,
        noActiveEditor: () => "æ²¡æœ‰æ´»åŠ¨æ–‡ä»¶ï¼",
        noFocusedEditors: () => "æ²¡æœ‰ç„¦ç‚¹æ–‡ä»¶ã€‚",
        noLogoInstanceProvided: () => "æœªæä¾›å¾½æ ‡éšæœºå®žä¾‹ã€‚",
        randomLogoGatheringFailed: (error: string) => `éšæœºå¾½æ ‡æ”¶é›†å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤å¾½æ ‡ï¼Œé”™è¯¯ï¼š${error}`,
        ramdomLogoGatheringLogoUndefined: () => "å¾½æ ‡å†…å®¹æœªå®šä¹‰ã€‚",
        openFileToApplyHeader: () => "è¯·æ‰“å¼€ä¸€ä¸ªæ–‡ä»¶ä»¥åº”ç”¨å¤´éƒ¨ã€‚",
        corruptedFileMetaData: () => "æ–‡ä»¶å…ƒæ•°æ®æœªæ­£ç¡®æ”¶é›†ï¼Œä¸­æ­¢æ“ä½œã€‚",
        messageWritten: () => "æ¶ˆæ¯å·²å†™å…¥",
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string) => `Hello worldï¼æ‰©å±•åï¼š${fileExtension}ï¼Œæ–‡ä»¶åï¼š${fileName}ï¼Œè·¯å¾„ï¼š${filePath}ï¼Œè¯­è¨€ï¼š${languageId}\n`,
        missingFileError: () => "ç¼ºå°‘è¯­è¨€å­—å…¸ï¼Œå› æ­¤è¯„è®ºé€‚é…è¢«ç¦ç”¨ã€‚",
        unknownFileStructure: () => "è¯­è¨€å­—å…¸ç»“æž„æœªçŸ¥ï¼Œå› æ­¤è¯„è®ºé€‚é…è¢«ç¦ç”¨ã€‚",
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]) => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}ã€‚`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string) =>
            `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        identifiedLanguage: (langName: string) => `è¯†åˆ«çš„è¯­è¨€ï¼š${langName}ã€‚`,
        errorDuringFunctionCall: (functionName: string) => `è°ƒç”¨å‡½æ•° (${functionName}) æ—¶å‡ºé”™ï¼Œè¯·æŸ¥çœ‹æ—¥å¿—ã€‚`,
        missingLanguageComment: () => "æœªæä¾›è¯­è¨€æ³¨é‡Šï¼Œè·³è¿‡åˆ†é…ã€‚",
        getHeaderDescription: () => "è¯·è¾“å…¥æè¿°ï¼š",
        getHeaderTags: () => "è¯·è¾“å…¥æ–‡ä»¶æ ‡ç­¾ï¼Œç”¨é€—å·åˆ†éš”ï¼š",
        getHeaderPurpose: () => "è¯·è¾“å…¥æ–‡ä»¶ç”¨é€”ï¼š",
        noProvidedCommentOptions: () => "æœªæä¾›æ³¨é‡Šé€‰é¡¹ã€‚",
        chooseSingleLineCommentOption: () => "è¯·é€‰æ‹©ä»¥ä¸‹é€‰é¡¹ä¸­çš„é¦–é€‰æ³¨é‡Šå‰ç¼€ï¼š",
        updateAbortedBecauseFileClosedSyncCancelled: () => "æ›´æ–°ä¸­æ­¢ï¼Œå› ä¸ºæ–‡ä»¶å·²å…³é—­ä¸”ä¸ä¼šåŒæ­¥ã€‚",
        updateEditDateMissingBounds: () => "æ— æ³•æ›´æ–°å¤´éƒ¨ï¼šæœªæ‰¾åˆ°å†…éƒ¨æ ‡è®°ã€‚",
        lastModifiedLineNotFound: () => "å¤´éƒ¨ä¸­æœªæ‰¾åˆ°â€œæœ€åŽä¿®æ”¹â€è¡Œä»¥æ›´æ–°ã€‚",
        lastModifiedUpdated: () => "â€œæœ€åŽä¿®æ”¹â€æ—¥æœŸå·²æˆåŠŸæ›´æ–°ã€‚",
        languageNotFound: (LanguageId: string, fileExtension: string) => `æ— æ³•è¯†åˆ«æ–‡ä»¶è¯­è¨€ï¼ŒlanguageID: ${LanguageId}ï¼Œæ‰©å±•åï¼š${fileExtension}`,
        jsonContent: (jsonContentString: String) => `è¯„è®º JSON æ–‡ä»¶å†…å®¹ï¼š${jsonContentString}`,
        messageNotFound: (key: string) => `æœªæ‰¾åˆ°æ¶ˆæ¯ '${key}'ã€‚`
    },
    "zh-tw": {
        inputboxError: (promptText: string, err: string) => `è¼¸å…¥æ¡†éŒ¯èª¤ï¼š${promptText}ï¼ŒéŒ¯èª¤ï¼š${err}`,
        quickPickError: (err: string) => `å¿«é€Ÿé¸æ“‡éŒ¯èª¤ï¼š${err}`,
        quickPickYes: () => "æ˜¯",
        quickPickNo: () => "å¦",
        watermarkView: () => "æ°´å°æª¢è¦–",
        watermarkJsonFileInvalid: () => "æ°´å° JSON æª”æ¡ˆç‚ºç©ºæˆ–ç„¡æ•ˆ",
        watermarkName: () => "æ°´å°åç¨±",
        watermarkCopyAscii: () => "è¤‡è£½ ASCII",
        watermarkZoomIn: () => "æ”¾å¤§",
        watermarkZoomOut: () => "ç¸®å°",
        watermarkPersonDisplayed: (name: string) => `æ°´å° '${name}' å·²é¡¯ç¤ºã€‚`,
        watermarkChosen: (watermark: string[]) => `è¦é¡¯ç¤ºçš„æ°´å°ï¼š${JSON.stringify(watermark)}`,
        watermarkNotFound: () => "æœªæ‰¾åˆ°æ°´å°",
        watermarkCopied: (name: string) => `${name} çš„ ASCII è—è¡“å·²è¤‡è£½ï¼`,
        watermarkAuthorName: () => "ä½œè€…åç¨±",
        darlingView: () => "è§’è‰²æª¢è¦–",
        darlingJsonFileInvalid: () => "Darling JSON æª”æ¡ˆç‚ºç©ºæˆ–ç„¡æ•ˆ",
        darlingPersonDisplayed: (name: string) => `è§’è‰² '${name}' å·²é¡¯ç¤ºã€‚`,
        darlingCopyAscii: () => "è¤‡è£½ ASCII",
        darlingZoomIn: () => "æ”¾å¤§",
        darlingZoomOut: () => "ç¸®å°",
        darlingType: () => "é¡žåž‹",
        darlingAge: () => "å¹´é½¡",
        darlingHeight: () => "èº«é«˜",
        darlingAlias: () => "åˆ¥å",
        darlingDescription: () => "æè¿°",
        darlingQuote: () => "å¼•ç”¨",
        darlingMoreInfo: () => "æ›´å¤šè³‡è¨Š",
        darlingImage: () => "åœ–ç‰‡",
        darlingCopied: (name: string) => `${name} çš„ ASCII è—è¡“å·²è¤‡è£½ï¼`,
        logoView: () => "å¾½æ¨™æª¢è¦–",
        logoName: () => "å¾½æ¨™åç¨±",
        logoMessage: (logoPath: string) => `æª”æ¡ˆ (${logoPath}) è¢«å¿½ç•¥ï¼Œå› ç‚ºå®ƒä¸æ˜¯æ‰€éœ€é¡žåž‹ã€‚`,
        logoNoRootDir: () => "æœªæä¾›ç”¨æ–¼æ”¶é›†å¾½æ¨™çš„æ ¹ç›®éŒ„",
        logoRootDirUpdateError: (error: string) => `æ›´æ–°å¾½æ¨™æª”æ¡ˆæ™‚å‡ºéŒ¯ï¼ŒéŒ¯èª¤ï¼š${error}`,
        logoDisplayed: (name: string) => `å¾½æ¨™ '${name}' å·²é¡¯ç¤ºã€‚`,
        logoCopied: (logoName: string) => `${logoName} çš„ ASCII è—è¡“å·²è¤‡è£½ï¼`,
        logoChosen: (logo: string[]) => `è¦é¡¯ç¤ºçš„å¾½æ¨™ï¼š${JSON.stringify(logo)}`,
        logoNotFound: () => "æœªæ‰¾åˆ°å¾½æ¨™",
        logoCopyAscii: () => "è¤‡è£½ ASCII",
        logoZoomIn: () => "æ”¾å¤§",
        logoZoomOut: () => "ç¸®å°",
        noCommentToShow: () => "æ²’æœ‰å¯é¡¯ç¤ºçš„è©•è«–ã€‚",
        unknown: () => "æœªçŸ¥",
        headerOpenerFound: () => "æ‰¾åˆ°é ­éƒ¨é–‹å§‹æ¨™è¨˜ã€‚",
        headerOpenerAndCloserFound: () => "æ‰¾åˆ°é ­éƒ¨é–‹å§‹å’ŒçµæŸæ¨™è¨˜ï¼Œé€²è¡Œæ—¥æœŸæ›´æ–°å‰çš„æª¢æŸ¥ã€‚",
        headerWriteFailed: () => "å¯«å…¥é ­éƒ¨å¤±æ•—ï¼Œè«‹æª¢æŸ¥æ—¥èªŒã€‚",
        headerWriteSuccess: () => "é ­éƒ¨å¯«å…¥æˆåŠŸã€‚",
        headerNotFound: () => "æœªæ‰¾åˆ°é ­éƒ¨ã€‚",
        headerInjectQuestion: () => "æœªæ‰¾åˆ°é ­éƒ¨ã€‚æ˜¯å¦æ·»åŠ ä¸€å€‹ï¼Ÿ",
        headerInjectQuestionRefused: () => "æ‚¨é¸æ“‡ä¸å‘æª”æ¡ˆæ·»åŠ é ­éƒ¨ã€‚",
        morseConverted: (input: string, final: string) => `å·²è½‰æ›ï¼š${input} -> ${final}`,
        morseDecoded: (input: string, final: string) => `å·²è§£ç¢¼ï¼š${input} -> ${final}`,
        fileLoaded: (absolutePath: string) => `æª”æ¡ˆ ${absolutePath} å·²åŠ è¼‰ï¼`,
        fileParseError: (filePath: string, error: string) => `æª”æ¡ˆå…§å®¹ (${filePath}) åŠ è¼‰å¤±æ•—ã€‚éŒ¯èª¤ï¼š${error}ã€‚`,
        fileRefreshed: () => "åˆ·æ–°æª”æ¡ˆå…§å®¹ã€‚",
        filePathUpdated: (oldFilePath: string, newFilePath: string) => `è·¯å¾‘å·²å¾ž ${oldFilePath} æ›´æ–°ç‚º ${newFilePath}ã€‚`,
        fileUnloaded: (filePath: string) => `æª”æ¡ˆ ${filePath} å·²å¾žè¨˜æ†¶é«”å¸è¼‰ã€‚`,
        fileExcludedActivationDisabled: () => "å•Ÿç”¨å·²ç¦ç”¨ï¼Œæª”æ¡ˆåœ¨æŽ’é™¤æ¸…å–®ä¸­ã€‚",
        fileSaveFailed: () => "ä¿å­˜æª”æ¡ˆå¤±æ•—ï¼Œè«‹é‡è©¦ã€‚",
        cwdUpdated: (oldCwd: string, newCwd: string) => `ç•¶å‰å·¥ä½œç›®éŒ„å·²å¾ž ${oldCwd} æ›´æ–°ç‚º ${newCwd}ã€‚`,
        cwdDoesNotExist: (cwd: string) => `æä¾›çš„å·¥ä½œç›®éŒ„ ${cwd} ä¸å­˜åœ¨ã€‚`,
        updatingEditionDate: () => "æ›´æ–°ç‰ˆæœ¬æ—¥æœŸã€‚",
        documentLineScanExceeded: (maxScanLength: number) => `æŽƒææª”æ¡ˆå‰ ${maxScanLength} è¡Œï¼Œä½†æœªæ‰¾åˆ°é ­éƒ¨ã€‚`,
        closedDocument: () => "æ–‡ä»¶å·²é—œé–‰ï¼Œåœæ­¢æ“ä½œã€‚",
        emptyDocument: () => "æ–‡ä»¶ç‚ºç©ºï¼Œç„¡æ³•æ“ä½œã€‚",
        brokenHeader: () => "æª¢æ¸¬åˆ°ç ´æçš„é ­éƒ¨ï¼Œæ­£åœ¨æ³¨å…¥æ–°çš„ï¼Œè«‹åˆªé™¤èˆŠçš„ã€‚",
        extensionActivated: (moduleName: string) => `ðŸš€ æ“´å±• "${moduleName}" å·²å•Ÿå‹•ï¼`,
        helloWorldGreetingsCommand: (moduleName: string) => `ä¾†è‡ª ${moduleName} çš„ Hello Worldï¼`,
        noActiveEditor: () => "æ²’æœ‰æ´»å‹•æª”æ¡ˆï¼",
        noFocusedEditors: () => "æ²’æœ‰ç„¦é»žæª”æ¡ˆã€‚",
        noLogoInstanceProvided: () => "æœªæä¾›å¾½æ¨™éš¨æ©Ÿå¯¦ä¾‹ã€‚",
        randomLogoGatheringFailed: (error: string) => `éš¨æ©Ÿå¾½æ¨™æ”¶é›†å¤±æ•—ï¼Œä½¿ç”¨é è¨­å¾½æ¨™ï¼ŒéŒ¯èª¤ï¼š${error}`,
        ramdomLogoGatheringLogoUndefined: () => "å¾½æ¨™å…§å®¹æœªå®šç¾©ã€‚",
        openFileToApplyHeader: () => "è«‹æ‰“é–‹ä¸€å€‹æª”æ¡ˆä»¥æ‡‰ç”¨é ­éƒ¨ã€‚",
        corruptedFileMetaData: () => "æª”æ¡ˆå…ƒè³‡æ–™æœªæ­£ç¢ºæ”¶é›†ï¼Œä¸­æ­¢æ“ä½œã€‚",
        messageWritten: () => "æ¶ˆæ¯å·²å¯«å…¥",
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string) => `Hello worldï¼å‰¯æª”åï¼š${fileExtension}ï¼Œæª”åï¼š${fileName}ï¼Œè·¯å¾‘ï¼š${filePath}ï¼Œèªžè¨€ï¼š${languageId}\n`,
        missingFileError: () => "ç¼ºå°‘èªžè¨€å­—å…¸ï¼Œå› æ­¤è©•è«–é©é…è¢«ç¦ç”¨ã€‚",
        unknownFileStructure: () => "èªžè¨€å­—å…¸çµæ§‹æœªçŸ¥ï¼Œå› æ­¤è©•è«–é©é…è¢«ç¦ç”¨ã€‚",
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]) => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}ã€‚`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string) =>
            `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        identifiedLanguage: (langName: string) => `è­˜åˆ¥çš„èªžè¨€ï¼š${langName}ã€‚`,
        errorDuringFunctionCall: (functionName: string) => `å‘¼å«å‡½æ•¸ (${functionName}) æ™‚ç™¼ç”ŸéŒ¯èª¤ï¼Œè«‹æŸ¥çœ‹æ—¥èªŒã€‚`,
        missingLanguageComment: () => "æœªæä¾›èªžè¨€è¨»è§£ï¼Œè·³éŽåˆ†é…ã€‚",
        getHeaderDescription: () => "è«‹æä¾›æè¿°ï¼š",
        getHeaderTags: () => "è«‹è¼¸å…¥æª”æ¡ˆæ¨™ç±¤ï¼Œç”¨é€—è™Ÿåˆ†éš”ï¼š",
        getHeaderPurpose: () => "è«‹æä¾›æª”æ¡ˆç”¨é€”ï¼š",
        noProvidedCommentOptions: () => "æœªæä¾›è¨»è§£é¸é …ã€‚",
        chooseSingleLineCommentOption: () => "è«‹å¾žä¸‹åˆ—é¸é …ä¸­é¸æ“‡é¦–é¸è¨»è§£å‰ç¶´ï¼š",
        updateAbortedBecauseFileClosedSyncCancelled: () => "æ›´æ–°ä¸­æ­¢ï¼Œå› ç‚ºæª”æ¡ˆå·²é—œé–‰ä¸”ä¸æœƒåŒæ­¥ã€‚",
        updateEditDateMissingBounds: () => "ç„¡æ³•æ›´æ–°é ­éƒ¨ï¼šæœªæ‰¾åˆ°å…§éƒ¨æ¨™è¨˜ã€‚",
        lastModifiedLineNotFound: () => "é ­éƒ¨ä¸­æœªæ‰¾åˆ°â€œæœ€å¾Œä¿®æ”¹â€è¡Œä»¥æ›´æ–°ã€‚",
        lastModifiedUpdated: () => "â€œæœ€å¾Œä¿®æ”¹â€æ—¥æœŸå·²æˆåŠŸæ›´æ–°ã€‚",
        languageNotFound: (LanguageId: string, fileExtension: string) => `ç„¡æ³•è­˜åˆ¥æª”æ¡ˆèªžè¨€ï¼ŒlanguageID: ${LanguageId}ï¼Œå‰¯æª”åï¼š${fileExtension}`,
        jsonContent: (jsonContentString: String) => `è¨»è§£ JSON æª”æ¡ˆå…§å®¹ï¼š${jsonContentString}`,
        messageNotFound: (key: string) => `æœªæ‰¾åˆ°æ¶ˆæ¯ '${key}'ã€‚`
    },
    "de": {
        inputboxError: (promptText: string, err: string) => `Fehler im Eingabefeld fÃ¼r ${promptText}: ${err}`,
        quickPickError: (err: string) => `Fehler in QuickPick: ${err}`,
        quickPickYes: () => "Ja",
        quickPickNo: () => "Nein",
        watermarkView: () => "Wasserzeichen-Ansicht",
        watermarkJsonFileInvalid: () => "Wasserzeichen JSON-Datei ist leer oder ungÃ¼ltig",
        watermarkName: () => "Wasserzeichenname",
        watermarkCopyAscii: () => "ASCII kopieren",
        watermarkZoomIn: () => "VergrÃ¶ÃŸern",
        watermarkZoomOut: () => "Verkleinern",
        watermarkPersonDisplayed: (name: string) => `Wasserzeichen '${name}' angezeigt.`,
        watermarkChosen: (watermark: string[]) => `Anzuzeigendes Wasserzeichen: ${JSON.stringify(watermark)}`,
        watermarkNotFound: () => "Wasserzeichen nicht gefunden",
        watermarkCopied: (name: string) => `ASCII-Kunst fÃ¼r ${name} kopiert!`,
        watermarkAuthorName: () => "Autor",
        darlingView: () => "Charakter-Ansicht",
        darlingJsonFileInvalid: () => "Darling JSON-Datei ist leer oder ungÃ¼ltig",
        darlingPersonDisplayed: (name: string) => `Charakter '${name}' angezeigt.`,
        darlingCopyAscii: () => "ASCII kopieren",
        darlingZoomIn: () => "VergrÃ¶ÃŸern",
        darlingZoomOut: () => "Verkleinern",
        darlingType: () => "Typ",
        darlingAge: () => "Alter",
        darlingHeight: () => "GrÃ¶ÃŸe",
        darlingAlias: () => "Alias",
        darlingDescription: () => "Beschreibung",
        darlingQuote: () => "Zitat",
        darlingMoreInfo: () => "Weitere Infos",
        darlingImage: () => "Bild",
        darlingCopied: (name: string) => `ASCII-Kunst fÃ¼r ${name} kopiert!`,
        logoView: () => "Logo-Ansicht",
        logoName: () => "Logoname",
        logoMessage: (logoPath: string) => `Datei (${logoPath}) ignoriert, da sie nicht vom gesuchten Typ ist.`,
        logoNoRootDir: () => "Kein Stammverzeichnis zur Sammlung von Logos angegeben",
        logoRootDirUpdateError: (error: string) => `Fehler beim Aktualisieren der Logodateien, Fehler: ${error}`,
        logoDisplayed: (name: string) => `Logo '${name}' angezeigt.`,
        logoCopied: (logoName: string) => `ASCII-Kunst fÃ¼r ${logoName} kopiert!`,
        logoChosen: (logo: string[]) => `Anzuzeigendes Logo: ${JSON.stringify(logo)}`,
        logoNotFound: () => "Logo nicht gefunden",
        logoCopyAscii: () => "ASCII kopieren",
        logoZoomIn: () => "VergrÃ¶ÃŸern",
        logoZoomOut: () => "Verkleinern",
        noCommentToShow: () => "Kein Kommentar zum Anzeigen.",
        unknown: () => "Unbekannt",
        headerOpenerFound: () => "Header-Start gefunden.",
        headerOpenerAndCloserFound: () => "Header-Start und -Ende gefunden, aktualisiere das Datum nach ÃœberprÃ¼fung.",
        headerWriteFailed: () => "Header konnte nicht in die Datei geschrieben werden, prÃ¼fen Sie die Logs.",
        headerWriteSuccess: () => "Header erfolgreich geschrieben.",
        headerNotFound: () => "Kein Header in diesem Dokument gefunden.",
        headerInjectQuestion: () => "Kein Header gefunden. MÃ¶chten Sie einen hinzufÃ¼gen?",
        headerInjectQuestionRefused: () => "Sie haben entschieden, keinen Header hinzuzufÃ¼gen.",
        morseConverted: (input: string, final: string) => `Konvertiert: ${input} -> ${final}`,
        morseDecoded: (input: string, final: string) => `Dekodiert: ${input} -> ${final}`,
        fileLoaded: (absolutePath: string) => `Datei ${absolutePath} geladen!`,
        fileParseError: (filePath: string, error: string) => `Dateiinhalt (${filePath}) konnte nicht erfolgreich geladen werden. Fehler: ${error}.`,
        fileRefreshed: () => "Dateiinhalt wird aktualisiert.",
        filePathUpdated: (oldFilePath: string, newFilePath: string) => `Pfad wurde von ${oldFilePath} auf ${newFilePath} aktualisiert.`,
        fileUnloaded: (filePath: string) => `Datei ${filePath} aus dem Speicher entfernt.`,
        fileExcludedActivationDisabled: () => "Aktivierung deaktiviert, Datei ist auf der Ausschlussliste.",
        fileSaveFailed: () => "Datei konnte nicht gespeichert werden, bitte erneut versuchen.",
        cwdUpdated: (oldCwd: string, newCwd: string) => `Das aktuelle Arbeitsverzeichnis wurde von ${oldCwd} auf ${newCwd} aktualisiert.`,
        cwdDoesNotExist: (cwd: string) => `Das angegebene Arbeitsverzeichnis ${cwd} existiert nicht.`,
        updatingEditionDate: () => "Aktualisiere das Erstellungsdatum.",
        documentLineScanExceeded: (maxScanLength: number) => `Erste ${maxScanLength} Zeilen der Datei gescannt, kein Header gefunden.`,
        closedDocument: () => "Das Dokument ist geschlossen, Operationen gestoppt.",
        emptyDocument: () => "Kein Dokument vorhanden.",
        brokenHeader: () => "BeschÃ¤digter Header erkannt, fÃ¼ge neuen Header ein, bitte vorherigen entfernen.",
        extensionActivated: (moduleName: string) => `ðŸš€ Erweiterung "${moduleName}" ist jetzt aktiv!`,
        helloWorldGreetingsCommand: (moduleName: string) => `Hello World von ${moduleName}!`,
        noActiveEditor: () => "Keine aktive Datei!",
        noFocusedEditors: () => "Keine fokussierten Dateien.",
        noLogoInstanceProvided: () => "Keine Logo-Randomizer-Instanz bereitgestellt.",
        randomLogoGatheringFailed: (error: string) => `ZufÃ¤lliges Logo konnte nicht geladen werden, Standardlogo wird verwendet, Fehler: "${error}"`,
        ramdomLogoGatheringLogoUndefined: () => "Logo-Inhalt ist undefiniert.",
        openFileToApplyHeader: () => "Bitte Ã¶ffnen Sie eine Datei, um den Header anzuwenden.",
        corruptedFileMetaData: () => "Datei-Metadaten wurden nicht korrekt gesammelt, Abbruch.",
        messageWritten: () => "Nachricht geschrieben",
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string) => `Hello World! Dateiendung: ${fileExtension}, Name: ${fileName}, Pfad: ${filePath}, Sprache: ${languageId}\n`,
        missingFileError: () => "SprachwÃ¶rterbuch fehlt, Kommentar-Anpassung deaktiviert.",
        unknownFileStructure: () => "SprachwÃ¶rterbuchstruktur unbekannt, Kommentar-Anpassung deaktiviert.",
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]) => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}.`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string) =>
            `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        identifiedLanguage: (langName: string) => `Identifizierte Sprache: ${langName}.`,
        errorDuringFunctionCall: (functionName: string) => `Fehler beim Aufruf der Funktion (${functionName}), prÃ¼fen Sie die Logs.`,
        missingLanguageComment: () => "Sprachkommentar nicht bereitgestellt, Zuweisung Ã¼bersprungen.",
        getHeaderDescription: () => "Bitte Beschreibung angeben:",
        getHeaderTags: () => "Bitte Tags fÃ¼r diese Datei eingeben, durch Kommas getrennt:",
        getHeaderPurpose: () => "Bitte Zweck der Datei angeben:",
        noProvidedCommentOptions: () => "Keine Kommentaroptionen bereitgestellt.",
        chooseSingleLineCommentOption: () => "Bitte bevorzugten KommentarprÃ¤fix aus den Optionen unten auswÃ¤hlen:",
        updateAbortedBecauseFileClosedSyncCancelled: () => "Update abgebrochen, da die Datei geschlossen ist und nicht synchronisiert wird.",
        updateEditDateMissingBounds: () => "Header konnte nicht aktualisiert werden: interne Marker nicht gefunden.",
        lastModifiedLineNotFound: () => "Header enthÃ¤lt keine 'Zuletzt geÃ¤ndert'-Zeile zum Aktualisieren.",
        lastModifiedUpdated: () => "'Zuletzt geÃ¤ndert'-Datum erfolgreich aktualisiert.",
        languageNotFound: (LanguageId: string, fileExtension: string) => `Dateisprache konnte nicht erkannt werden, languageID: ${LanguageId}, Dateierweiterung: ${fileExtension}`,
        jsonContent: (jsonContentString: String) => `Inhalt der Kommentar-JSON-Datei: ${jsonContentString}`,
        messageNotFound: (key: string) => `Nachricht '${key}' nicht gefunden.`
    },
    "ja": {
        inputboxError: (promptText: string, err: string) => `${promptText} ã®å…¥åŠ›ãƒœãƒƒã‚¯ã‚¹ã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ${err}`,
        quickPickError: (err: string) => `QuickPick ã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ${err}`,
        quickPickYes: () => "ã¯ã„",
        quickPickNo: () => "ã„ã„ãˆ",
        watermarkView: () => "ã‚¦ã‚©ãƒ¼ã‚¿ãƒ¼ãƒžãƒ¼ã‚¯ãƒ“ãƒ¥ãƒ¼",
        watermarkJsonFileInvalid: () => "ã‚¦ã‚©ãƒ¼ã‚¿ãƒ¼ãƒžãƒ¼ã‚¯ JSON ãƒ•ã‚¡ã‚¤ãƒ«ãŒç©ºã¾ãŸã¯ç„¡åŠ¹ã§ã™",
        watermarkName: () => "ã‚¦ã‚©ãƒ¼ã‚¿ãƒ¼ãƒžãƒ¼ã‚¯å",
        watermarkCopyAscii: () => "ASCII ã‚’ã‚³ãƒ”ãƒ¼",
        watermarkZoomIn: () => "ã‚ºãƒ¼ãƒ ã‚¤ãƒ³",
        watermarkZoomOut: () => "ã‚ºãƒ¼ãƒ ã‚¢ã‚¦ãƒˆ",
        watermarkPersonDisplayed: (name: string) => `ã‚¦ã‚©ãƒ¼ã‚¿ãƒ¼ãƒžãƒ¼ã‚¯ '${name}' ã‚’è¡¨ç¤ºã—ã¾ã—ãŸã€‚`,
        watermarkChosen: (watermark: string[]) => `è¡¨ç¤ºã™ã‚‹ã‚¦ã‚©ãƒ¼ã‚¿ãƒ¼ãƒžãƒ¼ã‚¯: ${JSON.stringify(watermark)}`,
        watermarkNotFound: () => "ã‚¦ã‚©ãƒ¼ã‚¿ãƒ¼ãƒžãƒ¼ã‚¯ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“",
        watermarkCopied: (name: string) => `${name} ã® ASCII ã‚¢ãƒ¼ãƒˆã‚’ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸï¼`,
        watermarkAuthorName: () => "ä½œæˆè€…å",
        darlingView: () => "ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ãƒ“ãƒ¥ãƒ¼",
        darlingJsonFileInvalid: () => "Darling JSON ãƒ•ã‚¡ã‚¤ãƒ«ãŒç©ºã¾ãŸã¯ç„¡åŠ¹ã§ã™",
        darlingPersonDisplayed: (name: string) => `ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ '${name}' ã‚’è¡¨ç¤ºã—ã¾ã—ãŸã€‚`,
        darlingCopyAscii: () => "ASCII ã‚’ã‚³ãƒ”ãƒ¼",
        darlingZoomIn: () => "ã‚ºãƒ¼ãƒ ã‚¤ãƒ³",
        darlingZoomOut: () => "ã‚ºãƒ¼ãƒ ã‚¢ã‚¦ãƒˆ",
        darlingType: () => "ã‚¿ã‚¤ãƒ—",
        darlingAge: () => "å¹´é½¢",
        darlingHeight: () => "èº«é•·",
        darlingAlias: () => "åˆ¥å",
        darlingDescription: () => "èª¬æ˜Ž",
        darlingQuote: () => "å¼•ç”¨",
        darlingMoreInfo: () => "è©³ç´°æƒ…å ±",
        darlingImage: () => "ç”»åƒ",
        darlingCopied: (name: string) => `${name} ã® ASCII ã‚¢ãƒ¼ãƒˆã‚’ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸï¼`,
        logoView: () => "ãƒ­ã‚´ãƒ“ãƒ¥ãƒ¼",
        logoName: () => "ãƒ­ã‚´å",
        logoMessage: (logoPath: string) => `ãƒ•ã‚¡ã‚¤ãƒ« (${logoPath}) ã¯å¯¾è±¡ã‚¿ã‚¤ãƒ—ã§ã¯ãªã„ãŸã‚ç„¡è¦–ã•ã‚Œã¾ã—ãŸã€‚`,
        logoNoRootDir: () => "ãƒ­ã‚´ã‚’åŽé›†ã™ã‚‹ãŸã‚ã®ãƒ«ãƒ¼ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãŒæä¾›ã•ã‚Œã¦ã„ã¾ã›ã‚“",
        logoRootDirUpdateError: (error: string) => `ãƒ­ã‚´ãƒ•ã‚¡ã‚¤ãƒ«ã®æ›´æ–°ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ${error}`,
        logoDisplayed: (name: string) => `ãƒ­ã‚´ '${name}' ã‚’è¡¨ç¤ºã—ã¾ã—ãŸã€‚`,
        logoCopied: (logoName: string) => `${logoName} ã® ASCII ã‚¢ãƒ¼ãƒˆã‚’ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸï¼`,
        logoChosen: (logo: string[]) => `è¡¨ç¤ºã™ã‚‹ãƒ­ã‚´: ${JSON.stringify(logo)}`,
        logoNotFound: () => "ãƒ­ã‚´ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“",
        logoCopyAscii: () => "ASCII ã‚’ã‚³ãƒ”ãƒ¼",
        noCommentToShow: () => "è¡¨ç¤ºã™ã‚‹ã‚³ãƒ¡ãƒ³ãƒˆã¯ã‚ã‚Šã¾ã›ã‚“ã€‚",
        unknown: () => "ä¸æ˜Ž",
        headerOpenerFound: () => "ãƒ˜ãƒƒãƒ€ãƒ¼ã®é–‹å§‹ãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸã€‚",
        headerOpenerAndCloserFound: () => "ãƒ˜ãƒƒãƒ€ãƒ¼ã®é–‹å§‹ã¨çµ‚äº†ãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸã€‚ãƒã‚§ãƒƒã‚¯å¾Œã€æ—¥ä»˜ã‚’æ›´æ–°ã—ã¾ã™ã€‚",
        headerWriteFailed: () => "ãƒ•ã‚¡ã‚¤ãƒ«ã«ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’æ›¸ãè¾¼ã‚ã¾ã›ã‚“ã§ã—ãŸã€‚ãƒ­ã‚°ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚",
        headerWriteSuccess: () => "ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’æ›¸ãè¾¼ã¿ã¾ã—ãŸã€‚",
        headerNotFound: () => "ã“ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã«ãƒ˜ãƒƒãƒ€ãƒ¼ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚",
        headerInjectQuestion: () => "ã“ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã«ãƒ˜ãƒƒãƒ€ãƒ¼ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚è¿½åŠ ã—ã¾ã™ã‹ï¼Ÿ",
        headerInjectQuestionRefused: () => "ãƒ•ã‚¡ã‚¤ãƒ«ã«ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’è¿½åŠ ã—ãªã„ã“ã¨ã«ã—ã¾ã—ãŸã€‚",
        morseConverted: (input: string, final: string) => `å¤‰æ›: ${input} â†’ ${final}`,
        morseDecoded: (input: string, final: string) => `å¾©å·: ${input} â†’ ${final}`,
        fileLoaded: (absolutePath: string) => `ãƒ•ã‚¡ã‚¤ãƒ« ${absolutePath} ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸï¼`,
        fileParseError: (filePath: string, error: string) => `ãƒ•ã‚¡ã‚¤ãƒ«ã®å†…å®¹ (${filePath}) ã‚’æ­£å¸¸ã«èª­ã¿è¾¼ã‚ã¾ã›ã‚“ã§ã—ãŸã€‚ã‚¨ãƒ©ãƒ¼: ${error}ã€‚`,
        fileRefreshed: () => "ãƒ•ã‚¡ã‚¤ãƒ«å†…å®¹ã‚’æ›´æ–°ã—ã¦ã„ã¾ã™ã€‚",
        filePathUpdated: (oldFilePath: string, newFilePath: string) => `ãƒ‘ã‚¹ã‚’ ${oldFilePath} ã‹ã‚‰ ${newFilePath} ã«æ›´æ–°ã—ã¾ã—ãŸã€‚`,
        fileUnloaded: (filePath: string) => `ãƒ•ã‚¡ã‚¤ãƒ« ${filePath} ã‚’ãƒ¡ãƒ¢ãƒªã‹ã‚‰ã‚¢ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¾ã—ãŸã€‚`,
        fileExcludedActivationDisabled: () => "ã‚¢ã‚¯ãƒ†ã‚£ãƒ™ãƒ¼ã‚·ãƒ§ãƒ³ã¯ç„¡åŠ¹ã§ã™ã€‚ãƒ•ã‚¡ã‚¤ãƒ«ã¯é™¤å¤–ãƒªã‚¹ãƒˆã«ã‚ã‚Šã¾ã™ã€‚",
        fileSaveFailed: () => "ãƒ•ã‚¡ã‚¤ãƒ«ã®ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ã‚‚ã†ä¸€åº¦ä¿å­˜ã—ã¦ãã ã•ã„ã€‚",
        cwdUpdated: (oldCwd: string, newCwd: string) => `ç¾åœ¨ã®ä½œæ¥­ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ ${oldCwd} ã‹ã‚‰ ${newCwd} ã«æ›´æ–°ã—ã¾ã—ãŸã€‚`,
        cwdDoesNotExist: (cwd: string) => `æŒ‡å®šã•ã‚ŒãŸä½œæ¥­ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª ${cwd} ã¯å­˜åœ¨ã—ã¾ã›ã‚“ã€‚`,
        updatingEditionDate: () => "ç·¨é›†æ—¥ã‚’æ›´æ–°ã—ã¦ã„ã¾ã™ã€‚",
        documentLineScanExceeded: (maxScanLength: number) => `ãƒ•ã‚¡ã‚¤ãƒ«ã®æœ€åˆã® ${maxScanLength} è¡Œã‚’ã‚¹ã‚­ãƒ£ãƒ³ã—ã¾ã—ãŸãŒã€ãƒ˜ãƒƒãƒ€ãƒ¼ã¯è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚`,
        closedDocument: () => "ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã¯é–‰ã˜ã‚‰ã‚Œã¾ã—ãŸã€‚æ“ä½œã‚’åœæ­¢ã—ã¾ã™ã€‚",
        emptyDocument: () => "ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã®æœ¬æ–‡ãŒã‚ã‚Šã¾ã›ã‚“ã€‚",
        brokenHeader: () => "å£Šã‚ŒãŸãƒ˜ãƒƒãƒ€ãƒ¼ãŒæ¤œå‡ºã•ã‚Œã¾ã—ãŸã€‚æ–°ã—ã„ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’æŒ¿å…¥ã—ã¾ã™ã€‚å‰ã®ã‚‚ã®ã‚’å‰Šé™¤ã—ã¦ãã ã•ã„ã€‚",
        extensionActivated: (moduleName: string) => `ðŸš€ "${moduleName}" æ‹¡å¼µæ©Ÿèƒ½ãŒã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã«ãªã‚Šã¾ã—ãŸï¼`,
        helloWorldGreetingsCommand: (moduleName: string) => `Hello World from ${moduleName}ï¼`,
        noActiveEditor: () => "ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒ•ã‚¡ã‚¤ãƒ«ãŒã‚ã‚Šã¾ã›ã‚“ï¼",
        noFocusedEditors: () => "ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ã•ã‚Œã¦ã„ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚",
        noLogoInstanceProvided: () => "æä¾›ã•ã‚ŒãŸãƒ­ã‚´ãƒ©ãƒ³ãƒ€ãƒžã‚¤ã‚¶ãƒ¼ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒã‚ã‚Šã¾ã›ã‚“ã€‚",
        randomLogoGatheringFailed: (error: string) => `ãƒ©ãƒ³ãƒ€ãƒ ãƒ­ã‚´ã®åŽé›†ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ­ã‚´ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚ã‚¨ãƒ©ãƒ¼: "${error}"`,
        ramdomLogoGatheringLogoUndefined: () => "ãƒ­ã‚´ã®å†…å®¹ãŒæœªå®šç¾©ã§ã™ã€‚",
        openFileToApplyHeader: () => "ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’é©ç”¨ã™ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ã„ã¦ãã ã•ã„ã€‚",
        corruptedFileMetaData: () => "å¿…è¦ãªãƒ•ã‚¡ã‚¤ãƒ«ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ãŒæ­£ã—ãåŽé›†ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚ä¸­æ­¢ã—ã¾ã™ã€‚",
        messageWritten: () => "ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æ›¸ãè¾¼ã¿ã¾ã—ãŸ",
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string) =>
            `Hello World! ãƒ•ã‚¡ã‚¤ãƒ«ã®æ‹¡å¼µå­: ${fileExtension}, åå‰: ${fileName}, ãƒ‘ã‚¹: ${filePath}, è¨€èªž: ${languageId}\n`,
        missingFileError: () => "è¨€èªžè¾žæ›¸ãŒã‚ã‚Šã¾ã›ã‚“ã€‚ã‚³ãƒ¡ãƒ³ãƒˆã®é©å¿œæ€§ã¯ç„¡åŠ¹ã§ã™ã€‚",
        unknownFileStructure: () => "è¨€èªžè¾žæ›¸ã®æ§‹é€ ãŒä¸æ˜Žã§ã™ã€‚ã‚³ãƒ¡ãƒ³ãƒˆã®é©å¿œæ€§ã¯ç„¡åŠ¹ã§ã™ã€‚",
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]) =>
            `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}ã€‚`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string) =>
            `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        identifiedLanguage: (langName: string) => `è­˜åˆ¥ã•ã‚ŒãŸè¨€èªž: ${langName}ã€‚`,
        errorDuringFunctionCall: (functionName: string) => `é–¢æ•° (${functionName}) ã®å‘¼ã³å‡ºã—ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ãƒ­ã‚°ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚`,
        missingLanguageComment: () => "è¨€èªžã‚³ãƒ¡ãƒ³ãƒˆãŒæä¾›ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚å‰²ã‚Šå½“ã¦ã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã™ã€‚",
        getHeaderDescription: () => "èª¬æ˜Žã‚’å…¥åŠ›ã—ã¦ãã ã•ã„: ",
        getHeaderTags: () => "ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚¿ã‚°ã‚’ã‚«ãƒ³ãƒžã§åŒºåˆ‡ã£ã¦å…¥åŠ›ã—ã¦ãã ã•ã„: ",
        getHeaderPurpose: () => "ãƒ•ã‚¡ã‚¤ãƒ«ã®ç›®çš„ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„: ",
        noProvidedCommentOptions: () => "æä¾›ã•ã‚ŒãŸã‚³ãƒ¡ãƒ³ãƒˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚",
        chooseSingleLineCommentOption: () => "ä»¥ä¸‹ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‹ã‚‰ã‚³ãƒ¡ãƒ³ãƒˆã®ãƒ—ãƒ¬ãƒ•ã‚£ãƒƒã‚¯ã‚¹ã‚’é¸æŠžã—ã¦ãã ã•ã„: ",
        updateAbortedBecauseFileClosedSyncCancelled: () => "ãƒ•ã‚¡ã‚¤ãƒ«ãŒé–‰ã˜ã‚‰ã‚Œã¦ã„ã‚‹ãŸã‚ã€æ›´æ–°ã¯ä¸­æ­¢ã•ã‚ŒåŒæœŸã•ã‚Œã¾ã›ã‚“ã€‚",
        updateEditDateMissingBounds: () => "ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’æ›´æ–°ã§ãã¾ã›ã‚“: å†…éƒ¨ãƒžãƒ¼ã‚«ãƒ¼ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚",
        lastModifiedLineNotFound: () => "ãƒ˜ãƒƒãƒ€ãƒ¼ã«ã€Œæœ€çµ‚æ›´æ–°æ—¥ã€è¡ŒãŒã‚ã‚Šã¾ã›ã‚“ã€‚",
        lastModifiedUpdated: () => "ã€Œæœ€çµ‚æ›´æ–°æ—¥ã€ãŒæ­£å¸¸ã«æ›´æ–°ã•ã‚Œã¾ã—ãŸã€‚",
        languageNotFound: (LanguageId: string, fileExtension: string) =>
            `ã“ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã®ãƒ•ã‚¡ã‚¤ãƒ«è¨€èªžã‚’è­˜åˆ¥ã§ãã¾ã›ã‚“ã€‚languageID: ${LanguageId}, ãƒ•ã‚¡ã‚¤ãƒ«æ‹¡å¼µå­: ${fileExtension}`,
        jsonContent: (jsonContentString: String) => `ã‚³ãƒ¡ãƒ³ãƒˆ JSON ãƒ•ã‚¡ã‚¤ãƒ«ã®å†…å®¹: ${jsonContentString}`,
        messageNotFound: (key: string) => `ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ '${key}' ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚`
    },
    "ko": {
        inputboxError: (promptText: string, err: string) => `${promptText} ìž…ë ¥ ìƒìžì—ì„œ ì˜¤ë¥˜ ë°œìƒ: ${err}`,
        quickPickError: (err: string) => `QuickPickì—ì„œ ì˜¤ë¥˜ ë°œìƒ: ${err}`,
        quickPickYes: () => "ì˜ˆ",
        quickPickNo: () => "ì•„ë‹ˆì˜¤",
        watermarkView: () => "ì›Œí„°ë§ˆí¬ ë·°",
        watermarkJsonFileInvalid: () => "ì›Œí„°ë§ˆí¬ JSON íŒŒì¼ì´ ë¹„ì–´ ìžˆê±°ë‚˜ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤",
        watermarkName: () => "ì›Œí„°ë§ˆí¬ ì´ë¦„",
        watermarkCopyAscii: () => "ASCII ë³µì‚¬",
        watermarkZoomIn: () => "í™•ëŒ€",
        watermarkZoomOut: () => "ì¶•ì†Œ",
        watermarkPersonDisplayed: (name: string) => `ì›Œí„°ë§ˆí¬ '${name}' í‘œì‹œë¨.`,
        watermarkChosen: (watermark: string[]) => `í‘œì‹œí•  ì›Œí„°ë§ˆí¬: ${JSON.stringify(watermark)}`,
        watermarkNotFound: () => "ì›Œí„°ë§ˆí¬ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ",
        watermarkCopied: (name: string) => `${name}ì˜ ASCII ì•„íŠ¸ê°€ ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!`,
        watermarkAuthorName: () => "ìž‘ì„±ìž ì´ë¦„",
        darlingView: () => "ìºë¦­í„° ë·°",
        darlingJsonFileInvalid: () => "Darling JSON íŒŒì¼ì´ ë¹„ì–´ ìžˆê±°ë‚˜ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤",
        darlingPersonDisplayed: (name: string) => `ìºë¦­í„° '${name}' í‘œì‹œë¨.`,
        darlingCopyAscii: () => "ASCII ë³µì‚¬",
        darlingZoomIn: () => "í™•ëŒ€",
        darlingZoomOut: () => "ì¶•ì†Œ",
        darlingType: () => "ìœ í˜•",
        darlingAge: () => "ë‚˜ì´",
        darlingHeight: () => "í‚¤",
        darlingAlias: () => "ë³„ëª…",
        darlingDescription: () => "ì„¤ëª…",
        darlingQuote: () => "ì¸ìš©êµ¬",
        darlingMoreInfo: () => "ì¶”ê°€ ì •ë³´",
        darlingImage: () => "ì´ë¯¸ì§€",
        darlingCopied: (name: string) => `${name}ì˜ ASCII ì•„íŠ¸ê°€ ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!`,
        logoView: () => "ë¡œê³  ë·°",
        logoName: () => "ë¡œê³  ì´ë¦„",
        logoMessage: (logoPath: string) => `íŒŒì¼ (${logoPath})ì€(ëŠ”) ì›í•˜ëŠ” ìœ í˜•ì´ ì•„ë‹ˆë¯€ë¡œ ë¬´ì‹œë©ë‹ˆë‹¤.`,
        logoNoRootDir: () => "ë¡œê³ ë¥¼ ìˆ˜ì§‘í•  ë£¨íŠ¸ ë””ë ‰í„°ë¦¬ê°€ ì œê³µë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤",
        logoRootDirUpdateError: (error: string) => `ë¡œê³  íŒŒì¼ ì—…ë°ì´íŠ¸ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: ${error}`,
        logoDisplayed: (name: string) => `ë¡œê³  '${name}' í‘œì‹œë¨.`,
        logoCopied: (logoName: string) => `${logoName}ì˜ ASCII ì•„íŠ¸ê°€ ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!`,
        logoChosen: (logo: string[]) => `í‘œì‹œí•  ë¡œê³ : ${JSON.stringify(logo)}`,
        logoNotFound: () => "ë¡œê³ ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ",
        logoCopyAscii: () => "ASCII ë³µì‚¬",
        noCommentToShow: () => "í‘œì‹œí•  ì£¼ì„ì´ ì—†ìŠµë‹ˆë‹¤.",
        unknown: () => "ì•Œ ìˆ˜ ì—†ìŒ",
        headerOpenerFound: () => "í—¤ë” ì‹œìž‘ ë°œê²¬.",
        headerOpenerAndCloserFound: () => "í—¤ë” ì‹œìž‘ ë° ì¢…ë£Œ ë°œê²¬, ê²€ì‚¬ í›„ ë‚ ì§œë¥¼ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.",
        headerWriteFailed: () => "íŒŒì¼ì— í—¤ë”ë¥¼ ì“¸ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë¡œê·¸ë¥¼ í™•ì¸í•˜ì„¸ìš”.",
        headerWriteSuccess: () => "í—¤ë”ê°€ ì„±ê³µì ìœ¼ë¡œ ìž‘ì„±ë˜ì—ˆìŠµë‹ˆë‹¤.",
        headerNotFound: () => "ì´ ë¬¸ì„œì—ì„œ í—¤ë”ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
        headerInjectQuestion: () => "ì´ ë¬¸ì„œì—ì„œ í—¤ë”ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì¶”ê°€í•˜ì‹œê² ìŠµë‹ˆê¹Œ?",
        headerInjectQuestionRefused: () => "íŒŒì¼ì— í—¤ë”ë¥¼ ì¶”ê°€í•˜ì§€ ì•Šê¸°ë¡œ ê²°ì •í–ˆìŠµë‹ˆë‹¤.",
        morseConverted: (input: string, final: string) => `ë³€í™˜ë¨: ${input} â†’ ${final}`,
        morseDecoded: (input: string, final: string) => `ë³µí˜¸í™”ë¨: ${input} â†’ ${final}`,
        fileLoaded: (absolutePath: string) => `íŒŒì¼ ${absolutePath} ë¡œë“œ ì™„ë£Œ!`,
        fileParseError: (filePath: string, error: string) => `íŒŒì¼ ë‚´ìš© (${filePath})ì„(ë¥¼) ì •ìƒì ìœ¼ë¡œ ë¡œë“œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì˜¤ë¥˜: ${error}.`,
        fileRefreshed: () => "íŒŒì¼ ë‚´ìš©ì„ ìƒˆë¡œ ê³ ì¹˜ëŠ” ì¤‘ìž…ë‹ˆë‹¤.",
        filePathUpdated: (oldFilePath: string, newFilePath: string) => `ê²½ë¡œê°€ ${oldFilePath}ì—ì„œ ${newFilePath}ë¡œ ì—…ë°ì´íŠ¸ë˜ì—ˆìŠµë‹ˆë‹¤.`,
        fileUnloaded: (filePath: string) => `íŒŒì¼ ${filePath}ì´(ê°€) ë©”ëª¨ë¦¬ì—ì„œ ì–¸ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤.`,
        fileExcludedActivationDisabled: () => "í™œì„±í™” ë¹„í™œì„±í™”ë¨, íŒŒì¼ì´ ì œì™¸ ëª©ë¡ì— ìžˆìŠµë‹ˆë‹¤.",
        fileSaveFailed: () => "íŒŒì¼ ì €ìž¥ ì‹¤íŒ¨, ë‹¤ì‹œ ì‹œë„í•˜ì‹­ì‹œì˜¤.",
        cwdUpdated: (oldCwd: string, newCwd: string) => `í˜„ìž¬ ìž‘ì—… ë””ë ‰í„°ë¦¬ê°€ ${oldCwd}ì—ì„œ ${newCwd}ë¡œ ì—…ë°ì´íŠ¸ë˜ì—ˆìŠµë‹ˆë‹¤.`,
        cwdDoesNotExist: (cwd: string) => `ì œê³µëœ ìž‘ì—… ë””ë ‰í„°ë¦¬ ${cwd}ê°€ ì¡´ìž¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.`,
        updatingEditionDate: () => "ìˆ˜ì •ì¼ì„ ì—…ë°ì´íŠ¸ ì¤‘ìž…ë‹ˆë‹¤.",
        documentLineScanExceeded: (maxScanLength: number) => `íŒŒì¼ì˜ ì²˜ìŒ ${maxScanLength}ì¤„ì„ ìŠ¤ìº”í–ˆì§€ë§Œ í—¤ë”ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`,
        closedDocument: () => "ë¬¸ì„œê°€ ë‹«í˜€ ìžˆì–´ ìž‘ì—…ì„ ì¤‘ë‹¨í•©ë‹ˆë‹¤.",
        emptyDocument: () => "ìž‘ì—…í•  ë¬¸ì„œ ë‚´ìš©ì´ ì—†ìŠµë‹ˆë‹¤.",
        brokenHeader: () => "ì†ìƒëœ í—¤ë”ê°€ ê°ì§€ë˜ì—ˆìŠµë‹ˆë‹¤. ìƒˆ í—¤ë”ë¥¼ ì‚½ìž…í•©ë‹ˆë‹¤. ì´ì „ ê²ƒì„ ì‚­ì œí•˜ì„¸ìš”.",
        extensionActivated: (moduleName: string) => `ðŸš€ "${moduleName}" í™•ìž¥ì´ í™œì„±í™”ë˜ì—ˆìŠµë‹ˆë‹¤!`,
        helloWorldGreetingsCommand: (moduleName: string) => `Hello World from ${moduleName}!`,
        noActiveEditor: () => "í™œì„± íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤!",
        noFocusedEditors: () => "í¬ì»¤ìŠ¤ëœ íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤.",
        noLogoInstanceProvided: () => "ì œê³µëœ ë¡œê³  ëžœë¤ ì¸ìŠ¤í„´ìŠ¤ê°€ ì—†ìŠµë‹ˆë‹¤.",
        randomLogoGatheringFailed: (error: string) => `ëžœë¤ ë¡œê³  ìˆ˜ì§‘ ì‹¤íŒ¨, ê¸°ë³¸ ë¡œê³  ì‚¬ìš©, ì˜¤ë¥˜: "${error}"`,
        ramdomLogoGatheringLogoUndefined: () => "ë¡œê³  ë‚´ìš©ì´ ì •ì˜ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.",
        openFileToApplyHeader: () => "í—¤ë”ë¥¼ ì ìš©í•  íŒŒì¼ì„ ì—´ì–´ì£¼ì„¸ìš”.",
        corruptedFileMetaData: () => "í•„ìš”í•œ íŒŒì¼ ë©”íƒ€ë°ì´í„°ê°€ ì˜¬ë°”ë¥´ê²Œ ìˆ˜ì§‘ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ì¤‘ë‹¨í•©ë‹ˆë‹¤.",
        messageWritten: () => "ë©”ì‹œì§€ ìž‘ì„± ì™„ë£Œ",
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string) =>
            `Hello World! íŒŒì¼ í™•ìž¥ìž: ${fileExtension}, ì´ë¦„: ${fileName}, ê²½ë¡œ: ${filePath}, ì–¸ì–´: ${languageId}\n`,
        missingFileError: () => "ì–¸ì–´ ì‚¬ì „ì´ ì—†ìŠµë‹ˆë‹¤. ì£¼ì„ ì ì‘ ê¸°ëŠ¥ì´ ë¹„í™œì„±í™”ë©ë‹ˆë‹¤.",
        unknownFileStructure: () => "ì–¸ì–´ ì‚¬ì „ êµ¬ì¡°ë¥¼ ì•Œ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì£¼ì„ ì ì‘ ê¸°ëŠ¥ì´ ë¹„í™œì„±í™”ë©ë‹ˆë‹¤.",
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]) => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}.`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string) =>
            `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        identifiedLanguage: (langName: string) => `ì‹ë³„ëœ ì–¸ì–´: ${langName}.`,
        errorDuringFunctionCall: (functionName: string) => `í•¨ìˆ˜ (${functionName}) í˜¸ì¶œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ë¡œê·¸ë¥¼ í™•ì¸í•˜ì„¸ìš”.`,
        missingLanguageComment: () => "ì–¸ì–´ ì£¼ì„ì´ ì œê³µë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. í• ë‹¹ì„ ê±´ë„ˆëœë‹ˆë‹¤.",
        getHeaderDescription: () => "ì„¤ëª…ì„ ìž…ë ¥í•˜ì„¸ìš”: ",
        getHeaderTags: () => "ì´ íŒŒì¼ì˜ íƒœê·¸ë¥¼ ì‰¼í‘œë¡œ êµ¬ë¶„í•˜ì—¬ ìž…ë ¥í•˜ì„¸ìš”: ",
        getHeaderPurpose: () => "íŒŒì¼ì˜ ëª©ì ì„ ìž…ë ¥í•˜ì„¸ìš”: ",
        noProvidedCommentOptions: () => "ì œê³µëœ ì£¼ì„ ì˜µì…˜ì´ ì—†ìŠµë‹ˆë‹¤.",
        chooseSingleLineCommentOption: () => "ì•„ëž˜ ì˜µì…˜ì—ì„œ ì›í•˜ëŠ” ì£¼ì„ ì ‘ë‘ì‚¬ë¥¼ ì„ íƒí•˜ì„¸ìš”: ",
        updateAbortedBecauseFileClosedSyncCancelled: () => "íŒŒì¼ì´ ë‹«í˜€ ìžˆì–´ ì—…ë°ì´íŠ¸ê°€ ì¤‘ë‹¨ë˜ì—ˆìœ¼ë©° ë™ê¸°í™”ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.",
        updateEditDateMissingBounds: () => "í—¤ë”ë¥¼ ì—…ë°ì´íŠ¸í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤: ë‚´ë¶€ ë§ˆì»¤ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
        lastModifiedLineNotFound: () => "í—¤ë”ì— 'ë§ˆì§€ë§‰ ìˆ˜ì •ì¼' ë¼ì¸ì´ ì—†ìŠµë‹ˆë‹¤.",
        lastModifiedUpdated: () => "'ë§ˆì§€ë§‰ ìˆ˜ì •ì¼'ì´ ì„±ê³µì ìœ¼ë¡œ ì—…ë°ì´íŠ¸ë˜ì—ˆìŠµë‹ˆë‹¤.",
        languageNotFound: (LanguageId: string, fileExtension: string) => `ì´ ë¬¸ì„œì˜ íŒŒì¼ ì–¸ì–´ë¥¼ ì‹ë³„í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. languageID: ${LanguageId}, íŒŒì¼ í™•ìž¥ìž: ${fileExtension}`,
        jsonContent: (jsonContentString: String) => `ì£¼ì„ JSON íŒŒì¼ ë‚´ìš©: ${jsonContentString}`,
        messageNotFound: (key: string) => `ë©”ì‹œì§€ '${key}'ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`
    },
    "ru": {
        inputboxError: (promptText: string, err: string) => `ÐžÑˆÐ¸Ð±ÐºÐ° Ð² Ð¿Ð¾Ð»Ðµ Ð²Ð²Ð¾Ð´Ð° Ð´Ð»Ñ ${promptText}: ${err}`,
        quickPickError: (err: string) => `ÐžÑˆÐ¸Ð±ÐºÐ° Ð² quickPick: ${err}`,
        quickPickYes: () => "Ð”Ð°",
        quickPickNo: () => "ÐÐµÑ‚",
        watermarkView: () => "Ð¿Ñ€Ð¾ÑÐ¼Ð¾Ñ‚Ñ€ Ð²Ð¾Ð´ÑÐ½Ð¾Ð³Ð¾ Ð·Ð½Ð°ÐºÐ°",
        watermarkJsonFileInvalid: () => "Ð¤Ð°Ð¹Ð» JSON Ð²Ð¾Ð´ÑÐ½Ð¾Ð³Ð¾ Ð·Ð½Ð°ÐºÐ° Ð¿ÑƒÑÑ‚ Ð¸Ð»Ð¸ Ð½ÐµÐ´ÐµÐ¹ÑÑ‚Ð²Ð¸Ñ‚ÐµÐ»ÐµÐ½",
        watermarkName: () => "ÐÐ°Ð·Ð²Ð°Ð½Ð¸Ðµ Ð²Ð¾Ð´ÑÐ½Ð¾Ð³Ð¾ Ð·Ð½Ð°ÐºÐ°",
        watermarkCopyAscii: () => "Ð¡ÐºÐ¾Ð¿Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ ASCII",
        watermarkZoomIn: () => "Ð£Ð²ÐµÐ»Ð¸Ñ‡Ð¸Ñ‚ÑŒ",
        watermarkZoomOut: () => "Ð£Ð¼ÐµÐ½ÑŒÑˆÐ¸Ñ‚ÑŒ",
        watermarkPersonDisplayed: (name: string) => `Ð’Ð¾Ð´ÑÐ½Ð¾Ð¹ Ð·Ð½Ð°Ðº '${name}' Ð¾Ñ‚Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½.`,
        watermarkChosen: (watermark: string[]) => `Ð’Ñ‹Ð±Ñ€Ð°Ð½Ð½Ñ‹Ð¹ Ð²Ð¾Ð´ÑÐ½Ð¾Ð¹ Ð·Ð½Ð°Ðº: ${JSON.stringify(watermark)}`,
        watermarkNotFound: () => "Ð’Ð¾Ð´ÑÐ½Ð¾Ð¹ Ð·Ð½Ð°Ðº Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½",
        watermarkCopied: (name: string) => `ASCII-Ð°Ñ€Ñ‚ Ð´Ð»Ñ ${name} ÑÐºÐ¾Ð¿Ð¸Ñ€Ð¾Ð²Ð°Ð½!`,
        watermarkAuthorName: () => "Ð˜Ð¼Ñ Ð°Ð²Ñ‚Ð¾Ñ€Ð°",
        darlingView: () => "Ð¿Ñ€Ð¾ÑÐ¼Ð¾Ñ‚Ñ€ Ð¿ÐµÑ€ÑÐ¾Ð½Ð°Ð¶Ð°",
        darlingJsonFileInvalid: () => "Ð¤Ð°Ð¹Ð» JSON Ð¿ÐµÑ€ÑÐ¾Ð½Ð°Ð¶Ð° Ð¿ÑƒÑÑ‚ Ð¸Ð»Ð¸ Ð½ÐµÐ´ÐµÐ¹ÑÑ‚Ð²Ð¸Ñ‚ÐµÐ»ÐµÐ½",
        darlingPersonDisplayed: (name: string) => `ÐŸÐµÑ€ÑÐ¾Ð½Ð°Ð¶ '${name}' Ð¾Ñ‚Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½.`,
        darlingCopyAscii: () => "Ð¡ÐºÐ¾Ð¿Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ ASCII",
        darlingZoomIn: () => "Ð£Ð²ÐµÐ»Ð¸Ñ‡Ð¸Ñ‚ÑŒ",
        darlingZoomOut: () => "Ð£Ð¼ÐµÐ½ÑŒÑˆÐ¸Ñ‚ÑŒ",
        darlingType: () => "Ð¢Ð¸Ð¿",
        darlingAge: () => "Ð’Ð¾Ð·Ñ€Ð°ÑÑ‚",
        darlingHeight: () => "Ð Ð¾ÑÑ‚",
        darlingAlias: () => "ÐŸÑÐµÐ²Ð´Ð¾Ð½Ð¸Ð¼",
        darlingDescription: () => "ÐžÐ¿Ð¸ÑÐ°Ð½Ð¸Ðµ",
        darlingQuote: () => "Ð¦Ð¸Ñ‚Ð°Ñ‚Ð°",
        darlingMoreInfo: () => "Ð”Ð¾Ð¿. Ð¸Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ð¸Ñ",
        darlingImage: () => "Ð˜Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ðµ",
        darlingCopied: (name: string) => `ASCII-Ð°Ñ€Ñ‚ Ð´Ð»Ñ ${name} ÑÐºÐ¾Ð¿Ð¸Ñ€Ð¾Ð²Ð°Ð½!`,
        logoView: () => "Ð¿Ñ€Ð¾ÑÐ¼Ð¾Ñ‚Ñ€ Ð»Ð¾Ð³Ð¾Ñ‚Ð¸Ð¿Ð°",
        logoName: () => "ÐÐ°Ð·Ð²Ð°Ð½Ð¸Ðµ Ð»Ð¾Ð³Ð¾Ñ‚Ð¸Ð¿Ð°",
        logoMessage: (logoPath: string) => `Ð¤Ð°Ð¹Ð» (${logoPath}) Ð¿Ñ€Ð¾Ð¸Ð³Ð½Ð¾Ñ€Ð¸Ñ€Ð¾Ð²Ð°Ð½, Ñ‚Ð°Ðº ÐºÐ°Ðº ÑÑ‚Ð¾ Ð½Ðµ Ð½ÑƒÐ¶Ð½Ñ‹Ð¹ Ñ‚Ð¸Ð¿.`,
        logoNoRootDir: () => "ÐÐµ Ð¿Ñ€ÐµÐ´Ð¾ÑÑ‚Ð°Ð²Ð»ÐµÐ½ ÐºÐ¾Ñ€Ð½ÐµÐ²Ð¾Ð¹ ÐºÐ°Ñ‚Ð°Ð»Ð¾Ð³ Ð´Ð»Ñ ÑÐ±Ð¾Ñ€Ð° Ð»Ð¾Ð³Ð¾Ñ‚Ð¸Ð¿Ð¾Ð²",
        logoRootDirUpdateError: (error: string) => `ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ð¸ Ñ„Ð°Ð¹Ð»Ð¾Ð² Ð»Ð¾Ð³Ð¾Ñ‚Ð¸Ð¿Ð°: ${error}`,
        logoDisplayed: (name: string) => `Ð›Ð¾Ð³Ð¾Ñ‚Ð¸Ð¿ '${name}' Ð¾Ñ‚Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½.`,
        logoCopied: (logoName: string) => `ASCII-Ð°Ñ€Ñ‚ Ð´Ð»Ñ ${logoName} ÑÐºÐ¾Ð¿Ð¸Ñ€Ð¾Ð²Ð°Ð½!`,
        logoChosen: (logo: string[]) => `Ð’Ñ‹Ð±Ñ€Ð°Ð½Ð½Ñ‹Ð¹ Ð»Ð¾Ð³Ð¾Ñ‚Ð¸Ð¿: ${JSON.stringify(logo)}`,
        logoNotFound: () => "Ð›Ð¾Ð³Ð¾Ñ‚Ð¸Ð¿ Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½",
        logoCopyAscii: () => "Ð¡ÐºÐ¾Ð¿Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ ASCII",
        noCommentToShow: () => "ÐÐµÑ‚ ÐºÐ¾Ð¼Ð¼ÐµÐ½Ñ‚Ð°Ñ€Ð¸ÐµÐ² Ð´Ð»Ñ Ð¾Ñ‚Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ñ.",
        unknown: () => "ÐÐµÐ¸Ð·Ð²ÐµÑÑ‚Ð½Ð¾",
        headerOpenerFound: () => "ÐÐ°Ñ‡Ð°Ð»Ð¾ Ð·Ð°Ð³Ð¾Ð»Ð¾Ð²ÐºÐ° Ð½Ð°Ð¹Ð´ÐµÐ½Ð¾.",
        headerOpenerAndCloserFound: () => "ÐÐ°Ñ‡Ð°Ð»Ð¾ Ð¸ ÐºÐ¾Ð½ÐµÑ† Ð·Ð°Ð³Ð¾Ð»Ð¾Ð²ÐºÐ° Ð½Ð°Ð¹Ð´ÐµÐ½Ñ‹, Ð²Ñ‹Ð¿Ð¾Ð»Ð½ÑÐµÑ‚ÑÑ Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ðµ Ð´Ð°Ñ‚Ñ‹ Ð¿Ð¾ÑÐ»Ðµ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐ¸.",
        headerWriteFailed: () => "ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð·Ð°Ð¿Ð¸ÑÐ°Ñ‚ÑŒ Ð·Ð°Ð³Ð¾Ð»Ð¾Ð²Ð¾Ðº Ð² Ñ„Ð°Ð¹Ð», Ð¿Ñ€Ð¾Ð²ÐµÑ€ÑŒÑ‚Ðµ Ð»Ð¾Ð³Ð¸.",
        headerWriteSuccess: () => "Ð—Ð°Ð³Ð¾Ð»Ð¾Ð²Ð¾Ðº ÑƒÑÐ¿ÐµÑˆÐ½Ð¾ Ð·Ð°Ð¿Ð¸ÑÐ°Ð½.",
        headerNotFound: () => "Ð—Ð°Ð³Ð¾Ð»Ð¾Ð²Ð¾Ðº Ð² ÑÑ‚Ð¾Ð¼ Ð´Ð¾ÐºÑƒÐ¼ÐµÐ½Ñ‚Ðµ Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½.",
        headerInjectQuestion: () => "Ð—Ð°Ð³Ð¾Ð»Ð¾Ð²Ð¾Ðº Ð² ÑÑ‚Ð¾Ð¼ Ð´Ð¾ÐºÑƒÐ¼ÐµÐ½Ñ‚Ðµ Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½. Ð¥Ð¾Ñ‚Ð¸Ñ‚Ðµ Ð´Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ ÐµÐ³Ð¾?",
        headerInjectQuestionRefused: () => "Ð’Ñ‹ Ñ€ÐµÑˆÐ¸Ð»Ð¸ Ð½Ðµ Ð´Ð¾Ð±Ð°Ð²Ð»ÑÑ‚ÑŒ Ð·Ð°Ð³Ð¾Ð»Ð¾Ð²Ð¾Ðº Ð² Ñ„Ð°Ð¹Ð».",
        morseConverted: (input: string, final: string) => `ÐŸÑ€ÐµÐ¾Ð±Ñ€Ð°Ð·Ð¾Ð²Ð°Ð½Ð¾: ${input} â†’ ${final}`,
        morseDecoded: (input: string, final: string) => `Ð”ÐµÐºÐ¾Ð´Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¾: ${input} â†’ ${final}`,
        fileLoaded: (absolutePath: string) => `Ð¤Ð°Ð¹Ð» ${absolutePath} Ð·Ð°Ð³Ñ€ÑƒÐ¶ÐµÐ½!`,
        fileParseError: (filePath: string, error: string) => `Ð¡Ð¾Ð´ÐµÑ€Ð¶Ð¸Ð¼Ð¾Ðµ Ñ„Ð°Ð¹Ð»Ð° (${filePath}) Ð½Ðµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð·Ð°Ð³Ñ€ÑƒÐ·Ð¸Ñ‚ÑŒ. ÐžÑˆÐ¸Ð±ÐºÐ°: ${error}.`,
        fileRefreshed: () => "ÐžÐ±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ðµ ÑÐ¾Ð´ÐµÑ€Ð¶Ð¸Ð¼Ð¾Ð³Ð¾ Ñ„Ð°Ð¹Ð»Ð°.",
        filePathUpdated: (oldFilePath: string, newFilePath: string) => `ÐŸÑƒÑ‚ÑŒ Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½ Ñ ${oldFilePath} Ð½Ð° ${newFilePath}.`,
        fileUnloaded: (filePath: string) => `Ð¤Ð°Ð¹Ð» ${filePath} Ð²Ñ‹Ð³Ñ€ÑƒÐ¶ÐµÐ½ Ð¸Ð· Ð¿Ð°Ð¼ÑÑ‚Ð¸.`,
        fileExcludedActivationDisabled: () => "ÐÐºÑ‚Ð¸Ð²Ð°Ñ†Ð¸Ñ Ð¾Ñ‚ÐºÐ»ÑŽÑ‡ÐµÐ½Ð°, Ñ„Ð°Ð¹Ð» Ð½Ð°Ñ…Ð¾Ð´Ð¸Ñ‚ÑÑ Ð² ÑÐ¿Ð¸ÑÐºÐµ Ð¸ÑÐºÐ»ÑŽÑ‡ÐµÐ½Ð¸Ð¹.",
        fileSaveFailed: () => "ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ ÑÐ¾Ñ…Ñ€Ð°Ð½Ð¸Ñ‚ÑŒ Ñ„Ð°Ð¹Ð», Ð¿Ð¾Ð¿Ñ€Ð¾Ð±ÑƒÐ¹Ñ‚Ðµ ÑÐ½Ð¾Ð²Ð°.",
        cwdUpdated: (oldCwd: string, newCwd: string) => `Ð¢ÐµÐºÑƒÑ‰Ð¸Ð¹ Ñ€Ð°Ð±Ð¾Ñ‡Ð¸Ð¹ ÐºÐ°Ñ‚Ð°Ð»Ð¾Ð³ Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½ Ñ ${oldCwd} Ð½Ð° ${newCwd}.`,
        cwdDoesNotExist: (cwd: string) => `Ð£ÐºÐ°Ð·Ð°Ð½Ð½Ñ‹Ð¹ Ñ€Ð°Ð±Ð¾Ñ‡Ð¸Ð¹ ÐºÐ°Ñ‚Ð°Ð»Ð¾Ð³ ${cwd} Ð½Ðµ ÑÑƒÑ‰ÐµÑÑ‚Ð²ÑƒÐµÑ‚.`,
        updatingEditionDate: () => "ÐžÐ±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ðµ Ð´Ð°Ñ‚Ñ‹ Ñ€ÐµÐ´Ð°ÐºÑ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ.",
        documentLineScanExceeded: (maxScanLength: number) => `ÐŸÑ€Ð¾ÑÐºÐ°Ð½Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¾ Ð¿ÐµÑ€Ð²Ñ‹Ðµ ${maxScanLength} ÑÑ‚Ñ€Ð¾ÐºÐ¸ Ñ„Ð°Ð¹Ð»Ð°, Ð·Ð°Ð³Ð¾Ð»Ð¾Ð²Ð¾Ðº Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½.`,
        closedDocument: () => "Ð”Ð¾ÐºÑƒÐ¼ÐµÐ½Ñ‚ Ð·Ð°ÐºÑ€Ñ‹Ñ‚, Ð¾Ð¿ÐµÑ€Ð°Ñ†Ð¸Ñ Ð¾ÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½Ð°.",
        emptyDocument: () => "ÐÐµÑ‚ ÑÐ¾Ð´ÐµÑ€Ð¶Ð¸Ð¼Ð¾Ð³Ð¾ Ð´Ð¾ÐºÑƒÐ¼ÐµÐ½Ñ‚Ð° Ð´Ð»Ñ Ñ€Ð°Ð±Ð¾Ñ‚Ñ‹.",
        brokenHeader: () => "ÐžÐ±Ð½Ð°Ñ€ÑƒÐ¶ÐµÐ½ Ð¿Ð¾Ð²Ñ€ÐµÐ¶Ð´ÐµÐ½Ð½Ñ‹Ð¹ Ð·Ð°Ð³Ð¾Ð»Ð¾Ð²Ð¾Ðº, Ð²ÑÑ‚Ð°Ð²Ð»ÑÐµÑ‚ÑÑ Ð½Ð¾Ð²Ñ‹Ð¹, ÑƒÐ´Ð°Ð»Ð¸Ñ‚Ðµ Ð¿Ñ€ÐµÐ´Ñ‹Ð´ÑƒÑ‰Ð¸Ð¹.",
        extensionActivated: (moduleName: string) => `ðŸš€ Ð Ð°ÑÑˆÐ¸Ñ€ÐµÐ½Ð¸Ðµ "${moduleName}" Ñ‚ÐµÐ¿ÐµÑ€ÑŒ Ð°ÐºÑ‚Ð¸Ð²Ð½Ð¾!`,
        helloWorldGreetingsCommand: (moduleName: string) => `Hello World Ð¸Ð· ${moduleName}!`,
        noActiveEditor: () => "ÐÐµÑ‚ Ð°ÐºÑ‚Ð¸Ð²Ð½Ð¾Ð³Ð¾ Ñ„Ð°Ð¹Ð»Ð°!",
        noFocusedEditors: () => "ÐÐµÑ‚ Ñ„Ð°Ð¹Ð»Ð¾Ð² Ð² Ñ„Ð¾ÐºÑƒÑÐµ.",
        noLogoInstanceProvided: () => "ÐÐµ Ð¿Ñ€ÐµÐ´Ð¾ÑÑ‚Ð°Ð²Ð»ÐµÐ½ ÑÐºÐ·ÐµÐ¼Ð¿Ð»ÑÑ€ Ñ€Ð°Ð½Ð´Ð¾Ð¼Ð¸Ð·Ð°Ñ‚Ð¾Ñ€Ð° Ð»Ð¾Ð³Ð¾Ñ‚Ð¸Ð¿Ð°.",
        randomLogoGatheringFailed: (error: string) => `Ð¡Ð±Ð¾Ñ€ ÑÐ»ÑƒÑ‡Ð°Ð¹Ð½Ð¾Ð³Ð¾ Ð»Ð¾Ð³Ð¾Ñ‚Ð¸Ð¿Ð° Ð½Ðµ ÑƒÐ´Ð°Ð»ÑÑ, Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÑ‚ÑÑ Ð»Ð¾Ð³Ð¾Ñ‚Ð¸Ð¿ Ð¿Ð¾ ÑƒÐ¼Ð¾Ð»Ñ‡Ð°Ð½Ð¸ÑŽ, Ð¾ÑˆÐ¸Ð±ÐºÐ°: "${error}"`,
        ramdomLogoGatheringLogoUndefined: () => "Ð¡Ð¾Ð´ÐµÑ€Ð¶Ð¸Ð¼Ð¾Ðµ Ð»Ð¾Ð³Ð¾Ñ‚Ð¸Ð¿Ð° Ð½ÐµÐ¾Ð¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð¾.",
        openFileToApplyHeader: () => "ÐŸÐ¾Ð¶Ð°Ð»ÑƒÐ¹ÑÑ‚Ð°, Ð¾Ñ‚ÐºÑ€Ð¾Ð¹Ñ‚Ðµ Ñ„Ð°Ð¹Ð», Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ð¿Ñ€Ð¸Ð¼ÐµÐ½Ð¸Ñ‚ÑŒ Ð·Ð°Ð³Ð¾Ð»Ð¾Ð²Ð¾Ðº.",
        corruptedFileMetaData: () => "ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ ÐºÐ¾Ñ€Ñ€ÐµÐºÑ‚Ð½Ð¾ ÑÐ¾Ð±Ñ€Ð°Ñ‚ÑŒ Ð½ÐµÐ¾Ð±Ñ…Ð¾Ð´Ð¸Ð¼Ñ‹Ðµ Ð¼ÐµÑ‚Ð°Ð´Ð°Ð½Ð½Ñ‹Ðµ Ñ„Ð°Ð¹Ð»Ð°, Ð¿Ñ€ÐµÑ€Ñ‹Ð²Ð°Ð½Ð¸Ðµ.",
        messageWritten: () => "Ð¡Ð¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ Ð·Ð°Ð¿Ð¸ÑÐ°Ð½Ð¾",
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string) =>
            `Hello World! Ð Ð°ÑÑˆÐ¸Ñ€ÐµÐ½Ð¸Ðµ Ñ„Ð°Ð¹Ð»Ð°: ${fileExtension}, Ð¸Ð¼Ñ: ${fileName}, Ð¿ÑƒÑ‚ÑŒ: ${filePath}, ÑÐ·Ñ‹Ðº: ${languageId}\n`,
        missingFileError: () => "Ð¡Ð»Ð¾Ð²Ð°Ñ€ÑŒ ÑÐ·Ñ‹ÐºÐ° Ð¾Ñ‚ÑÑƒÑ‚ÑÑ‚Ð²ÑƒÐµÑ‚, Ð°Ð´Ð°Ð¿Ñ‚Ð°Ñ†Ð¸Ñ ÐºÐ¾Ð¼Ð¼ÐµÐ½Ñ‚Ð°Ñ€Ð¸ÐµÐ² Ð¾Ñ‚ÐºÐ»ÑŽÑ‡ÐµÐ½Ð°.",
        unknownFileStructure: () => "Ð¡Ñ‚Ñ€ÑƒÐºÑ‚ÑƒÑ€Ð° ÑÐ»Ð¾Ð²Ð°Ñ€Ñ ÑÐ·Ñ‹ÐºÐ° Ð½ÐµÐ¸Ð·Ð²ÐµÑÑ‚Ð½Ð°, Ð°Ð´Ð°Ð¿Ñ‚Ð°Ñ†Ð¸Ñ ÐºÐ¾Ð¼Ð¼ÐµÐ½Ñ‚Ð°Ñ€Ð¸ÐµÐ² Ð¾Ñ‚ÐºÐ»ÑŽÑ‡ÐµÐ½Ð°.",
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]) => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}.`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string) =>
            `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        identifiedLanguage: (langName: string) => `ÐžÐ¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð½Ñ‹Ð¹ ÑÐ·Ñ‹Ðº: ${langName}.`,
        errorDuringFunctionCall: (functionName: string) => `ÐŸÑ€Ð¾Ð¸Ð·Ð¾ÑˆÐ»Ð° Ð¾ÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ Ð²Ñ‹Ð·Ð¾Ð²Ðµ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸ (${functionName}), Ð¿Ñ€Ð¾Ð²ÐµÑ€ÑŒÑ‚Ðµ Ð»Ð¾Ð³Ð¸.`,
        missingLanguageComment: () => "ÐšÐ¾Ð¼Ð¼ÐµÐ½Ñ‚Ð°Ñ€Ð¸Ð¹ Ð´Ð»Ñ ÑÐ·Ñ‹ÐºÐ° Ð½Ðµ Ð¿Ñ€ÐµÐ´Ð¾ÑÑ‚Ð°Ð²Ð»ÐµÐ½, Ð¿Ñ€Ð¾Ð¿ÑƒÑÐº Ð¿Ñ€Ð¸ÑÐ²Ð¾ÐµÐ½Ð¸Ñ.",
        getHeaderDescription: () => "ÐŸÐ¾Ð¶Ð°Ð»ÑƒÐ¹ÑÑ‚Ð°, Ð¿Ñ€ÐµÐ´Ð¾ÑÑ‚Ð°Ð²ÑŒÑ‚Ðµ Ð¾Ð¿Ð¸ÑÐ°Ð½Ð¸Ðµ: ",
        getHeaderTags: () => "Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ñ‚ÐµÐ³Ð¸ Ð´Ð»Ñ ÑÑ‚Ð¾Ð³Ð¾ Ñ„Ð°Ð¹Ð»Ð° Ñ‡ÐµÑ€ÐµÐ· Ð·Ð°Ð¿ÑÑ‚ÑƒÑŽ: ",
        getHeaderPurpose: () => "ÐŸÐ¾Ð¶Ð°Ð»ÑƒÐ¹ÑÑ‚Ð°, ÑƒÐºÐ°Ð¶Ð¸Ñ‚Ðµ Ð½Ð°Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ Ñ„Ð°Ð¹Ð»Ð°: ",
        noProvidedCommentOptions: () => "ÐÐµÑ‚ Ð¿Ñ€ÐµÐ´Ð¾ÑÑ‚Ð°Ð²Ð»ÐµÐ½Ð½Ñ‹Ñ… Ð¾Ð¿Ñ†Ð¸Ð¹ ÐºÐ¾Ð¼Ð¼ÐµÐ½Ñ‚Ð°Ñ€Ð¸ÐµÐ².",
        chooseSingleLineCommentOption: () => "ÐŸÐ¾Ð¶Ð°Ð»ÑƒÐ¹ÑÑ‚Ð°, Ð²Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ Ð¿Ñ€ÐµÐ´Ð¿Ð¾Ñ‡Ð¸Ñ‚Ð°ÐµÐ¼Ñ‹Ð¹ Ð¿Ñ€ÐµÑ„Ð¸ÐºÑ ÐºÐ¾Ð¼Ð¼ÐµÐ½Ñ‚Ð°Ñ€Ð¸Ñ Ð¸Ð· Ð¿Ñ€ÐµÐ´Ð»Ð¾Ð¶ÐµÐ½Ð½Ñ‹Ñ… Ð²Ð°Ñ€Ð¸Ð°Ð½Ñ‚Ð¾Ð²: ",
        updateAbortedBecauseFileClosedSyncCancelled: () => "ÐžÐ±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ðµ Ð¿Ñ€ÐµÑ€Ð²Ð°Ð½Ð¾, Ñ‚Ð°Ðº ÐºÐ°Ðº Ñ„Ð°Ð¹Ð» Ð·Ð°ÐºÑ€Ñ‹Ñ‚ Ð¸ Ð½Ðµ Ð±ÑƒÐ´ÐµÑ‚ ÑÐ¸Ð½Ñ…Ñ€Ð¾Ð½Ð¸Ð·Ð¸Ñ€Ð¾Ð²Ð°Ð½.",
        updateEditDateMissingBounds: () => "ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð¾Ð±Ð½Ð¾Ð²Ð¸Ñ‚ÑŒ Ð·Ð°Ð³Ð¾Ð»Ð¾Ð²Ð¾Ðº: Ð²Ð½ÑƒÑ‚Ñ€ÐµÐ½Ð½Ð¸Ðµ Ð¼Ð°Ñ€ÐºÐµÑ€Ñ‹ Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½Ñ‹.",
        lastModifiedLineNotFound: () => "Ð’ Ð·Ð°Ð³Ð¾Ð»Ð¾Ð²ÐºÐµ Ð¾Ñ‚ÑÑƒÑ‚ÑÑ‚Ð²ÑƒÐµÑ‚ ÑÑ‚Ñ€Ð¾ÐºÐ° 'ÐŸÐ¾ÑÐ»ÐµÐ´Ð½ÐµÐµ Ð¸Ð·Ð¼ÐµÐ½ÐµÐ½Ð¸Ðµ' Ð´Ð»Ñ Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ñ.",
        lastModifiedUpdated: () => "Ð”Ð°Ñ‚Ð° 'ÐŸÐ¾ÑÐ»ÐµÐ´Ð½ÐµÐµ Ð¸Ð·Ð¼ÐµÐ½ÐµÐ½Ð¸Ðµ' ÑƒÑÐ¿ÐµÑˆÐ½Ð¾ Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½Ð°.",
        languageNotFound: (LanguageId: string, fileExtension: string) => `ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»Ð¸Ñ‚ÑŒ ÑÐ·Ñ‹Ðº Ñ„Ð°Ð¹Ð»Ð° ÑÑ‚Ð¾Ð³Ð¾ Ð´Ð¾ÐºÑƒÐ¼ÐµÐ½Ñ‚Ð°, languageID: ${LanguageId}, Ñ€Ð°ÑÑˆÐ¸Ñ€ÐµÐ½Ð¸Ðµ Ñ„Ð°Ð¹Ð»Ð°: ${fileExtension}`,
        jsonContent: (jsonContentString: String) => `Ð¡Ð¾Ð´ÐµÑ€Ð¶Ð¸Ð¼Ð¾Ðµ JSON-Ñ„Ð°Ð¹Ð»Ð° ÐºÐ¾Ð¼Ð¼ÐµÐ½Ñ‚Ð°Ñ€Ð¸ÐµÐ²: ${jsonContentString}`,
        messageNotFound: (key: string) => `Ð¡Ð¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ '${key}' Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½Ð¾.`
    },
    "pt-br": {
        inputboxError: (promptText: string, err: string) => `Erro na caixa de entrada para ${promptText}: ${err}`,
        quickPickError: (err: string) => `Erro no quickPick: ${err}`,
        quickPickYes: () => "Sim",
        quickPickNo: () => "NÃ£o",
        watermarkView: () => "visualizaÃ§Ã£o da marca d'Ã¡gua",
        watermarkJsonFileInvalid: () => "O arquivo JSON da marca d'Ã¡gua estÃ¡ vazio ou invÃ¡lido",
        watermarkName: () => "Nome da marca d'Ã¡gua",
        watermarkCopyAscii: () => "Copiar ASCII",
        watermarkZoomIn: () => "Aumentar zoom",
        watermarkZoomOut: () => "Diminuir zoom",
        watermarkPersonDisplayed: (name: string) => `Marca d'Ã¡gua '${name}' exibida.`,
        watermarkChosen: (watermark: string[]) => `Marca d'Ã¡gua a ser exibida: ${JSON.stringify(watermark)}`,
        watermarkNotFound: () => "Marca d'Ã¡gua nÃ£o encontrada",
        watermarkCopied: (name: string) => `ASCII art copiado para ${name}!`,
        watermarkAuthorName: () => "Nome do autor",
        darlingView: () => "visualizaÃ§Ã£o do personagem",
        darlingJsonFileInvalid: () => "O arquivo JSON do personagem estÃ¡ vazio ou invÃ¡lido",
        darlingPersonDisplayed: (name: string) => `Personagem '${name}' exibido.`,
        darlingCopyAscii: () => "Copiar ASCII",
        darlingZoomIn: () => "Aumentar zoom",
        darlingZoomOut: () => "Diminuir zoom",
        darlingType: () => "Tipo",
        darlingAge: () => "Idade",
        darlingHeight: () => "Altura",
        darlingAlias: () => "Apelido",
        darlingDescription: () => "DescriÃ§Ã£o",
        darlingQuote: () => "CitaÃ§Ã£o",
        darlingMoreInfo: () => "Mais informaÃ§Ãµes",
        darlingImage: () => "Imagem",
        darlingCopied: (name: string) => `ASCII art copiado para ${name}!`,
        logoView: () => "visualizaÃ§Ã£o do logotipo",
        logoName: () => "Nome do logotipo",
        logoMessage: (logoPath: string) => `Arquivo (${logoPath}) ignorado, pois nÃ£o Ã© do tipo esperado.`,
        logoNoRootDir: () => "Nenhum diretÃ³rio raiz fornecido para coleta de logotipos",
        logoRootDirUpdateError: (error: string) => `Erro ao atualizar arquivos de logotipo: ${error}`,
        logoDisplayed: (name: string) => `Logotipo '${name}' exibido.`,
        logoCopied: (logoName: string) => `ASCII art copiado para ${logoName}!`,
        logoChosen: (logo: string[]) => `Logotipo a ser exibido: ${JSON.stringify(logo)}`,
        logoNotFound: () => "Logotipo nÃ£o encontrado",
        logoCopyAscii: () => "Copiar ASCII",
        noCommentToShow: () => "NÃ£o hÃ¡ comentÃ¡rios para exibir.",
        unknown: () => "Desconhecido",
        headerOpenerFound: () => "InÃ­cio do cabeÃ§alho encontrado.",
        headerOpenerAndCloserFound: () => "InÃ­cio e fim do cabeÃ§alho encontrados, atualizando data apÃ³s verificaÃ§Ã£o.",
        headerWriteFailed: () => "Falha ao escrever o cabeÃ§alho no arquivo, verifique os logs.",
        headerWriteSuccess: () => "CabeÃ§alho escrito com sucesso.",
        headerNotFound: () => "Nenhum cabeÃ§alho encontrado neste documento.",
        headerInjectQuestion: () => "Nenhum cabeÃ§alho encontrado neste documento. Deseja adicionar um?",
        headerInjectQuestionRefused: () => "VocÃª optou por nÃ£o adicionar um cabeÃ§alho ao arquivo.",
        morseConverted: (input: string, final: string) => `Convertido: ${input} para ${final}`,
        morseDecoded: (input: string, final: string) => `Decodificado: ${input} para ${final}`,
        fileLoaded: (absolutePath: string) => `Arquivo ${absolutePath} carregado!`,
        fileParseError: (filePath: string, error: string) => `O conteÃºdo do arquivo (${filePath}) nÃ£o pÃ´de ser carregado com sucesso. Erro: ${error}.`,
        fileRefreshed: () => "Atualizando o conteÃºdo do arquivo.",
        filePathUpdated: (oldFilePath: string, newFilePath: string) => `O caminho foi atualizado de ${oldFilePath} para ${newFilePath}.`,
        fileUnloaded: (filePath: string) => `Arquivo ${filePath} descarregado da memÃ³ria.`,
        fileExcludedActivationDisabled: () => "AtivaÃ§Ã£o desativada, o arquivo estÃ¡ na lista de exclusÃ£o.",
        fileSaveFailed: () => "Falha ao salvar o arquivo, por favor tente novamente.",
        cwdUpdated: (oldCwd: string, newCwd: string) => `O diretÃ³rio de trabalho atual foi atualizado de ${oldCwd} para ${newCwd}.`,
        cwdDoesNotExist: (cwd: string) => `O diretÃ³rio de trabalho fornecido ${cwd} nÃ£o existe.`,
        updatingEditionDate: () => "Atualizando a data de ediÃ§Ã£o.",
        documentLineScanExceeded: (maxScanLength: number) => `Verificadas as primeiras ${maxScanLength} linhas do arquivo, mas nenhum cabeÃ§alho encontrado.`,
        closedDocument: () => "O documento estÃ¡ fechado, interrompendo operaÃ§Ãµes.",
        emptyDocument: () => "NÃ£o hÃ¡ corpo do documento para trabalhar.",
        brokenHeader: () => "CabeÃ§alho corrompido detectado, inserindo novo, por favor remova o anterior.",
        extensionActivated: (moduleName: string) => `ðŸš€ "${moduleName}" agora estÃ¡ ativo!`,
        helloWorldGreetingsCommand: (moduleName: string) => `OlÃ¡ Mundo do ${moduleName}!`,
        noActiveEditor: () => "Nenhum arquivo ativo!",
        noFocusedEditors: () => "NÃ£o hÃ¡ arquivos em foco.",
        noLogoInstanceProvided: () => "Nenhuma instÃ¢ncia de randomizador de logotipo fornecida.",
        randomLogoGatheringFailed: (error: string) => `Falha na coleta aleatÃ³ria de logotipos, usando logotipo padrÃ£o, erro: "${error}"`,
        ramdomLogoGatheringLogoUndefined: () => "O conteÃºdo do logotipo estÃ¡ indefinido.",
        openFileToApplyHeader: () => "Por favor, abra um arquivo para aplicar o cabeÃ§alho.",
        corruptedFileMetaData: () => "Os metadados do arquivo nÃ£o foram coletados corretamente, abortando.",
        messageWritten: () => "Mensagem escrita",
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string) =>
            `OlÃ¡ mundo! ExtensÃ£o do arquivo: ${fileExtension}, nome: ${fileName}, caminho: ${filePath}, idioma: ${languageId}\n`,
        missingFileError: () => "O dicionÃ¡rio de idioma estÃ¡ faltando, adaptabilidade de comentÃ¡rio desativada.",
        unknownFileStructure: () => "A estrutura do dicionÃ¡rio de idioma Ã© desconhecida, adaptabilidade de comentÃ¡rio desativada.",
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]) => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}.`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string) =>
            `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        identifiedLanguage: (langName: string) => `Idioma identificado: ${langName}.`,
        errorDuringFunctionCall: (functionName: string) => `Algo deu errado durante a chamada da funÃ§Ã£o (${functionName}), verifique os logs.`,
        missingLanguageComment: () => "ComentÃ¡rio de idioma nÃ£o fornecido, atribuiÃ§Ã£o ignorada.",
        getHeaderDescription: () => "Por favor, forneÃ§a uma descriÃ§Ã£o: ",
        getHeaderTags: () => "Digite as tags para este arquivo, separadas por vÃ­rgulas:",
        getHeaderPurpose: () => "Por favor, forneÃ§a o propÃ³sito do arquivo:",
        noProvidedCommentOptions: () => "Nenhuma opÃ§Ã£o de comentÃ¡rio fornecida.",
        chooseSingleLineCommentOption: () => "Por favor, selecione seu prefixo de comentÃ¡rio preferido entre as opÃ§Ãµes abaixo:",
        updateAbortedBecauseFileClosedSyncCancelled: () => "AtualizaÃ§Ã£o abortada porque o arquivo estÃ¡ fechado e nÃ£o serÃ¡ sincronizado.",
        updateEditDateMissingBounds: () => "NÃ£o foi possÃ­vel atualizar o cabeÃ§alho: marcadores internos nÃ£o encontrados.",
        lastModifiedLineNotFound: () => "O cabeÃ§alho nÃ£o contÃ©m uma linha 'Ãšltima ModificaÃ§Ã£o' para atualizar.",
        lastModifiedUpdated: () => "Data de 'Ãšltima ModificaÃ§Ã£o' atualizada com sucesso.",
        languageNotFound: (LanguageId: string, fileExtension: string) => `NÃ£o foi possÃ­vel identificar o idioma do arquivo deste documento, languageID: ${LanguageId}, extensÃ£o do arquivo: ${fileExtension}`,
        jsonContent: (jsonContentString: String) => `ConteÃºdo do arquivo JSON de comentÃ¡rios: ${jsonContentString}`,
        messageNotFound: (key: string) => `Mensagem '${key}' nÃ£o encontrada.`
    },
    "tr": {
        inputboxError: (promptText: string, err: string) => `${promptText} iÃ§in inputBox hatasÄ±: ${err}`,
        quickPickError: (err: string) => `quickPick hatasÄ±: ${err}`,
        quickPickYes: () => "Evet",
        quickPickNo: () => "HayÄ±r",
        watermarkView: () => "filigranGÃ¶rÃ¼nÃ¼mÃ¼",
        watermarkJsonFileInvalid: () => "Filigran JSON dosyasÄ± boÅŸ veya geÃ§ersiz",
        watermarkName: () => "Filigran adÄ±",
        watermarkCopyAscii: () => "ASCII'yi Kopyala",
        watermarkZoomIn: () => "YakÄ±nlaÅŸtÄ±r",
        watermarkZoomOut: () => "UzaklaÅŸtÄ±r",
        watermarkPersonDisplayed: (name: string) => `'${name}' filigranÄ± gÃ¶rÃ¼ntÃ¼lendi.`,
        watermarkChosen: (watermark: string[]) => `GÃ¶sterilecek filigran: ${JSON.stringify(watermark)}`,
        watermarkNotFound: () => "Filigran bulunamadÄ±",
        watermarkCopied: (name: string) => `${name} iÃ§in ASCII sanatÄ± kopyalandÄ±!`,
        watermarkAuthorName: () => "Yazar adÄ±",
        darlingView: () => "karakterGÃ¶rÃ¼nÃ¼mÃ¼",
        darlingJsonFileInvalid: () => "Karakter JSON dosyasÄ± boÅŸ veya geÃ§ersiz",
        darlingPersonDisplayed: (name: string) => `'${name}' karakteri gÃ¶rÃ¼ntÃ¼lendi.`,
        darlingCopyAscii: () => "ASCII'yi Kopyala",
        darlingZoomIn: () => "YakÄ±nlaÅŸtÄ±r",
        darlingZoomOut: () => "UzaklaÅŸtÄ±r",
        darlingType: () => "TÃ¼r",
        darlingAge: () => "YaÅŸ",
        darlingHeight: () => "Boy",
        darlingAlias: () => "Takma ad",
        darlingDescription: () => "AÃ§Ä±klama",
        darlingQuote: () => "AlÄ±ntÄ±",
        darlingMoreInfo: () => "Daha fazla bilgi",
        darlingImage: () => "Resim",
        darlingCopied: (name: string) => `${name} iÃ§in ASCII sanatÄ± kopyalandÄ±!`,
        logoView: () => "logoGÃ¶rÃ¼nÃ¼mÃ¼",
        logoName: () => "Logo adÄ±",
        logoMessage: (logoPath: string) => `Dosya (${logoPath}) gÃ¶z ardÄ± edildi, Ã§Ã¼nkÃ¼ aranan tÃ¼r deÄŸil.`,
        logoNoRootDir: () => "Logo toplamak iÃ§in kÃ¶k dizin saÄŸlanmadÄ±",
        logoRootDirUpdateError: (error: string) => `Logo dosyalarÄ± gÃ¼ncellenirken bir hata oluÅŸtu: ${error}`,
        logoDisplayed: (name: string) => `'${name}' logosu gÃ¶rÃ¼ntÃ¼lendi.`,
        logoCopied: (logoName: string) => `${logoName} iÃ§in ASCII sanatÄ± kopyalandÄ±!`,
        logoChosen: (logo: string[]) => `GÃ¶sterilecek logo: ${JSON.stringify(logo)}`,
        logoNotFound: () => "Logo bulunamadÄ±",
        logoCopyAscii: () => "ASCII'yi Kopyala",
        noCommentToShow: () => "GÃ¶sterilecek yorum yok.",
        unknown: () => "Bilinmeyen",
        headerOpenerFound: () => "BaÅŸlÄ±k aÃ§Ä±lÄ±ÅŸÄ± bulundu.",
        headerOpenerAndCloserFound: () => "BaÅŸlÄ±k aÃ§Ä±lÄ±ÅŸÄ± ve kapanÄ±ÅŸÄ± bulundu, denetim sonrasÄ± tarih gÃ¼ncellemesine geÃ§iliyor.",
        headerWriteFailed: () => "BaÅŸlÄ±k dosyaya yazÄ±lamadÄ±, gÃ¼nlÃ¼kleri kontrol edin.",
        headerWriteSuccess: () => "BaÅŸlÄ±k baÅŸarÄ±yla yazÄ±ldÄ±.",
        headerNotFound: () => "Bu belgede baÅŸlÄ±k bulunamadÄ±.",
        headerInjectQuestion: () => "Bu belgede baÅŸlÄ±k bulunamadÄ±. Eklemek ister misiniz?",
        headerInjectQuestionRefused: () => "Dosyaya baÅŸlÄ±k eklememeyi seÃ§tiniz.",
        morseConverted: (input: string, final: string) => `DÃ¶nÃ¼ÅŸtÃ¼rÃ¼ldÃ¼: ${input} -> ${final}`,
        morseDecoded: (input: string, final: string) => `Ã‡Ã¶zÃ¼ldÃ¼: ${input} -> ${final}`,
        fileLoaded: (absolutePath: string) => `Dosya ${absolutePath} yÃ¼klendi!`,
        fileParseError: (filePath: string, error: string) => `Dosya iÃ§eriÄŸi (${filePath}) baÅŸarÄ±yla yÃ¼klenemedi. Hata: ${error}.`,
        fileRefreshed: () => "Dosya iÃ§eriÄŸi yenileniyor.",
        filePathUpdated: (oldFilePath: string, newFilePath: string) => `Yol ${oldFilePath}â€™den ${newFilePath}â€™e gÃ¼ncellendi.`,
        fileUnloaded: (filePath: string) => `Dosya ${filePath} hafÄ±zadan boÅŸaltÄ±ldÄ±.`,
        fileExcludedActivationDisabled: () => "Aktivasyon devre dÄ±ÅŸÄ±, dosya hariÃ§ tutma listesinde.",
        fileSaveFailed: () => "Dosya kaydedilemedi, lÃ¼tfen tekrar deneyin.",
        cwdUpdated: (oldCwd: string, newCwd: string) => `Mevcut Ã§alÄ±ÅŸma dizini ${oldCwd}â€™den ${newCwd}â€™ye gÃ¼ncellendi.`,
        cwdDoesNotExist: (cwd: string) => `SaÄŸlanan Ã§alÄ±ÅŸma dizini ${cwd} mevcut deÄŸil.`,
        updatingEditionDate: () => "SÃ¼rÃ¼m tarihi gÃ¼ncelleniyor.",
        documentLineScanExceeded: (maxScanLength: number) => `DosyanÄ±n ilk ${maxScanLength} satÄ±rÄ± tarandÄ±, baÅŸlÄ±k bulunamadÄ±.`,
        closedDocument: () => "Belge kapalÄ±, iÅŸlemler durduruluyor.",
        emptyDocument: () => "Ãœzerinde Ã§alÄ±ÅŸÄ±lacak belge yok.",
        brokenHeader: () => "Bozuk baÅŸlÄ±k tespit edildi, yeni baÅŸlÄ±k ekleniyor, lÃ¼tfen Ã¶ncekini kaldÄ±rÄ±n.",
        extensionActivated: (moduleName: string) => `ðŸš€ "${moduleName}" artÄ±k aktif!`,
        helloWorldGreetingsCommand: (moduleName: string) => `${moduleName}â€™den Merhaba DÃ¼nya!`,
        noActiveEditor: () => "Aktif dosya yok!",
        noFocusedEditors: () => "OdaklanmÄ±ÅŸ dosya yok.",
        noLogoInstanceProvided: () => "HiÃ§bir logo rastgeleleÅŸtirici Ã¶rneÄŸi saÄŸlanmadÄ±.",
        randomLogoGatheringFailed: (error: string) => `Rastgele logo toplama baÅŸarÄ±sÄ±z, varsayÄ±lan logo kullanÄ±lÄ±yor, hata: "${error}"`,
        ramdomLogoGatheringLogoUndefined: () => "Logo iÃ§eriÄŸi tanÄ±msÄ±z.",
        openFileToApplyHeader: () => "BaÅŸlÄ±ÄŸÄ± uygulamak iÃ§in bir dosya aÃ§Ä±n.",
        corruptedFileMetaData: () => "Gerekli dosya meta verileri doÄŸru ÅŸekilde alÄ±namadÄ±, iÅŸlem durduruldu.",
        messageWritten: () => "Mesaj yazÄ±ldÄ±",
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string) =>
            `Merhaba dÃ¼nya! Bu dosyanÄ±n uzantÄ±sÄ±: ${fileExtension}, adÄ±: ${fileName}, yolu: ${filePath}, belirlenen dil: ${languageId}\n`,
        missingFileError: () => "Dil sÃ¶zlÃ¼ÄŸÃ¼ eksik, yorum uyumluluÄŸu devre dÄ±ÅŸÄ±.",
        unknownFileStructure: () => "Dil sÃ¶zlÃ¼ÄŸÃ¼ yapÄ±sÄ± bilinmiyor, yorum uyumluluÄŸu devre dÄ±ÅŸÄ±.",
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]) => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}.`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string) =>
            `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        identifiedLanguage: (langName: string) => `Belirlenen dil: ${langName}.`,
        errorDuringFunctionCall: (functionName: string) => `Fonksiyon (${functionName}) Ã§aÄŸrÄ±lÄ±rken bir hata oluÅŸtu, loglarÄ± kontrol edin.`,
        missingLanguageComment: () => "Dil yorumu saÄŸlanmadÄ±, atlama yapÄ±lÄ±yor.",
        getHeaderDescription: () => "LÃ¼tfen bir aÃ§Ä±klama saÄŸlayÄ±n: ",
        getHeaderTags: () => "Bu dosya iÃ§in etiketleri virgÃ¼lle ayÄ±rarak girin:",
        getHeaderPurpose: () => "LÃ¼tfen dosyanÄ±n amacÄ±nÄ± belirtin:",
        noProvidedCommentOptions: () => "SaÄŸlanmÄ±ÅŸ yorum seÃ§eneÄŸi yok.",
        chooseSingleLineCommentOption: () => "AÅŸaÄŸÄ±daki seÃ§eneklerden tercih ettiÄŸiniz yorum Ã¶n ekini seÃ§in:",
        updateAbortedBecauseFileClosedSyncCancelled: () => "Dosya kapalÄ± olduÄŸu iÃ§in gÃ¼ncelleme iptal edildi ve senkronize edilmeyecek.",
        updateEditDateMissingBounds: () => "BaÅŸlÄ±k gÃ¼ncellenemedi: iÃ§ baÅŸlÄ±k iÅŸaretÃ§ileri bulunamadÄ±.",
        lastModifiedLineNotFound: () => "BaÅŸlÄ±kta gÃ¼ncellenecek 'Son DeÄŸiÅŸiklik' satÄ±rÄ± yok.",
        lastModifiedUpdated: () => "'Son DeÄŸiÅŸiklik' tarihi baÅŸarÄ±yla gÃ¼ncellendi.",
        languageNotFound: (LanguageId: string, fileExtension: string) => `Bu belgenin dosya dili tanÄ±mlanamadÄ±, languageID: ${LanguageId}, dosya uzantÄ±sÄ±: ${fileExtension}`,
        jsonContent: (jsonContentString: String) => `Yorum JSON dosyasÄ±nÄ±n iÃ§eriÄŸi: ${jsonContentString}`,
        messageNotFound: (key: string) => `'${key}' mesajÄ± bulunamadÄ±.`
    },
    "pl": {
        inputboxError: (promptText: string, err: string) => `BÅ‚Ä…d w inputBox dla ${promptText}: ${err}`,
        quickPickError: (err: string) => `BÅ‚Ä…d w quickPick: ${err}`,
        quickPickYes: () => "Tak",
        quickPickNo: () => "Nie",
        watermarkView: () => "widokWatermark",
        watermarkJsonFileInvalid: () => "Plik JSON filigranu jest pusty lub nieprawidÅ‚owy",
        watermarkName: () => "Nazwa filigranu",
        watermarkCopyAscii: () => "Kopiuj ASCII",
        watermarkZoomIn: () => "PowiÄ™ksz",
        watermarkZoomOut: () => "Pomniejsz",
        watermarkPersonDisplayed: (name: string) => `Filigran '${name}' zostaÅ‚ wyÅ›wietlony.`,
        watermarkChosen: (watermark: string[]) => `Filigran do wyÅ›wietlenia: ${JSON.stringify(watermark)}`,
        watermarkNotFound: () => "Filigran nie zostaÅ‚ znaleziony",
        watermarkCopied: (name: string) => `Sztuka ASCII skopiowana dla ${name}!`,
        watermarkAuthorName: () => "Autor",
        darlingView: () => "widokPostaci",
        darlingJsonFileInvalid: () => "Plik JSON postaci jest pusty lub nieprawidÅ‚owy",
        darlingPersonDisplayed: (name: string) => `PostaÄ‡ '${name}' zostaÅ‚a wyÅ›wietlona.`,
        darlingCopyAscii: () => "Kopiuj ASCII",
        darlingZoomIn: () => "PowiÄ™ksz",
        darlingZoomOut: () => "Pomniejsz",
        darlingType: () => "Typ",
        darlingAge: () => "Wiek",
        darlingHeight: () => "Wzrost",
        darlingAlias: () => "Alias",
        darlingDescription: () => "Opis",
        darlingQuote: () => "Cytat",
        darlingMoreInfo: () => "WiÄ™cej informacji",
        darlingImage: () => "Obraz",
        darlingCopied: (name: string) => `Sztuka ASCII skopiowana dla ${name}!`,
        logoView: () => "widokLogo",
        logoName: () => "Nazwa logo",
        logoMessage: (logoPath: string) => `Plik (${logoPath}) pominiÄ™ty, poniewaÅ¼ nie jest szukanym typem.`,
        logoNoRootDir: () => "Nie podano katalogu gÅ‚Ã³wnego do zbierania logotypÃ³w",
        logoRootDirUpdateError: (error: string) => `WystÄ…piÅ‚ bÅ‚Ä…d podczas aktualizacji plikÃ³w logo: ${error}`,
        logoDisplayed: (name: string) => `Logo '${name}' zostaÅ‚o wyÅ›wietlone.`,
        logoCopied: (logoName: string) => `Sztuka ASCII skopiowana dla ${logoName}!`,
        logoChosen: (logo: string[]) => `Logo do wyÅ›wietlenia: ${JSON.stringify(logo)}`,
        logoNotFound: () => "Logo nie znaleziono",
        logoCopyAscii: () => "Kopiuj ASCII",
        noCommentToShow: () => "Brak komentarzy do wyÅ›wietlenia.",
        unknown: () => "Nieznany",
        headerOpenerFound: () => "Znaleziono otwieracz nagÅ‚Ã³wka.",
        headerOpenerAndCloserFound: () => "Znaleziono otwieracz i zamykacz nagÅ‚Ã³wka, kontynuowanie aktualizacji daty po kontroli poprawnoÅ›ci.",
        headerWriteFailed: () => "Nie udaÅ‚o siÄ™ zapisaÄ‡ nagÅ‚Ã³wka do pliku, sprawdÅº logi.",
        headerWriteSuccess: () => "NagÅ‚Ã³wek zapisany pomyÅ›lnie.",
        headerNotFound: () => "Nie znaleziono nagÅ‚Ã³wka w tym dokumencie.",
        headerInjectQuestion: () => "Nie znaleziono nagÅ‚Ã³wka w tym dokumencie. Czy chcesz dodaÄ‡ jeden?",
        headerInjectQuestionRefused: () => "Zdecydowano nie dodawaÄ‡ nagÅ‚Ã³wka do pliku.",
        morseConverted: (input: string, final: string) => `Przekonwertowano: ${input} na ${final}`,
        morseDecoded: (input: string, final: string) => `Rozkodowano: ${input} na ${final}`,
        fileLoaded: (absolutePath: string) => `Plik ${absolutePath} zostaÅ‚ zaÅ‚adowany!`,
        fileParseError: (filePath: string, error: string) => `ZawartoÅ›Ä‡ pliku (${filePath}) nie mogÅ‚a zostaÄ‡ zaÅ‚adowana poprawnie. BÅ‚Ä…d: ${error}.`,
        fileRefreshed: () => "OdÅ›wieÅ¼anie zawartoÅ›ci pliku.",
        filePathUpdated: (oldFilePath: string, newFilePath: string) => `ÅšcieÅ¼ka zostaÅ‚a zaktualizowana z ${oldFilePath} na ${newFilePath}.`,
        fileUnloaded: (filePath: string) => `Plik ${filePath} zostaÅ‚ usuniÄ™ty z pamiÄ™ci.`,
        fileExcludedActivationDisabled: () => "Aktywacja wyÅ‚Ä…czona, plik znajduje siÄ™ na liÅ›cie wykluczeÅ„.",
        fileSaveFailed: () => "Nie udaÅ‚o siÄ™ zapisaÄ‡ pliku, sprÃ³buj ponownie.",
        cwdUpdated: (oldCwd: string, newCwd: string) => `BieÅ¼Ä…cy katalog roboczy zaktualizowano z ${oldCwd} na ${newCwd}.`,
        cwdDoesNotExist: (cwd: string) => `Podany katalog roboczy ${cwd} nie istnieje.`,
        updatingEditionDate: () => "Aktualizacja daty edycji.",
        documentLineScanExceeded: (maxScanLength: number) => `Przeskanowano pierwsze ${maxScanLength} linie pliku, ale nie znaleziono nagÅ‚Ã³wka.`,
        closedDocument: () => "Dokument jest zamkniÄ™ty, zatrzymywanie operacji.",
        emptyDocument: () => "Brak zawartoÅ›ci dokumentu do pracy.",
        brokenHeader: () => "Wykryto uszkodzony nagÅ‚Ã³wek, wstrzykiwanie nowego, usuÅ„ poprzedni.",
        extensionActivated: (moduleName: string) => `ðŸš€ "${moduleName}" jest teraz aktywny!`,
        helloWorldGreetingsCommand: (moduleName: string) => `Witaj Åšwiecie z ${moduleName}!`,
        noActiveEditor: () => "Brak aktywnego pliku!",
        noFocusedEditors: () => "Brak plikÃ³w w fokusie.",
        noLogoInstanceProvided: () => "Nie podano instancji losowego loga.",
        randomLogoGatheringFailed: (error: string) => `Losowe zbieranie loga nie powiodÅ‚o siÄ™, uÅ¼ycie domyÅ›lnego loga, bÅ‚Ä…d: "${error}"`,
        ramdomLogoGatheringLogoUndefined: () => "ZawartoÅ›Ä‡ loga jest niezdefiniowana.",
        openFileToApplyHeader: () => "OtwÃ³rz plik, aby zastosowaÄ‡ nagÅ‚Ã³wek.",
        corruptedFileMetaData: () => "Wymagane metadane pliku nie zostaÅ‚y poprawnie zebrane, przerywanie.",
        messageWritten: () => "WiadomoÅ›Ä‡ zapisana",
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string) =>
            `Witaj Å›wiecie! Rozszerzenie tego pliku: ${fileExtension}, nazwa: ${fileName}, Å›cieÅ¼ka: ${filePath}, okreÅ›lony jÄ™zyk: ${languageId}\n`,
        missingFileError: () => "SÅ‚ownik jÄ™zykowy jest brakujÄ…cy, dostosowanie komentarzy jest wyÅ‚Ä…czone.",
        unknownFileStructure: () => "Struktura sÅ‚ownika jÄ™zykowego jest nieznana, dostosowanie komentarzy jest wyÅ‚Ä…czone.",
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]) => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}.`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string) =>
            `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        identifiedLanguage: (langName: string) => `Zidentyfikowany jÄ™zyk: ${langName}.`,
        errorDuringFunctionCall: (functionName: string) => `WystÄ…piÅ‚ bÅ‚Ä…d podczas wywoÅ‚ania funkcji (${functionName}), sprawdÅº logi.`,
        missingLanguageComment: () => "Komentarz jÄ™zyka nie zostaÅ‚ dostarczony, pomijanie przypisania.",
        getHeaderDescription: () => "Podaj opis: ",
        getHeaderTags: () => "WprowadÅº tagi dla tego pliku, oddzielone przecinkami:",
        getHeaderPurpose: () => "Podaj cel pliku:",
        noProvidedCommentOptions: () => "Nie dostarczono Å¼adnych opcji komentarza.",
        chooseSingleLineCommentOption: () => "Wybierz preferowany prefiks komentarza z poniÅ¼szych opcji:",
        updateAbortedBecauseFileClosedSyncCancelled: () => "Aktualizacja przerwana, poniewaÅ¼ plik jest zamkniÄ™ty i nie zostanie zsynchronizowany.",
        updateEditDateMissingBounds: () => "Nie moÅ¼na zaktualizowaÄ‡ nagÅ‚Ã³wka: nie znaleziono wewnÄ™trznych znacznikÃ³w nagÅ‚Ã³wka.",
        lastModifiedLineNotFound: () => "NagÅ‚Ã³wek nie zawiera wiersza 'Ostatnia modyfikacja' do aktualizacji.",
        lastModifiedUpdated: () => "Data 'Ostatnia modyfikacja' zostaÅ‚a pomyÅ›lnie zaktualizowana.",
        languageNotFound: (LanguageId: string, fileExtension: string) => `Nie udaÅ‚o siÄ™ zidentyfikowaÄ‡ jÄ™zyka pliku tego dokumentu, languageID: ${LanguageId}, rozszerzenie pliku: ${fileExtension}`,
        jsonContent: (jsonContentString: String) => `ZawartoÅ›Ä‡ pliku JSON komentarza: ${jsonContentString}`,
        messageNotFound: (key: string) => `Nie znaleziono komunikatu '${key}'.`
    },
    "cs": {
        inputboxError: (promptText: string, err: string) => `Chyba v inputBox pro ${promptText}: ${err}`,
        quickPickError: (err: string) => `Chyba v quickPick: ${err}`,
        quickPickYes: () => "Ano",
        quickPickNo: () => "Ne",
        watermarkView: () => "zobrazenÃ­Watermark",
        watermarkJsonFileInvalid: () => "Soubor JSON vodoznaku je prÃ¡zdnÃ½ nebo neplatnÃ½",
        watermarkName: () => "NÃ¡zev vodoznaku",
        watermarkCopyAscii: () => "KopÃ­rovat ASCII",
        watermarkZoomIn: () => "PÅ™iblÃ­Å¾it",
        watermarkZoomOut: () => "OddÃ¡lit",
        watermarkPersonDisplayed: (name: string) => `Vodoznak '${name}' zobrazen.`,
        watermarkChosen: (watermark: string[]) => `Vodoznak k zobrazenÃ­: ${JSON.stringify(watermark)}`,
        watermarkNotFound: () => "Vodoznak nenalezen",
        watermarkCopied: (name: string) => `ASCII umÄ›nÃ­ zkopÃ­rovÃ¡no pro ${name}!`,
        watermarkAuthorName: () => "JmÃ©no autora",
        darlingView: () => "zobrazenÃ­Postavy",
        darlingJsonFileInvalid: () => "Soubor JSON postavy je prÃ¡zdnÃ½ nebo neplatnÃ½",
        darlingPersonDisplayed: (name: string) => `Postava '${name}' zobrazena.`,
        darlingCopyAscii: () => "KopÃ­rovat ASCII",
        darlingZoomIn: () => "PÅ™iblÃ­Å¾it",
        darlingZoomOut: () => "OddÃ¡lit",
        darlingType: () => "Typ",
        darlingAge: () => "VÄ›k",
        darlingHeight: () => "VÃ½Å¡ka",
        darlingAlias: () => "PÅ™ezdÃ­vka",
        darlingDescription: () => "Popis",
        darlingQuote: () => "CitÃ¡t",
        darlingMoreInfo: () => "VÃ­ce informacÃ­",
        darlingImage: () => "ObrÃ¡zek",
        darlingCopied: (name: string) => `ASCII umÄ›nÃ­ zkopÃ­rovÃ¡no pro ${name}!`,
        logoView: () => "zobrazenÃ­Loga",
        logoName: () => "NÃ¡zev loga",
        logoMessage: (logoPath: string) => `Soubor (${logoPath}) byl ignorovÃ¡n, protoÅ¾e nenÃ­ poÅ¾adovanÃ©ho typu.`,
        logoNoRootDir: () => "Nebyl poskytnut Å¾Ã¡dnÃ½ koÅ™enovÃ½ adresÃ¡Å™ pro sbÄ›r log",
        logoRootDirUpdateError: (error: string) => `DoÅ¡lo k chybÄ› pÅ™i aktualizaci souborÅ¯ loga, chyba: ${error}`,
        logoDisplayed: (name: string) => `Logo '${name}' zobrazeno.`,
        logoCopied: (logoName: string) => `ASCII umÄ›nÃ­ zkopÃ­rovÃ¡no pro ${logoName}!`,
        logoChosen: (logo: string[]) => `Logo k zobrazenÃ­: ${JSON.stringify(logo)}`,
        logoNotFound: () => "Logo nenalezeno",
        logoCopyAscii: () => "KopÃ­rovat ASCII",
        noCommentToShow: () => "Å½Ã¡dnÃ½ komentÃ¡Å™ k zobrazenÃ­.",
        unknown: () => "NeznÃ¡mÃ½",
        headerOpenerFound: () => "OtevÃ­raÄ hlaviÄky nalezen.",
        headerOpenerAndCloserFound: () => "OtevÃ­raÄ a zavÃ­raÄ hlaviÄky nalezeny, pokraÄuje aktualizace data po kontrole sprÃ¡vnosti.",
        headerWriteFailed: () => "NepodaÅ™ilo se zapsat hlaviÄku do souboru, zkontrolujte protokoly.",
        headerWriteSuccess: () => "HlaviÄka ÃºspÄ›Å¡nÄ› zapsÃ¡na.",
        headerNotFound: () => "V tomto dokumentu nebyla nalezena Å¾Ã¡dnÃ¡ hlaviÄka.",
        headerInjectQuestion: () => "V tomto dokumentu nebyla nalezena Å¾Ã¡dnÃ¡ hlaviÄka. Chcete ji pÅ™idat?",
        headerInjectQuestionRefused: () => "Rozhodli jste se nepÅ™idÃ¡vat hlaviÄku do souboru.",
        morseConverted: (input: string, final: string) => `PÅ™evedeno: ${input} na ${final}`,
        morseDecoded: (input: string, final: string) => `DekÃ³dovÃ¡no: ${input} na ${final}`,
        fileLoaded: (absolutePath: string) => `Soubor ${absolutePath} byl naÄten!`,
        fileParseError: (filePath: string, error: string) => `Obsah souboru (${filePath}) nelze ÃºspÄ›Å¡nÄ› naÄÃ­st. Chyba: ${error}.`,
        fileRefreshed: () => "ObnovovÃ¡nÃ­ obsahu souboru.",
        filePathUpdated: (oldFilePath: string, newFilePath: string) => `Cesta byla aktualizovÃ¡na z ${oldFilePath} na ${newFilePath}.`,
        fileUnloaded: (filePath: string) => `Soubor ${filePath} byl odstranÄ›n z pamÄ›ti.`,
        fileExcludedActivationDisabled: () => "Aktivace zakÃ¡zÃ¡na, soubor je na seznamu vylouÄenÃ­.",
        fileSaveFailed: () => "NepodaÅ™ilo se uloÅ¾it soubor, zkuste to znovu.",
        cwdUpdated: (oldCwd: string, newCwd: string) => `AktuÃ¡lnÃ­ pracovnÃ­ adresÃ¡Å™ byl aktualizovÃ¡n z ${oldCwd} na ${newCwd}.`,
        cwdDoesNotExist: (cwd: string) => `ZadanÃ½ pracovnÃ­ adresÃ¡Å™ ${cwd} neexistuje.`,
        updatingEditionDate: () => "Aktualizace data edice.",
        documentLineScanExceeded: (maxScanLength: number) => `ProhledÃ¡no prvnÃ­ch ${maxScanLength} Å™Ã¡dkÅ¯ souboru, ale hlaviÄka nebyla nalezena.`,
        closedDocument: () => "Dokument je uzavÅ™en, operace zastaveny.",
        emptyDocument: () => "Neexistuje Å¾Ã¡dnÃ½ obsah dokumentu k prÃ¡ci.",
        brokenHeader: () => "Byla detekovÃ¡na poÅ¡kozenÃ¡ hlaviÄka, vklÃ¡dÃ¡ se novÃ¡, odstraÅˆte pÅ™edchozÃ­.",
        extensionActivated: (moduleName: string) => `ðŸš€ "${moduleName}" je nynÃ­ aktivnÃ­!`,
        helloWorldGreetingsCommand: (moduleName: string) => `Hello World z ${moduleName}!`,
        noActiveEditor: () => "Å½Ã¡dnÃ½ aktivnÃ­ soubor!",
        noFocusedEditors: () => "Å½Ã¡dnÃ© soubory nejsou ve fokus.",
        noLogoInstanceProvided: () => "Nebyla poskytnuta instance nÃ¡hodnÃ©ho loga.",
        randomLogoGatheringFailed: (error: string) => `ShromaÅ¾ÄovÃ¡nÃ­ nÃ¡hodnÃ©ho loga selhalo, pouÅ¾itÃ­ vÃ½chozÃ­ho loga, chyba: "${error}"`,
        ramdomLogoGatheringLogoUndefined: () => "Obsah loga nenÃ­ definovÃ¡n.",
        openFileToApplyHeader: () => "OtevÅ™ete soubor, na kterÃ½ chcete aplikovat hlaviÄku.",
        corruptedFileMetaData: () => "PoÅ¾adovanÃ¡ metadata souboru nebyla sprÃ¡vnÄ› shromÃ¡Å¾dÄ›na, pÅ™eruÅ¡enÃ­.",
        messageWritten: () => "ZprÃ¡va zapsÃ¡na",
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string) =>
            `Hello world! PÅ™Ã­pona tohoto souboru: ${fileExtension}, nÃ¡zev: ${fileName}, cesta: ${filePath}, urÄenÃ½ jazyk: ${languageId}\n`,
        missingFileError: () => "SlovnÃ­k jazykÅ¯ chybÃ­, pÅ™izpÅ¯sobenÃ­ komentÃ¡Å™Å¯ je deaktivovÃ¡no.",
        unknownFileStructure: () => "Struktura slovnÃ­ku jazykÅ¯ je neznÃ¡mÃ¡, pÅ™izpÅ¯sobenÃ­ komentÃ¡Å™Å¯ je deaktivovÃ¡no.",
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]) => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}.`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string) =>
            `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        identifiedLanguage: (langName: string) => `IdentifikovanÃ½ jazyk: ${langName}.`,
        errorDuringFunctionCall: (functionName: string) => `NÄ›co se pokazilo bÄ›hem volÃ¡nÃ­ funkce (${functionName}), zkontrolujte logy.`,
        missingLanguageComment: () => "KomentÃ¡Å™ jazyka nebyl poskytnut, pÅ™iÅ™azenÃ­ pÅ™eskoÄeno.",
        getHeaderDescription: () => "Zadejte popis: ",
        getHeaderTags: () => "Zadejte tagy pro tento soubor, oddÄ›lenÃ© ÄÃ¡rkou:",
        getHeaderPurpose: () => "Zadejte ÃºÄel souboru:",
        noProvidedCommentOptions: () => "Nebyly poskytnuty Å¾Ã¡dnÃ© moÅ¾nosti komentÃ¡Å™e.",
        chooseSingleLineCommentOption: () => "Vyberte preferovanÃ½ prefix komentÃ¡Å™e z nÃ­Å¾e uvedenÃ½ch moÅ¾nostÃ­:",
        updateAbortedBecauseFileClosedSyncCancelled: () => "Aktualizace pÅ™eruÅ¡ena, protoÅ¾e soubor je uzavÅ™en a nebude synchronizovÃ¡n.",
        updateEditDateMissingBounds: () => "Nelze aktualizovat hlaviÄku: internÃ­ markery hlaviÄky nebyly nalezeny.",
        lastModifiedLineNotFound: () => "HlaviÄka neobsahuje Å™Ã¡dek 'PoslednÃ­ Ãºprava' k aktualizaci.",
        lastModifiedUpdated: () => "Datum 'PoslednÃ­ Ãºprava' bylo ÃºspÄ›Å¡nÄ› aktualizovÃ¡no.",
        languageNotFound: (LanguageId: string, fileExtension: string) => `Jazyk souboru tohoto dokumentu nelze identifikovat, languageID: ${LanguageId}, pÅ™Ã­pona souboru: ${fileExtension}`,
        jsonContent: (jsonContentString: String) => `Obsah JSON souboru komentÃ¡Å™Å¯: ${jsonContentString}`,
        messageNotFound: (key: string) => `ZprÃ¡va '${key}' nenalezena.`
    },
    "hu": {
        inputboxError: (promptText: string, err: string) => `Hiba az inputBox-nÃ¡l a(z) ${promptText} esetÃ©n: ${err}`,
        quickPickError: (err: string) => `Hiba a quickPick-nÃ¡l: ${err}`,
        quickPickYes: () => "Igen",
        quickPickNo: () => "Nem",
        watermarkView: () => "vÃ­zjelNÃ©zet",
        watermarkJsonFileInvalid: () => "A vÃ­zjel JSON fÃ¡jl Ã¼res vagy Ã©rvÃ©nytelen",
        watermarkName: () => "VÃ­zjel neve",
        watermarkCopyAscii: () => "MÃ¡solÃ¡s ASCII",
        watermarkZoomIn: () => "NagyÃ­tÃ¡s",
        watermarkZoomOut: () => "KicsinyÃ­tÃ©s",
        watermarkPersonDisplayed: (name: string) => `VÃ­zjel '${name}' megjelenÃ­tve.`,
        watermarkChosen: (watermark: string[]) => `MegjelenÃ­tendÅ‘ vÃ­zjel: ${JSON.stringify(watermark)}`,
        watermarkNotFound: () => "VÃ­zjel nem talÃ¡lhatÃ³",
        watermarkCopied: (name: string) => `ASCII mÅ±vÃ©szet mÃ¡solva ${name} szÃ¡mÃ¡ra!`,
        watermarkAuthorName: () => "SzerzÅ‘ neve",
        darlingView: () => "karakterNÃ©zet",
        darlingJsonFileInvalid: () => "A karakter JSON fÃ¡jl Ã¼res vagy Ã©rvÃ©nytelen",
        darlingPersonDisplayed: (name: string) => `Karakter '${name}' megjelenÃ­tve.`,
        darlingCopyAscii: () => "MÃ¡solÃ¡s ASCII",
        darlingZoomIn: () => "NagyÃ­tÃ¡s",
        darlingZoomOut: () => "KicsinyÃ­tÃ©s",
        darlingType: () => "TÃ­pus",
        darlingAge: () => "Kor",
        darlingHeight: () => "MagassÃ¡g",
        darlingAlias: () => "BecenÃ©v",
        darlingDescription: () => "LeÃ­rÃ¡s",
        darlingQuote: () => "IdÃ©zet",
        darlingMoreInfo: () => "TovÃ¡bbi info",
        darlingImage: () => "KÃ©p",
        darlingCopied: (name: string) => `ASCII mÅ±vÃ©szet mÃ¡solva ${name} szÃ¡mÃ¡ra!`,
        logoView: () => "logoNÃ©zet",
        logoName: () => "LogÃ³ neve",
        logoMessage: (logoPath: string) => `FÃ¡jl (${logoPath}) figyelmen kÃ­vÃ¼l hagyva, mert nem a keresett tÃ­pus.`,
        logoNoRootDir: () => "Nincs megadva gyÃ¶kÃ©rkÃ¶nyvtÃ¡r a logÃ³k gyÅ±jtÃ©sÃ©hez",
        logoRootDirUpdateError: (error: string) => `Hiba tÃ¶rtÃ©nt a logÃ³fÃ¡jlok frissÃ­tÃ©se kÃ¶zben, hiba: ${error}`,
        logoDisplayed: (name: string) => `LogÃ³ '${name}' megjelenÃ­tve.`,
        logoCopied: (logoName: string) => `ASCII mÅ±vÃ©szet mÃ¡solva ${logoName} szÃ¡mÃ¡ra!`,
        logoChosen: (logo: string[]) => `MegjelenÃ­tendÅ‘ logÃ³: ${JSON.stringify(logo)}`,
        logoNotFound: () => "LogÃ³ nem talÃ¡lhatÃ³",
        logoCopyAscii: () => "MÃ¡solÃ¡s ASCII",
        noCommentToShow: () => "Nincs megjelenÃ­thetÅ‘ komment.",
        unknown: () => "Ismeretlen",
        headerOpenerFound: () => "FejlÃ©c nyitÃ³ megtalÃ¡lva.",
        headerOpenerAndCloserFound: () => "FejlÃ©c nyitÃ³ Ã©s zÃ¡rÃ³ megtalÃ¡lva, a dÃ¡tum frissÃ­tÃ©se kÃ¶vetkezik ellenÅ‘rzÃ©s utÃ¡n.",
        headerWriteFailed: () => "Nem sikerÃ¼lt Ã­rni a fejlÃ©cet a fÃ¡jlba, ellenÅ‘rizze a naplÃ³kat.",
        headerWriteSuccess: () => "FejlÃ©c sikeresen Ã­rva.",
        headerNotFound: () => "Nem talÃ¡lhatÃ³ fejlÃ©c ebben a dokumentumban.",
        headerInjectQuestion: () => "Nem talÃ¡lhatÃ³ fejlÃ©c ebben a dokumentumban. Szeretne hozzÃ¡adni egyet?",
        headerInjectQuestionRefused: () => "Ãšgy dÃ¶ntÃ¶tt, hogy nem ad hozzÃ¡ fejlÃ©cet a fÃ¡jlhoz.",
        morseConverted: (input: string, final: string) => `ÃtalakÃ­tva: ${input} -> ${final}`,
        morseDecoded: (input: string, final: string) => `DekÃ³dolva: ${input} -> ${final}`,
        fileLoaded: (absolutePath: string) => `A fÃ¡jl ${absolutePath} betÃ¶ltve!`,
        fileParseError: (filePath: string, error: string) => `A fÃ¡jl tartalma (${filePath}) nem tÃ¶lthetÅ‘ be sikeresen. Hiba: ${error}.`,
        fileRefreshed: () => "FÃ¡jl tartalmÃ¡nak frissÃ­tÃ©se.",
        filePathUpdated: (oldFilePath: string, newFilePath: string) => `Az Ãºtvonal frissÃ­tve lett: ${oldFilePath} -> ${newFilePath}.`,
        fileUnloaded: (filePath: string) => `A fÃ¡jl ${filePath} eltÃ¡volÃ­tva a memÃ³riÃ¡bÃ³l.`,
        fileExcludedActivationDisabled: () => "Az aktivÃ¡lÃ¡s letiltva, a fÃ¡jl a kizÃ¡rÃ¡si listÃ¡n van.",
        fileSaveFailed: () => "A fÃ¡jl mentÃ©se sikertelen, prÃ³bÃ¡lja Ãºjra.",
        cwdUpdated: (oldCwd: string, newCwd: string) => `A munkakÃ¶nyvtÃ¡r frissÃ­tve lett: ${oldCwd} -> ${newCwd}.`,
        cwdDoesNotExist: (cwd: string) => `A megadott munkakÃ¶nyvtÃ¡r ${cwd} nem lÃ©tezik.`,
        updatingEditionDate: () => "KiadÃ¡s dÃ¡tumÃ¡nak frissÃ­tÃ©se.",
        documentLineScanExceeded: (maxScanLength: number) => `Az elsÅ‘ ${maxScanLength} sor beolvasva, de nem talÃ¡lhatÃ³ fejlÃ©c.`,
        closedDocument: () => "A dokumentum zÃ¡rva, a mÅ±veletek leÃ¡llÃ­tva.",
        emptyDocument: () => "Nincs dokumentumtartalom, amin dolgozni lehetne.",
        brokenHeader: () => "SÃ©rÃ¼lt fejlÃ©c Ã©szlelve, Ãºj beszÃºrÃ¡sa folyamatban, kÃ©rjÃ¼k tÃ¡volÃ­tsa el az elÅ‘zÅ‘t.",
        extensionActivated: (moduleName: string) => `ðŸš€ A(z) "${moduleName}" modul most aktÃ­v!`,
        helloWorldGreetingsCommand: (moduleName: string) => `Hello World a ${moduleName}-bÃ³l!`,
        noActiveEditor: () => "Nincs aktÃ­v fÃ¡jl!",
        noFocusedEditors: () => "Nincsenek fÃ³kuszban lÃ©vÅ‘ fÃ¡jlok.",
        noLogoInstanceProvided: () => "Nem lett logÃ³ randomizÃ¡lÃ³ pÃ©ldÃ¡ny megadva.",
        randomLogoGatheringFailed: (error: string) => `A vÃ©letlenszerÅ± logÃ³gyÅ±jtÃ©s sikertelen, alapÃ©rtelmezett logÃ³ hasznÃ¡lata, hiba: "${error}"`,
        ramdomLogoGatheringLogoUndefined: () => "A logÃ³ tartalma nem definiÃ¡lt.",
        openFileToApplyHeader: () => "Nyisson meg egy fÃ¡jlt a fejlÃ©c alkalmazÃ¡sÃ¡hoz.",
        corruptedFileMetaData: () => "A szÃ¼ksÃ©ges fÃ¡jl metaadatok nem lettek megfelelÅ‘en Ã¶sszegyÅ±jtve, megszakÃ­tÃ¡s.",
        messageWritten: () => "Ãœzenet Ã­rva",
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string) =>
            `Hello world! A fÃ¡jl kiterjesztÃ©se: ${fileExtension}, neve: ${fileName}, Ãºtvonala: ${filePath}, nyelv: ${languageId}\n`,
        missingFileError: () => "A nyelvi szÃ³tÃ¡r hiÃ¡nyzik, a komment alkalmazkodÃ¡s le van tiltva.",
        unknownFileStructure: () => "A nyelvi szÃ³tÃ¡r szerkezete ismeretlen, a komment alkalmazkodÃ¡s le van tiltva.",
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]) => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}.`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string) =>
            `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        identifiedLanguage: (langName: string) => `AzonosÃ­tott nyelv: ${langName}.`,
        errorDuringFunctionCall: (functionName: string) => `Hiba tÃ¶rtÃ©nt a ${functionName} fÃ¼ggvÃ©ny hÃ­vÃ¡sakor, ellenÅ‘rizze a naplÃ³kat.`,
        missingLanguageComment: () => "A nyelvi komment nem lett megadva, a hozzÃ¡rendelÃ©s kihagyva.",
        getHeaderDescription: () => "Adjon meg egy leÃ­rÃ¡st: ",
        getHeaderTags: () => "Adja meg a fÃ¡jl cÃ­mkÃ©it, vesszÅ‘vel elvÃ¡lasztva:",
        getHeaderPurpose: () => "Adja meg a fÃ¡jl cÃ©ljÃ¡t:",
        noProvidedCommentOptions: () => "Nincsenek megadott komment opciÃ³k.",
        chooseSingleLineCommentOption: () => "KÃ©rjÃ¼k, vÃ¡lassza ki a kÃ­vÃ¡nt komment prefixet az alÃ¡bbi lehetÅ‘sÃ©gek kÃ¶zÃ¼l:",
        updateAbortedBecauseFileClosedSyncCancelled: () => "A frissÃ­tÃ©s megszakÃ­tva, mert a fÃ¡jl zÃ¡rva van Ã©s nem lesz szinkronizÃ¡lva.",
        updateEditDateMissingBounds: () => "Nem sikerÃ¼lt frissÃ­teni a fejlÃ©cet: a belsÅ‘ jelÃ¶lÅ‘k nem talÃ¡lhatÃ³k.",
        lastModifiedLineNotFound: () => "A fejlÃ©c nem tartalmaz 'UtolsÃ³ mÃ³dosÃ­tÃ¡s' sort a frissÃ­tÃ©shez.",
        lastModifiedUpdated: () => "Az 'UtolsÃ³ mÃ³dosÃ­tÃ¡s' dÃ¡tum sikeresen frissÃ­tve.",
        languageNotFound: (LanguageId: string, fileExtension: string) => `A dokumentum nyelve nem azonosÃ­thatÃ³, languageID: ${LanguageId}, fÃ¡jlkiterjesztÃ©s: ${fileExtension}`,
        jsonContent: (jsonContentString: String) => `A komment JSON fÃ¡jl tartalma: ${jsonContentString}`,
        messageNotFound: (key: string) => `'${key}' Ã¼zenet nem talÃ¡lhatÃ³.`
    }
};
