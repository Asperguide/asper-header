/**
 * @file messageReference.ts
 * @brief Comprehensive multilingual message repository with advanced localization support
 * @author Henry Letellier
 * @version 1.0.8
 * @date 2025-10-03
 * @copyright (c) 2025 Asperguide - All rights reserved
 * 
 * @details This module serves as the authoritative multilingual message repository for the entire
 * AsperHeader extension ecosystem. It implements a sophisticated internationalization
 * framework that provides consistent, culturally-appropriate messaging across all user
 * interfaces, error conditions, and interactive elements while supporting dynamic
 * parameter interpolation and context-aware message generation.
 * 
 * @section Architecture Localization Architecture
 * The module implements a multi-layered localization system with the following components:
 * 
 * @subsection MultiLanguageSupport Multi-Language Support
 * - Complete translations for 15+ languages including English, French, Italian, Spanish, German, Japanese, Korean, Chinese (Simplified & Traditional), Russian, Portuguese, Turkish, Polish, Czech, and Hungarian
 * - Standardized message key consistency across all language variants
 * - Professional native speaker translations with technical domain expertise
 * 
 * @subsection FunctionBasedMessages Function-Based Message System  
 * - Dynamic parameter interpolation with full TypeScript type safety
 * - Named parameter substitution with `{paramName}` syntax support
 * - Automatic type conversion and locale-aware formatting
 * - Security-conscious parameter escaping for HTML contexts
 * 
 * @subsection CulturalAdaptation Cultural Adaptation Framework
 * - Language-specific formatting rules and cultural considerations
 * - Context-sensitive plural forms for different linguistic structures
 * - Locale-appropriate number, currency, and date formatting
 * - Right-to-left (RTL) language preparation for future expansion
 * 
 * @subsection ExtensibilityFramework Extensible Plugin Architecture
 * - Modular design enabling seamless addition of new languages
 * - Standardized message key interface for consistent expansion
 * - Automated validation tools for translation completeness
 * - Hot-reload capability for development and testing scenarios
 * 
 * @section LanguageMatrix Supported Language Matrix
 * @subsection PrimaryLanguages Primary Languages (100% Coverage)
 * - **English (en)**: Primary reference language - complete message coverage with American English conventions
 * - **French (fr)**: Professional translation with French cultural adaptations and technical terminology
 * - **Italian (it)**: Complete localization with Italian conventions and technical domain expertise
 * - **Spanish (es)**: Full Spanish translation with Latin American and European Spanish considerations
 * - **German (de)**: Comprehensive German localization with technical precision and formal register
 * 
 * @subsection AsianLanguages Asian Languages (Full Support)
 * - **Japanese (ja)**: Native Japanese translation with proper honorific usage and technical terminology
 * - **Korean (ko)**: Complete Korean localization with appropriate formality levels
 * - **Chinese Simplified (zh-cn)**: Mainland Chinese translation with simplified characters
 * - **Chinese Traditional (zh-tw)**: Traditional Chinese for Taiwan and Hong Kong regions
 * 
 * @subsection EuropeanLanguages Additional European Languages
 * - **Russian (ru)**: Full Cyrillic script support with Russian technical conventions
 * - **Portuguese (pt-br)**: Brazilian Portuguese with regional adaptations
 * - **Turkish (tr)**: Complete Turkish localization with agglutinative language considerations
 * - **Polish (pl)**: Polish translation with complex grammar and case system support
 * - **Czech (cs)**: Czech localization with Slavic language characteristics
 * - **Hungarian (hu)**: Hungarian translation with unique Finno-Ugric linguistic features
 * 
 * @section MessageClassification Message Classification and Organization
 * Messages are systematically organized into functional categories for maintainability:
 * 
 * @subsection UserInterfaceMessages User Interface Messages
 * - Dialog prompts and confirmation dialogs (`quickPickYes`, `quickPickNo`)
 * - Button labels and interactive element text (`copyAscii`, `zoomIn`, `zoomOut`)
 * - Input field prompts and validation messages (`getHeaderDescription`, `getHeaderTags`)
 * - Menu items and command descriptions
 * 
 * @subsection SystemOperationMessages System Operation Messages
 * - File I/O operations (`fileLoaded`, `fileParseError`, `fileSaveFailed`)
 * - Configuration management and settings validation
 * - Directory and workspace management (`cwdUpdated`, `cwdDoesNotExist`)
 * - Process lifecycle and state management
 * 
 * @subsection HeaderManagementMessages Header Management Messages
 * - Template generation and metadata handling (`headerOpenerFound`, `headerWriteSuccess`)
 * - Content creation and injection workflows (`headerInjectQuestion`)
 * - Date and timestamp management (`lastModifiedUpdated`)
 * - Header validation and integrity checks (`brokenHeader`)
 * 
 * @subsection ErrorReportingMessages Error Reporting and Diagnostics
 * - Comprehensive error messages with actionable guidance
 * - Input validation errors (`inputboxError`, `quickPickError`)
 * - File operation failures with diagnostic information
 * - System state errors and recovery suggestions
 * 
 * @subsection FeatureContentMessages Specialized Feature Messages
 * - Watermark display and management (`watermarkPersonDisplayed`, `watermarkCopied`)
 * - Character showcase functionality (`darlingPersonDisplayed`, `darlingCopied`)
 * - Logo randomization and display (`logoDisplayed`, `logoChosen`)
 * - ASCII art handling and clipboard operations
 * 
 * @subsection ExtensionLifecycleMessages Extension Lifecycle Messages
 * - Activation and initialization (`extensionActivated`)
 * - Deactivation and cleanup procedures
 * - Status updates and operational notifications
 * - Version and compatibility information
 * 
 * @subsection DevelopmentSupportMessages Development Support Messages
 * - Debug output and diagnostic information (`arrayNodeContent`)
 * - Development-oriented logging and tracing
 * - Performance metrics and optimization data
 * - Testing and validation support messages
 * 
 * @section TechnicalImplementation Technical Implementation Details
 * 
 * @subsection FunctionBasedDesign Function-Based Architecture
 * Each message is implemented as a function to enable:
 * - Dynamic parameter injection with compile-time type checking
 * - Runtime parameter validation and sanitization
 * - Contextual message generation based on application state
 * - Deferred execution for performance optimization
 * 
 * @subsection TypeSafetySystem TypeScript Type Safety System
 * - Strongly-typed parameter interfaces ensure consistency across languages
 * - Generic type parameters for flexible message function signatures
 * - Compile-time validation of parameter count and types
 * - Runtime type assertion for development safety
 * 
 * @subsection PerformanceOptimization Performance Optimization Strategies
 * - Lazy evaluation prevents unnecessary message generation
 * - Efficient parameter handling with minimal object allocation
 * - Message caching for frequently accessed strings
 * - Tree-shaking support for production bundle optimization
 * 
 * @subsection MemoryManagement Memory Management
 * - Optimal memory usage through selective message loading
 * - Garbage collection friendly implementation patterns
 * - Minimal closure overhead in message functions
 * - Language pack loading on demand for memory efficiency
 * 
 * @subsection ErrorResilienceFramework Error Resilience Framework
 * - Graceful fallback to English for missing translations
 * - Runtime detection of incomplete language packs
 * - Error logging for missing message keys during development
 * - Automatic recovery from corrupted message data
 * 
 * @section ParameterInterpolation Parameter Interpolation System
 * 
 * @subsection NamedParameters Named Parameter Substitution
 * - Template syntax: `{paramName}` for clear parameter identification
 * - Case-sensitive parameter matching with validation
 * - Nested object property access support: `{object.property}`
 * - Default value specification: `{param|defaultValue}`
 * 
 * @subsection PositionalArguments Positional Parameter System
 * - Sequential parameter replacement for simple message templates
 * - Zero-indexed positional parameters: `{0}`, `{1}`, etc.
 * - Mixed named and positional parameter support
 * - Overflow protection for parameter count mismatches
 * 
 * @subsection TypeConversionSystem Type Conversion and Formatting
 * - Automatic type coercion for string, number, and boolean values
 * - Date and time formatting with locale-aware patterns
 * - Currency formatting with regional currency symbols
 * - Percentage and decimal formatting with locale rules
 * 
 * @subsection SecurityEscaping Security-Conscious Parameter Escaping
 * - HTML entity escaping for web view contexts
 * - URL encoding for parameter values in URLs
 * - JSON escape sequences for data serialization
 * - SQL injection prevention for database contexts
 * 
 * @subsection PluralizationRules Context-Sensitive Pluralization
 * - Language-specific plural form rules (singular, plural, zero, few, many)
 * - Cardinal and ordinal number pluralization support
 * - Gender-sensitive pluralization for applicable languages
 * - Custom pluralization rules for domain-specific terms
 * 
 * @subsection LocaleFormatting Locale-Appropriate Formatting
 * - Number formatting with locale-specific separators and grouping
 * - Currency display with proper symbol placement and precision
 * - Date and time formatting following regional conventions
 * - Unit conversion and display for measurements
 * 
 * Quality Assurance Process:
 * - **Native Speaker Review**: All translations reviewed by native speakers
 * - **Technical Accuracy**: Technical terminology validated by subject matter experts
 * - **Cultural Sensitivity**: Messages adapted for cultural appropriateness
 * - **Consistency Checking**: Automated validation of message key completeness
 * - **Context Validation**: Messages tested in actual usage contexts
 * 
 * Integration Framework:
 * This module provides the foundation for all user-facing text throughout:
 * - **Core Extension**: Primary extension interfaces and workflows
 * - **Configuration System**: Settings descriptions and validation messages
 * - **Interactive Features**: Webview content and user interaction prompts
 * - **Error Handling**: Comprehensive error reporting and diagnostic messages
 * - **Development Tools**: Debug output and development-oriented information
 * 
 * @example Message structure and usage:
 * ```typescript
 * const messages = {
 *   en: {
 *     fileLoaded: (filename: string) => `Successfully loaded ${filename}`,
 *     operationComplete: (count: number, duration: string) => 
 *       `Processed ${count} files in ${duration}`
 *   },
 *   fr: {
 *     fileLoaded: (filename: string) => `Fichier ${filename} charg√© avec succ√®s`,
 *     operationComplete: (count: number, duration: string) => 
 *       `${count} fichiers trait√©s en ${duration}`
 *   }
 * };
 * ```
 * 
 * @example Advanced localization features:
 * ```typescript
 * // Context-aware pluralization
 * itemCount: (count: number) => count === 1 ? "1 item" : `${count} items`,
 * 
 * // Cultural adaptations
 * dateFormat: (date: Date) => date.toLocaleDateString('en-US'),
 * 
 * // Technical terminology
 * configurationError: (setting: string, value: any) => 
 *   `Invalid configuration for ${setting}: ${value}`
 * ```
 */

/**
 * @brief Complete message dictionary for all supported languages with type-safe function interfaces
 * @export Exported for use by the MessageProvider system and extension components
 * 
 * @details Central repository of all localized messages used throughout the AsperHeader extension.
 * Each language is represented as a nested object where message keys map to functions
 * that generate the appropriate localized string. The function-based architecture enables
 * sophisticated localization features while maintaining type safety and performance.
 * 
 * @section FunctionBasedMessaging Function-Based Message Architecture
 * Function-based messages provide several key advantages:
 * - **Dynamic Parameter Interpolation**: Contextual information injection at runtime
 * - **Type-Safe Parameter Passing**: Full TypeScript type checking and IntelliSense support
 * - **Consistent Message Formatting**: Uniform parameter handling across all languages
 * - **Runtime Message Generation**: Complex conditional and contextual message creation
 * - **Performance Optimization**: Lazy evaluation and parameter validation
 * 
 * @section LanguageSupport Comprehensive Language Support
 * @subsection PrimaryLanguages Primary Language Support (100% Coverage)
 * - **en**: English (primary) - Complete reference implementation with American English conventions
 * - **fr**: French - Professional translation with French linguistic and cultural adaptations
 * - **it**: Italian - Complete Italian localization with proper grammatical structures
 * - **es**: Spanish - Full Spanish translation covering Latin American and European variants
 * - **de**: German - Comprehensive German localization with technical precision
 * 
 * @subsection GlobalLanguages Extended Global Language Support
 * - **ja**: Japanese - Native Japanese with proper honorifics and technical terminology
 * - **ko**: Korean - Complete Korean with appropriate formality levels
 * - **zh-cn**: Chinese Simplified - Mainland Chinese with simplified character set
 * - **zh-tw**: Chinese Traditional - Traditional Chinese for Taiwan/Hong Kong regions
 * - **ru**: Russian - Full Cyrillic support with Russian technical conventions
 * - **pt-br**: Brazilian Portuguese - Regional Brazilian adaptations
 * - **tr**: Turkish - Turkish localization with agglutinative language considerations
 * - **pl**: Polish - Polish with complex grammar and case system support
 * - **cs**: Czech - Czech localization with Slavic linguistic characteristics
 * - **hu**: Hungarian - Hungarian with unique Finno-Ugric language features
 * 
 * @section UsagePatterns Usage Patterns and Examples
 * @code{.typescript}
 * // Basic parameter interpolation
 * messages.en.fileLoaded("/path/to/file")          // "File /path/to/file loaded!"
 * messages.fr.fileLoaded("/chemin/vers/fichier")   // "Fichier /chemin/vers/fichier charg√© !"
 * 
 * // Complex multi-parameter messages
 * messages.en.sayHelloWorldResponse(".ts", "main.ts", "/src/main.ts", "typescript")
 * // "Hello world! This file's extension is: .ts, it's name is: main.ts..."
 * 
 * // Error handling with contextual information
 * messages.en.fileParseError("/invalid.json", "SyntaxError: Unexpected token")
 * // "The file content (/invalid.json) could not be loaded successfully. Error: SyntaxError..."
 * @endcode
 * 
 * @section MessageCategories Functional Message Categories
 * Messages are systematically organized into the following categories:
 * 
 * @subsection IOOperations Input/Output Operations
 * - File loading, saving, and parsing operations (`fileLoaded`, `fileParseError`, `fileSaveFailed`)
 * - Directory and workspace management (`cwdUpdated`, `filePathUpdated`)
 * - Configuration file handling and validation
 * 
 * @subsection UserInterface User Interface Interactions
 * - Dialog prompts and confirmations (`quickPickYes`, `quickPickNo`, `headerInjectQuestion`)
 * - Input field labels and validation messages (`getHeaderDescription`, `getHeaderTags`)
 * - Button labels and interactive element text (`copyAscii`, `zoomIn`, `zoomOut`)
 * 
 * @subsection HeaderManagement Header Management Operations
 * - Header creation, updating, and validation (`headerOpenerFound`, `headerWriteSuccess`)
 * - Template injection and refresh workflows (`headerInjectQuestion`, `lastModifiedUpdated`)
 * - Metadata extraction and timestamp management (`updatingEditionDate`)
 * 
 * @subsection FeatureDisplays Specialized Feature Operations
 * - Watermark display and clipboard operations (`watermarkPersonDisplayed`, `watermarkCopied`)
 * - Character showcase functionality (`darlingPersonDisplayed`, `darlingCopied`)
 * - Logo randomization and display management (`logoDisplayed`, `logoChosen`)
 * - ASCII art processing and user interactions
 * 
 * @subsection ErrorHandling Error Handling and Diagnostics
 * - File operation errors with actionable guidance (`fileSaveFailed`, `fileParseError`)
 * - Input validation failures (`inputboxError`, `quickPickError`)
 * - System state errors and recovery procedures (`closedDocument`, `emptyDocument`)
 * - Language and configuration detection failures (`languageNotFound`, `missingFileError`)
 * 
 * @subsection ExtensionLifecycle Extension Lifecycle Management
 * - Activation and initialization notifications (`extensionActivated`, `helloWorldGreetingsCommand`)
 * - Status updates and operational feedback (`messageWritten`, `extensionActivated`)
 * - Resource management and cleanup procedures
 * 
 * @subsection DevelopmentUtilities Development and Debugging Support
 * - Debug output and diagnostic information (`arrayNodeContent`, `inputArgs`)
 * - Performance monitoring and optimization data
 * - Development-time logging and error tracking (`errorDuringFunctionCall`)
 * 
 * @section TypeSafetyContract Type Safety Contract
 * @note All message functions must maintain consistent parameter signatures across languages
 * @note Parameter types should be explicitly defined in TypeScript for compile-time validation
 * @note Runtime parameter validation should be implemented for production safety
 * 
 * @section FallbackMechanism Fallback and Error Handling
 * @note Missing translations automatically fall back to English through the MessageProvider system
 * @note Undefined message keys return a standardized error message with the missing key identifier
 * @note Language pack validation occurs during extension initialization for early error detection
 * 
 * @since 1.0.0
 * @version 1.0.8
 * @see MessageProvider For the primary interface to access these messages
 * @see Logger For integration with the extension's logging system
 */
export const messages: Record<string, Record<string, (...args: any[]) => string>> = {
    "en": {
        inputboxError: (promptText: string, err: string): string => `Error in inputBox for ${promptText}: ${err}`,
        quickPickError: (err: string): string => `Error in quickPick: ${err}`,
        quickPickYes: (): string => "Yes",
        quickPickNo: (): string => "No",
        watermarkView: (): string => "watermarkView",
        watermarkJsonFileInvalid: (): string => "Watermark JSON file is empty or invalid",
        watermarkName: (): string => "Watermark name",
        watermarkCopyAscii: (): string => "Copy ASCII",
        watermarkZoomIn: (): string => "Zoom In",
        watermarkZoomOut: (): string => "Zoom Out",
        watermarkPersonDisplayed: (name: string): string => `Watermark '${name}' displayed.`,
        watermarkChosen: (watermark: string[]): string => `Watermark to display: ${JSON.stringify(watermark)}`,
        watermarkNotFound: (): string => "Watermark not found",
        watermarkCopied: (name: string): string => `ASCII art copied for ${name}!`,
        watermarkAuthorName: (): string => "Author name",
        darlingView: (): string => "darlingView",
        darlingJsonFileInvalid: (): string => "Darling JSON file is empty or invalid",
        darlingPersonDisplayed: (name: string): string => `Character '${name}' displayed.`,
        darlingCopyAscii: (): string => "Copy ASCII",
        darlingZoomIn: (): string => "Zoom In",
        darlingZoomOut: (): string => "Zoom Out",
        darlingType: (): string => "Type",
        darlingAge: (): string => "Age",
        darlingHeight: (): string => "Height",
        darlingAlias: (): string => "Alias",
        darlingDescription: (): string => "Description",
        darlingQuote: (): string => "Quote",
        darlingMoreInfo: (): string => "More info",
        darlingImage: (): string => "Image",
        darlingCopied: (name: string): string => `ASCII art copied for ${name}!`,
        logoView: (): string => "logoView",
        logoName: (): string => "Logo name",
        logoMessage: (logoPath: string): string => `File (${logoPath}) ignored because it is not the type we are looking for.`,
        logoNoRootDir: (): string => "No root directory was provided for gathering the logos",
        logoRootDirUpdateError: (error: string): string => `An error occurred during the update of the logo files, error: ${error}`,
        logoDisplayed: (name: string): string => `Logo '${name}' displayed.`,
        logoCopied: (logoName: string): string => `ASCII art copied for ${logoName}!`,
        logoChosen: (logo: string[]): string => `Logo to display: ${JSON.stringify(logo)}`,
        logoNotFound: (): string => "Logo not found",
        logoCopyAscii: (): string => "Copy ASCII",
        logoZoomIn: (): string => "Zoom In",
        logoZoomOut: (): string => "Zoom Out",
        noCommentToShow: (): string => "There is no comment to show.",
        unknown: (): string => "Unknown",
        headerOpenerFound: (): string => "Header opener found.",
        headerOpenerAndCloserFound: (): string => "Header opener and closer found, proceeding to date update after sanity check.",
        headerWriteFailed: (): string => "Failed to write the header to the file, check the logs.",
        headerWriteSuccess: (): string => "Header written successfully.",
        headerNotFound: (): string => "No header was found in this document.",
        headerInjectQuestion: (): string => "No header was found in this document. Would you like to add one?",
        headerInjectQuestionRefused: (): string => "You decided not to add the a header to the file.",
        morseConverted: (input: string, final: string): string => `Converted: ${input} to ${final}`,
        morseDecoded: (input: string, final: string): string => `Converted: ${input} to ${final}`,
        fileLoaded: (absolutePath: string): string => `File ${absolutePath} loaded!`,
        fileParseError: (filePath: string, error: string): string => `The file content (${filePath}) could not be loaded successfully. Error: ${error}.`,
        fileRefreshed: (): string => "Refreshing file content.",
        filePathUpdated: (oldFilePath: string, newFilePath: string): string => `The path has been updated from ${oldFilePath} to ${newFilePath}.`,
        fileUnloaded: (filePath: string): string => `File ${filePath} unloaded from memory`,
        fileExcludedActivationDisabled: (): string => "Activation disabled, the file is in the activation exclusion list.",
        fileSaveFailed: (): string => "Failed to save the file, please try saving it again.",
        cwdUpdated: (oldCwd: string, newCwd: string): string => `The current working directory referential has been updated from ${oldCwd} to ${newCwd}.`,
        cwdDoesNotExist: (cwd: string): string => `The provided current working directory ${cwd} does not exist.`,
        updatingEditionDate: (): string => "Updating the edition date.",
        documentLineScanExceeded: (maxScanLength: number): string => `Scanned the first ${maxScanLength} line(s) of the file but no header was found.`,
        closedDocument: (): string => "The document is closed, stopping operations.",
        emptyDocument: (): string => "There is no document body to work with.",
        brokenHeader: (): string => "Broken header detected, injecting new one, please remove the previous one.",
        extensionActivated: (moduleName: string): string => `üöÄ "${moduleName}" is now active!`,
        helloWorldGreetingsCommand: (moduleName: string): string => `Hello World from ${moduleName}!`,
        noActiveEditor: (): string => "No active file!",
        noFocusedEditors: (): string => "There are no files in focus.",
        noLogoInstanceProvided: (): string => "No provided logo randomiser instance.",
        randomLogoGatheringFailed: (error: string): string => `The random logo gathering failed, using default logo, error: "${error}"`,
        ramdomLogoGatheringLogoUndefined: (): string => "The logo content is undefined.",
        openFileToApplyHeader: (): string => "Please open a file on which to apply the header.",
        corruptedFileMetaData: (): string => "The required file meta data appears to not have been gathered correctly, aborting.",
        messageWritten: (): string => "Message written",
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string): string => `Hello world! This file's extension is: ${fileExtension}, it's name is: ${fileName}, it's path is: ${filePath}, determined language: ${languageId}\n`,
        missingFileError: (): string => "The language dictionary is missing, comment adaptability is thus disabled.",
        unknownFileStructure: (): string => "The language dictionary structure is unknown, comment adaptability is thus disabled.",
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]): string => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}.`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string): string => `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        identifiedLanguage: (langName: string): string => `Identified language: ${langName}.`,
        errorDuringFunctionCall: (functionName: string): string => `Something went wrong during the function (${functionName}) call, check logs for more info.`,
        missingLanguageComment: (): string => "Language comment not provided, skipping assignement.",
        getHeaderDescription: (): string => "Please provide a description: ",
        getHeaderTags: (): string => "Please enter the tags for this file, separated by commas:",
        getHeaderPurpose: (): string => "Please provide the purpose of the file:",
        noProvidedCommentOptions: (): string => "There are no options that were provided.",
        chooseSingleLineCommentOption: (): string => "Please select your preferred comment prefix from the options below:",
        toMorseGetInput: (): string => "Please enter the text to convert",
        fromMorseGetInput: (): string => "Please enter the text to convert from",
        operationCanceled: (): string => "Operation cancelled",
        convertedContentCli: (content: string): string => `Converted content: ${content}`,
        convertedContentGui: (): string => "Converted content: ",
        updateAbortedBecauseFileClosedSyncCancelled: (): string => "Update aborted because the file is closed and will thus not be synced.",
        updateEditDateMissingBounds: (): string => "Could not update the header: internal header markers were not found.",
        lastModifiedLineNotFound: (): string => "The header does not contain a 'Last Modified' line to update.",
        lastModifiedUpdated: (): string => "Last Modified' date has been updated successfully.",
        languageNotFound: (LanguageId: string, fileExtension: string): string => `The file language of this document could not be identified, languageID: ${LanguageId}, fileExtention: ${fileExtension}`,
        jsonContent: (jsonContentString: String) => `The content of the comment json file: ${jsonContentString}`,
        inFunction: (functionName: string, className: string = "Not specified") => `In function: '${functionName}' from class: '${className}'`,
        foundLanguageComment: (): string => "Language comment file is present",
        foundFocusEditor: (): string => "There is an editor in focus",
        foundLogoInstance: (): string => "There is a logo instance that has been provided.",
        foundNewLine: (newLineType: string): string => `The new determined line is '${newLineType}'`,
        foundWorkingDirectory: (): string => "The provided current workign directory exists",
        messageNotFound: (key: string): string => `Message '${key}' not found.`
    },
    "fr": {
        inputboxError: (promptText: string, err: string): string => `Erreur dans la bo√Æte de saisie pour ${promptText} : ${err}`,
        quickPickError: (err: string): string => `Erreur dans quickPick : ${err}`,
        quickPickYes: (): string => "Oui",
        quickPickNo: (): string => "Non",
        noCommentToShow: (): string => "Il n‚Äôy a aucun commentaire √† afficher.",
        unknown: (): string => "Inconnu",
        headerOpenerFound: (): string => "D√©but d‚Äôen-t√™te trouv√©.",
        headerOpenerAndCloserFound: (): string => "D√©but et fin d‚Äôen-t√™te trouv√©s, mise √† jour de la date apr√®s v√©rification.",
        headerWriteFailed: (): string => "√âchec de l‚Äô√©criture de l‚Äôen-t√™te dans le fichier, consultez les journaux.",
        headerWriteSuccess: (): string => "En-t√™te √©crit avec succ√®s.",
        morseConverted: (input: string, final: string): string => `Converti : ${input} en ${final}`,
        morseDecoded: (input: string, final: string): string => `Converti : ${input} en ${final}`,
        fileLoaded: (absolutePath: string): string => `Fichier ${absolutePath} charg√© !`,
        fileParseError: (filePath: string, error: string): string => `Le contenu du fichier (${filePath}) n‚Äôa pas pu √™tre charg√© correctement. Erreur : ${error}.`,
        fileRefreshed: (): string => "Actualisation du contenu du fichier.",
        filePathUpdated: (oldFilePath: string, newFilePath: string): string => `Le chemin a √©t√© mis √† jour de ${oldFilePath} vers ${newFilePath}.`,
        fileUnloaded: (filePath: string): string => `Fichier ${filePath} d√©charg√© de la m√©moire.`,
        cwdUpdated: (oldCwd: string, newCwd: string): string => `Le r√©pertoire de travail a √©t√© mis √† jour de ${oldCwd} vers ${newCwd}.`,
        cwdDoesNotExist: (cwd: string): string => `Le r√©pertoire de travail fourni ${cwd} n‚Äôexiste pas.`,
        updatingEditionDate: (): string => "Mise √† jour de la date de modification.",
        documentLineScanExceeded: (maxScanLength: number): string => `Analyse des ${maxScanLength} premi√®res lignes du fichier, aucun en-t√™te trouv√©.`,
        closedDocument: (): string => "Le document est ferm√©, arr√™t des op√©rations.",
        emptyDocument: (): string => "Il n‚Äôy a aucun document √† traiter.",
        brokenHeader: (): string => "En-t√™te corrompu d√©tect√©, injection d‚Äôun nouveau, veuillez supprimer l‚Äôancien.",
        extensionActivated: (moduleName: string): string => `üöÄ L'extension ¬´ ${moduleName} ¬ª est maintenant active !`,
        helloWorldGreetingsCommand: (moduleName: string): string => `Hello World de ${moduleName} !`,
        noActiveEditor: (): string => "Aucun fichier actif !",
        noFocusedEditors: (): string => "Aucun fichier n‚Äôest en focus.",
        openFileToApplyHeader: (): string => "Veuillez ouvrir un fichier sur lequel appliquer l‚Äôen-t√™te.",
        corruptedFileMetaData: (): string => "Les m√©tadonn√©es n√©cessaires du fichier n‚Äôont pas √©t√© correctement collect√©es, abandon.",
        messageWritten: (): string => "Message √©crit",
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string): string => `Hello world ! Extension : ${fileExtension}, nom : ${fileName}, chemin : ${filePath}, langage : ${languageId}\n`,
        missingFileError: (): string => "Le dictionnaire des langages est manquant, l‚Äôadaptabilit√© des commentaires est d√©sactiv√©e.",
        unknownFileStructure: (): string => "La structure du dictionnaire des langages est inconnue, l‚Äôadaptabilit√© des commentaires est d√©sactiv√©e.",
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]): string => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}.`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string): string => `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        identifiedLanguage: (langName: string): string => `Langage identifi√© : ${langName}.`,
        errorDuringFunctionCall: (functionName: string): string => `Une erreur est survenue lors de l‚Äôappel de la fonction (${functionName}), consultez les journaux.`,
        missingLanguageComment: (): string => "Commentaire de langage non fourni, assignation ignor√©e.",
        getHeaderDescription: (): string => "Veuillez fournir une description : ",
        getHeaderTags: (): string => "Veuillez saisir les tags de ce fichier, s√©par√©s par des virgules :",
        getHeaderPurpose: (): string => "Veuillez fournir l‚Äôobjectif du fichier :",
        noProvidedCommentOptions: (): string => "Aucune option de commentaire n‚Äôa √©t√© fournie.",
        chooseSingleLineCommentOption: (): string => "Veuillez s√©lectionner votre pr√©fixe de commentaire pr√©f√©r√© parmi les options ci-dessous :",
        toMorseGetInput: (): string => "Veuillez entrer le texte √† convertir",
        fromMorseGetInput: (): string => "Veuillez entrer le texte √† convertir depuis",
        operationCanceled: (): string => "Op√©ration annul√©e",
        convertedContentCli: (content: string): string => `Contenu converti : ${content}`,
        convertedContentGui: (): string => "Contenu converti : ",
        updateAbortedBecauseFileClosedSyncCancelled: (): string => "Mise √† jour annul√©e car le fichier est ferm√© et ne sera pas synchronis√©.",
        updateEditDateMissingBounds: (): string => "Impossible de mettre √† jour l‚Äôen-t√™te : les marqueurs internes n‚Äôont pas √©t√© trouv√©s.",
        lastModifiedLineNotFound: (): string => "L‚Äôen-t√™te ne contient pas de ligne ¬´ Derni√®re modification ¬ª √† mettre √† jour.",
        lastModifiedUpdated: (): string => "La date de ¬´ Derni√®re modification ¬ª a √©t√© mise √† jour avec succ√®s.",
        watermarkView: (): string => "vueWatermark",
        watermarkJsonFileInvalid: (): string => "Le fichier JSON de watermark est vide ou invalide",
        watermarkName: (): string => "Nom du watermark",
        watermarkCopyAscii: (): string => "Copier l'ASCII",
        watermarkZoomIn: (): string => "Zoomer",
        watermarkZoomOut: (): string => "D√©zoomer",
        watermarkPersonDisplayed: (name: string): string => `Watermark '${name}' affich√©.`,
        watermarkChosen: (watermark: string[]): string => `Watermark √† afficher : ${JSON.stringify(watermark)}`,
        watermarkNotFound: (): string => "Watermark introuvable",
        watermarkCopied: (name: string): string => `Art ASCII copi√© pour ${name} !`,
        watermarkAuthorName: (): string => "Auteur",
        darlingView: (): string => "vueDarling",
        darlingJsonFileInvalid: (): string => "Le fichier JSON Darling est vide ou invalide",
        darlingPersonDisplayed: (name: string): string => `Personnage '${name}' affich√©.`,
        darlingCopyAscii: (): string => "Copier l'ASCII",
        darlingZoomIn: (): string => "Zoomer",
        darlingZoomOut: (): string => "D√©zoomer",
        darlingType: (): string => "Type",
        darlingAge: (): string => "√Çge",
        darlingHeight: (): string => "Taille",
        darlingAlias: (): string => "Alias",
        darlingDescription: (): string => "Description",
        darlingQuote: (): string => "Citation",
        darlingMoreInfo: (): string => "Plus d'infos",
        darlingImage: (): string => "Image",
        darlingCopied: (name: string): string => `Art ASCII copi√© pour ${name} !`,
        logoView: (): string => "vueLogo",
        logoName: (): string => "Nom du logo",
        logoMessage: (logoPath: string): string => `Fichier (${logoPath}) ignor√© car ce n'est pas le type recherch√©.`,
        logoNoRootDir: (): string => "Aucun r√©pertoire racine fourni pour collecter les logos",
        logoRootDirUpdateError: (error: string): string => `Erreur lors de la mise √† jour des fichiers de logo, erreur : ${error}`,
        logoDisplayed: (name: string): string => `Logo '${name}' affich√©.`,
        logoCopied: (logoName: string): string => `Art ASCII copi√© pour ${logoName} !`,
        logoChosen: (logo: string[]): string => `Logo √† afficher : ${JSON.stringify(logo)}`,
        logoNotFound: (): string => "Logo introuvable",
        logoCopyAscii: (): string => "Copier l'ASCII",
        logoZoomIn: (): string => "Zoomer",
        logoZoomOut: (): string => "D√©zoomer",
        headerNotFound: (): string => "Aucun en-t√™te trouv√© dans ce document.",
        headerInjectQuestion: (): string => "Aucun en-t√™te trouv√© dans ce document. Souhaitez-vous en ajouter un ?",
        headerInjectQuestionRefused: (): string => "Vous avez d√©cid√© de ne pas ajouter d'en-t√™te au fichier.",
        fileExcludedActivationDisabled: (): string => "Activation d√©sactiv√©e, le fichier est dans la liste d'exclusion.",
        fileSaveFailed: (): string => "√âchec de la sauvegarde du fichier, veuillez r√©essayer.",
        noLogoInstanceProvided: (): string => "Aucune instance de randomiseur de logo fournie.",
        randomLogoGatheringFailed: (error: string): string => `La collecte al√©atoire de logo a √©chou√©, utilisation du logo par d√©faut, erreur : "${error}"`,
        ramdomLogoGatheringLogoUndefined: (): string => "Le contenu du logo est ind√©fini.",
        languageNotFound: (LanguageId: string, fileExtension: string): string => `La langue du fichier de ce document n'a pas pu √™tre identifi√©e, languageID : ${LanguageId}, extension du fichier : ${fileExtension}`,
        jsonContent: (jsonContentString: String) => `Contenu du fichier JSON de commentaires : ${jsonContentString}`,
        messageNotFound: (key: string): string => `Message '${key}' introuvable.`
    },
    "it": {
        inputboxError: (promptText: string, err: string): string => `Errore nella inputBox per ${promptText}: ${err}`,
        quickPickError: (err: string): string => `Errore in quickPick: ${err}`,
        quickPickYes: (): string => "S√¨",
        quickPickNo: (): string => "No",
        noCommentToShow: (): string => "Non ci sono commenti da mostrare.",
        unknown: (): string => "Sconosciuto",
        headerOpenerFound: (): string => "Inizio intestazione trovato.",
        headerOpenerAndCloserFound: (): string => "Inizio e fine intestazione trovati, aggiornamento della data dopo il controllo.",
        headerWriteFailed: (): string => "Impossibile scrivere l‚Äôintestazione nel file, controlla i log.",
        headerWriteSuccess: (): string => "Intestazione scritta con successo.",
        morseConverted: (input: string, final: string): string => `Convertito: ${input} in ${final}`,
        morseDecoded: (input: string, final: string): string => `Convertito: ${input} in ${final}`,
        fileLoaded: (absolutePath: string): string => `File ${absolutePath} caricato!`,
        fileParseError: (filePath: string, error: string): string => `Il contenuto del file (${filePath}) non √® stato caricato correttamente. Errore: ${error}.`,
        fileRefreshed: (): string => "Aggiornamento del contenuto del file.",
        filePathUpdated: (oldFilePath: string, newFilePath: string): string => `Il percorso √® stato aggiornato da ${oldFilePath} a ${newFilePath}.`,
        fileUnloaded: (filePath: string): string => `File ${filePath} scaricato dalla memoria.`,
        cwdUpdated: (oldCwd: string, newCwd: string): string => `La directory di lavoro √® stata aggiornata da ${oldCwd} a ${newCwd}.`,
        cwdDoesNotExist: (cwd: string): string => `La directory di lavoro fornita ${cwd} non esiste.`,
        updatingEditionDate: (): string => "Aggiornamento della data di modifica.",
        documentLineScanExceeded: (maxScanLength: number): string => `Analizzate le prime ${maxScanLength} righe del file, nessuna intestazione trovata.`,
        closedDocument: (): string => "Il documento √® chiuso, operazioni interrotte.",
        emptyDocument: (): string => "Non c‚Äô√® alcun documento su cui lavorare.",
        brokenHeader: (): string => "Intestazione danneggiata rilevata, iniezione di una nuova, si prega di rimuovere la precedente.",
        extensionActivated: (moduleName: string): string => `üöÄ La tua estensione ¬´ ${moduleName} ¬ª √® ora attiva!`,
        helloWorldGreetingsCommand: (moduleName: string): string => `Hello World da ${moduleName}!`,
        noActiveEditor: (): string => "Nessun file attivo!",
        noFocusedEditors: (): string => "Non ci sono file in focus.",
        openFileToApplyHeader: (): string => "Apri un file su cui applicare l‚Äôintestazione.",
        corruptedFileMetaData: (): string => "I metadati richiesti del file non sono stati raccolti correttamente, interruzione.",
        messageWritten: (): string => "Messaggio scritto",
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string): string => `Hello world! Estensione: ${fileExtension}, nome: ${fileName}, percorso: ${filePath}, linguaggio: ${languageId}\n`,
        missingFileError: (): string => "Il dizionario dei linguaggi √® mancante, adattabilit√† dei commenti disabilitata.",
        unknownFileStructure: (): string => "La struttura del dizionario dei linguaggi √® sconosciuta, adattabilit√† dei commenti disabilitata.",
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]): string => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}.`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string): string => `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        identifiedLanguage: (langName: string): string => `Linguaggio identificato: ${langName}.`,
        errorDuringFunctionCall: (functionName: string): string => `Qualcosa √® andato storto durante la chiamata della funzione (${functionName}), controlla i log per maggiori informazioni.`,
        missingLanguageComment: (): string => "Commento del linguaggio non fornito, assegnazione ignorata.",
        getHeaderDescription: (): string => "Fornisci una descrizione: ",
        getHeaderTags: (): string => "Inserisci i tag per questo file, separati da virgole:",
        getHeaderPurpose: (): string => "Fornisci lo scopo del file:",
        noProvidedCommentOptions: (): string => "Non sono state fornite opzioni di commento.",
        chooseSingleLineCommentOption: (): string => "Seleziona il prefisso di commento preferito dalle opzioni qui sotto:",
        toMorseGetInput: (): string => "Inserisci il testo da convertire",
        fromMorseGetInput: (): string => "Inserisci il testo da convertire da",
        operationCanceled: (): string => "Operazione annullata",
        convertedContentCli: (content: string): string => `Contenuto convertito: ${content}`,
        convertedContentGui: (): string => "Contenuto convertito: ",
        updateAbortedBecauseFileClosedSyncCancelled: (): string => "Aggiornamento annullato perch√© il file √® chiuso e non sar√† sincronizzato.",
        updateEditDateMissingBounds: (): string => "Impossibile aggiornare l‚Äôintestazione: marcatori interni non trovati.",
        lastModifiedLineNotFound: (): string => "L‚Äôintestazione non contiene una riga 'Ultima modifica' da aggiornare.",
        lastModifiedUpdated: (): string => "La data di 'Ultima modifica' √® stata aggiornata con successo.",
        watermarkView: (): string => "vistaWatermark",
        watermarkJsonFileInvalid: (): string => "Il file JSON watermark √® vuoto o non valido",
        watermarkName: (): string => "Nome watermark",
        watermarkCopyAscii: (): string => "Copia ASCII",
        watermarkZoomIn: (): string => "Ingrandisci",
        watermarkZoomOut: (): string => "Rimpicciolisci",
        watermarkPersonDisplayed: (name: string): string => `Watermark '${name}' visualizzato.`,
        watermarkChosen: (watermark: string[]): string => `Watermark da visualizzare: ${JSON.stringify(watermark)}`,
        watermarkNotFound: (): string => "Watermark non trovato",
        watermarkCopied: (name: string): string => `Arte ASCII copiata per ${name}!`,
        watermarkAuthorName: (): string => "Nome autore: ",
        darlingView: (): string => "vistaDarling",
        darlingJsonFileInvalid: (): string => "Il file JSON Darling √® vuoto o non valido",
        darlingPersonDisplayed: (name: string): string => `Personaggio '${name}' visualizzato.`,
        darlingCopyAscii: (): string => "Copia ASCII",
        darlingZoomIn: (): string => "Ingrandisci",
        darlingZoomOut: (): string => "Rimpicciolisci",
        darlingType: (): string => "Tipo",
        darlingAge: (): string => "Et√†",
        darlingHeight: (): string => "Altezza",
        darlingAlias: (): string => "Alias",
        darlingDescription: (): string => "Descrizione",
        darlingQuote: (): string => "Citazione",
        darlingMoreInfo: (): string => "Maggiori info",
        darlingImage: (): string => "Immagine",
        darlingCopied: (name: string): string => `Arte ASCII copiata per ${name}!`,
        logoView: (): string => "vistaLogo",
        logoName: (): string => "Nome logo",
        logoMessage: (logoPath: string): string => `File (${logoPath}) ignorato perch√© non √® del tipo cercato.`,
        logoNoRootDir: (): string => "Nessuna directory radice fornita per raccogliere i loghi",
        logoRootDirUpdateError: (error: string): string => `Errore durante l'aggiornamento dei file logo, errore: ${error}`,
        logoDisplayed: (name: string): string => `Logo '${name}' visualizzato.`,
        logoCopied: (logoName: string): string => `Arte ASCII copiata per ${logoName}!`,
        logoChosen: (logo: string[]): string => `Logo da visualizzare: ${JSON.stringify(logo)}`,
        logoNotFound: (): string => "Logo non trovato",
        logoCopyAscii: (): string => "Copia ASCII",
        logoZoomIn: (): string => "Ingrandisci",
        logoZoomOut: (): string => "Rimpicciolisci",
        headerNotFound: (): string => "Nessuna intestazione trovata in questo documento.",
        headerInjectQuestion: (): string => "Nessuna intestazione trovata in questo documento. Vuoi aggiungerne una?",
        headerInjectQuestionRefused: (): string => "Hai deciso di non aggiungere un'intestazione al file.",
        fileExcludedActivationDisabled: (): string => "Attivazione disabilitata, il file √® nella lista di esclusione.",
        fileSaveFailed: (): string => "Salvataggio del file fallito, riprova a salvarlo.",
        noLogoInstanceProvided: (): string => "Nessuna istanza di randomizzatore logo fornita.",
        randomLogoGatheringFailed: (error: string): string => `La raccolta casuale del logo √® fallita, uso del logo predefinito, errore: "${error}"`,
        ramdomLogoGatheringLogoUndefined: (): string => "Il contenuto del logo √® indefinito.",
        languageNotFound: (LanguageId: string, fileExtension: string): string => `Non √® stato possibile identificare la lingua del file di questo documento, languageID: ${LanguageId}, estensione del file: ${fileExtension}`,
        jsonContent: (jsonContentString: String) => `Contenuto del file JSON dei commenti: ${jsonContentString}`,
        messageNotFound: (key: string): string => `Messaggio '${key}' non trovato.`
    },
    "es": {
        inputboxError: (promptText: string, err: string): string => `Error en la inputBox para ${promptText}: ${err}`,
        quickPickError: (err: string): string => `Error en quickPick: ${err}`,
        quickPickYes: (): string => "S√≠",
        quickPickNo: (): string => "No",
        noCommentToShow: (): string => "No hay comentarios para mostrar.",
        unknown: (): string => "Desconocido",
        headerOpenerFound: (): string => "Se encontr√≥ el inicio del encabezado.",
        headerOpenerAndCloserFound: (): string => "Inicio y fin del encabezado encontrados, actualizando la fecha tras la verificaci√≥n.",
        headerWriteFailed: (): string => "Error al escribir el encabezado en el archivo, revise los registros.",
        headerWriteSuccess: (): string => "Encabezado escrito con √©xito.",
        morseConverted: (input: string, final: string): string => `Convertido: ${input} a ${final}`,
        morseDecoded: (input: string, final: string): string => `Convertido: ${input} a ${final}`,
        fileLoaded: (absolutePath: string): string => `Archivo ${absolutePath} cargado!`,
        fileParseError: (filePath: string, error: string): string => `El contenido del archivo (${filePath}) no se pudo cargar correctamente. Error: ${error}.`,
        fileRefreshed: (): string => "Actualizando contenido del archivo.",
        filePathUpdated: (oldFilePath: string, newFilePath: string): string => `La ruta se actualiz√≥ de ${oldFilePath} a ${newFilePath}.`,
        fileUnloaded: (filePath: string): string => `Archivo ${filePath} descargado de la memoria.`,
        cwdUpdated: (oldCwd: string, newCwd: string): string => `El directorio de trabajo se actualiz√≥ de ${oldCwd} a ${newCwd}.`,
        cwdDoesNotExist: (cwd: string): string => `El directorio de trabajo proporcionado ${cwd} no existe.`,
        updatingEditionDate: (): string => "Actualizando la fecha de edici√≥n.",
        documentLineScanExceeded: (maxScanLength: number): string => `Se escanearon las primeras ${maxScanLength} l√≠neas del archivo pero no se encontr√≥ encabezado.`,
        closedDocument: (): string => "El documento est√° cerrado, deteniendo operaciones.",
        emptyDocument: (): string => "No hay contenido en el documento.",
        brokenHeader: (): string => "Encabezado roto detectado, inyectando uno nuevo, por favor elimina el anterior.",
        extensionActivated: (moduleName: string): string => `üöÄ La extensi√≥n "${moduleName}" ahora est√° activa!`,
        helloWorldGreetingsCommand: (moduleName: string): string => `¬°Hola Mundo desde ${moduleName}!`,
        noActiveEditor: (): string => "¬°No hay archivo activo!",
        noFocusedEditors: (): string => "No hay archivos enfocados.",
        openFileToApplyHeader: (): string => "Por favor, abre un archivo para aplicar el encabezado.",
        corruptedFileMetaData: (): string => "Los metadatos del archivo no se recopilaron correctamente, abortando.",
        messageWritten: (): string => "Mensaje escrito",
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string): string => `¬°Hola mundo! La extensi√≥n de este archivo es: ${fileExtension}, su nombre es: ${fileName}, su ruta es: ${filePath}, lenguaje determinado: ${languageId}\n`,
        missingFileError: (): string => "Falta el diccionario de idiomas, la adaptabilidad de comentarios est√° deshabilitada.",
        unknownFileStructure: (): string => "La estructura del diccionario de idiomas es desconocida, la adaptabilidad de comentarios est√° deshabilitada.",
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]): string => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}.`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string): string => `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        identifiedLanguage: (langName: string): string => `Idioma identificado: ${langName}.`,
        errorDuringFunctionCall: (functionName: string): string => `Algo sali√≥ mal durante la llamada de la funci√≥n (${functionName}), revise los registros.`,
        missingLanguageComment: (): string => "Comentario de idioma no proporcionado, omitiendo asignaci√≥n.",
        getHeaderDescription: (): string => "Por favor, proporciona una descripci√≥n: ",
        getHeaderTags: (): string => "Ingrese las etiquetas para este archivo, separadas por comas:",
        getHeaderPurpose: (): string => "Proporcione el prop√≥sito del archivo:",
        noProvidedCommentOptions: (): string => "No se proporcionaron opciones de comentario.",
        chooseSingleLineCommentOption: (): string => "Seleccione su prefijo de comentario preferido de las opciones a continuaci√≥n:",
        toMorseGetInput: (): string => "Por favor, introduzca el texto a convertir",
        fromMorseGetInput: (): string => "Por favor, introduzca el texto a convertir desde",
        operationCanceled: (): string => "Operaci√≥n cancelada",
        convertedContentCli: (content: string): string => `Contenido convertido: ${content}`,
        convertedContentGui: (): string => "Contenido convertido: ",
        updateAbortedBecauseFileClosedSyncCancelled: (): string => "Actualizaci√≥n abortada porque el archivo est√° cerrado y no se sincronizar√°.",
        updateEditDateMissingBounds: (): string => "No se pudo actualizar el encabezado: no se encontraron los marcadores internos.",
        lastModifiedLineNotFound: (): string => "El encabezado no contiene una l√≠nea '√öltima modificaci√≥n' para actualizar.",
        lastModifiedUpdated: (): string => "La fecha de '√öltima modificaci√≥n' se actualiz√≥ correctamente.",
        watermarkView: (): string => "vistaMarcaAgua",
        watermarkJsonFileInvalid: (): string => "El archivo JSON de la marca de agua est√° vac√≠o o es inv√°lido",
        watermarkName: (): string => "Nombre de la marca de agua",
        watermarkCopyAscii: (): string => "Copiar ASCII",
        watermarkZoomIn: (): string => "Acercar",
        watermarkZoomOut: (): string => "Alejar",
        watermarkPersonDisplayed: (name: string): string => `Marca de agua '${name}' mostrada.`,
        watermarkChosen: (watermark: string[]): string => `Marca de agua a mostrar: ${JSON.stringify(watermark)}`,
        watermarkNotFound: (): string => "Marca de agua no encontrada",
        watermarkCopied: (name: string): string => `Arte ASCII copiado para ${name}!`,
        watermarkAuthorName: (): string => "Nombre del autor",
        darlingView: (): string => "vistaDarling",
        darlingJsonFileInvalid: (): string => "El archivo JSON de Darling est√° vac√≠o o es inv√°lido",
        darlingPersonDisplayed: (name: string): string => `Personaje '${name}' mostrado.`,
        darlingCopyAscii: (): string => "Copiar ASCII",
        darlingZoomIn: (): string => "Acercar",
        darlingZoomOut: (): string => "Alejar",
        darlingType: (): string => "Tipo",
        darlingAge: (): string => "Edad",
        darlingHeight: (): string => "Altura",
        darlingAlias: (): string => "Alias",
        darlingDescription: (): string => "Descripci√≥n",
        darlingQuote: (): string => "Cita",
        darlingMoreInfo: (): string => "M√°s informaci√≥n",
        darlingImage: (): string => "Imagen",
        darlingCopied: (name: string): string => `Arte ASCII copiado para ${name}!`,
        logoView: (): string => "vistaLogo",
        logoName: (): string => "Nombre del logo",
        logoMessage: (logoPath: string): string => `Archivo (${logoPath}) ignorado porque no es el tipo buscado.`,
        logoNoRootDir: (): string => "No se proporcion√≥ directorio ra√≠z para recopilar los logos",
        logoRootDirUpdateError: (error: string): string => `Ocurri√≥ un error durante la actualizaci√≥n de los archivos de logo, error: ${error}`,
        logoDisplayed: (name: string): string => `Logo '${name}' mostrado.`,
        logoCopied: (logoName: string): string => `Arte ASCII copiado para ${logoName}!`,
        logoChosen: (logo: string[]): string => `Logo a mostrar: ${JSON.stringify(logo)}`,
        logoNotFound: (): string => "Logo no encontrado",
        logoCopyAscii: (): string => "Copiar ASCII",
        logoZoomIn: (): string => "Acercar",
        logoZoomOut: (): string => "Alejar",
        headerNotFound: (): string => "No se encontr√≥ encabezado en este documento.",
        headerInjectQuestion: (): string => "No se encontr√≥ encabezado en este documento. ¬øDesea agregar uno?",
        headerInjectQuestionRefused: (): string => "Decidi√≥ no agregar un encabezado al archivo.",
        fileExcludedActivationDisabled: (): string => "Activaci√≥n deshabilitada, el archivo est√° en la lista de exclusi√≥n.",
        fileSaveFailed: (): string => "No se pudo guardar el archivo, intente guardarlo nuevamente.",
        noLogoInstanceProvided: (): string => "No se proporcion√≥ instancia de randomizador de logo.",
        randomLogoGatheringFailed: (error: string): string => `La recopilaci√≥n aleatoria de logos fall√≥, usando el logo predeterminado, error: "${error}"`,
        ramdomLogoGatheringLogoUndefined: (): string => "El contenido del logo es indefinido.",
        languageNotFound: (LanguageId: string, fileExtension: string): string => `No se pudo identificar el idioma del archivo de este documento, languageID: ${LanguageId}, extensi√≥n del archivo: ${fileExtension}`,
        jsonContent: (jsonContentString: String) => `Contenido del archivo JSON de comentarios: ${jsonContentString}`,
        messageNotFound: (key: string): string => `Mensaje '${key}' no encontrado.`
    },
    "zh-cn": {
        inputboxError: (promptText: string, err: string) => `ËæìÂÖ•Ê°ÜÈîôËØØÔºö${promptText}ÔºåÈîôËØØÔºö${err}`,
        quickPickError: (err: string) => `Âø´ÈÄüÈÄâÊã©ÈîôËØØÔºö${err}`,
        quickPickYes: () => "ÊòØ",
        quickPickNo: () => "Âê¶",
        watermarkView: () => "Ê∞¥Âç∞ËßÜÂõæ",
        watermarkJsonFileInvalid: () => "Ê∞¥Âç∞ JSON Êñá‰ª∂‰∏∫Á©∫ÊàñÊó†Êïà",
        watermarkName: () => "Ê∞¥Âç∞ÂêçÁß∞",
        watermarkCopyAscii: () => "Â§çÂà∂ ASCII",
        watermarkZoomIn: () => "ÊîæÂ§ß",
        watermarkZoomOut: () => "Áº©Â∞è",
        watermarkPersonDisplayed: (name: string) => `Ê∞¥Âç∞ '${name}' Â∑≤ÊòæÁ§∫„ÄÇ`,
        watermarkChosen: (watermark: string[]) => `Ë¶ÅÊòæÁ§∫ÁöÑÊ∞¥Âç∞Ôºö${JSON.stringify(watermark)}`,
        watermarkNotFound: () => "Êú™ÊâæÂà∞Ê∞¥Âç∞",
        watermarkCopied: (name: string) => `${name} ÁöÑ ASCII Ëâ∫ÊúØÂ∑≤Â§çÂà∂ÔºÅ`,
        watermarkAuthorName: () => "‰ΩúËÄÖÂêçÁß∞",
        darlingView: () => "ËßíËâ≤ËßÜÂõæ",
        darlingJsonFileInvalid: () => "Darling JSON Êñá‰ª∂‰∏∫Á©∫ÊàñÊó†Êïà",
        darlingPersonDisplayed: (name: string) => `ËßíËâ≤ '${name}' Â∑≤ÊòæÁ§∫„ÄÇ`,
        darlingCopyAscii: () => "Â§çÂà∂ ASCII",
        darlingZoomIn: () => "ÊîæÂ§ß",
        darlingZoomOut: () => "Áº©Â∞è",
        darlingType: () => "Á±ªÂûã",
        darlingAge: () => "Âπ¥ÈæÑ",
        darlingHeight: () => "Ë∫´È´ò",
        darlingAlias: () => "Âà´Âêç",
        darlingDescription: () => "ÊèèËø∞",
        darlingQuote: () => "ÂºïÁî®",
        darlingMoreInfo: () => "Êõ¥Â§ö‰ø°ÊÅØ",
        darlingImage: () => "ÂõæÂÉè",
        darlingCopied: (name: string) => `${name} ÁöÑ ASCII Ëâ∫ÊúØÂ∑≤Â§çÂà∂ÔºÅ`,
        logoView: () => "ÂæΩÊ†áËßÜÂõæ",
        logoName: () => "ÂæΩÊ†áÂêçÁß∞",
        logoMessage: (logoPath: string) => `Êñá‰ª∂ (${logoPath}) Ë¢´ÂøΩÁï•ÔºåÂõ†‰∏∫ÂÆÉ‰∏çÊòØÊàë‰ª¨ÈúÄË¶ÅÁöÑÁ±ªÂûã„ÄÇ`,
        logoNoRootDir: () => "Êú™Êèê‰æõÁî®‰∫éÊî∂ÈõÜÂæΩÊ†áÁöÑÊ†πÁõÆÂΩï",
        logoRootDirUpdateError: (error: string) => `Êõ¥Êñ∞ÂæΩÊ†áÊñá‰ª∂Êó∂Âá∫ÈîôÔºåÈîôËØØÔºö${error}`,
        logoDisplayed: (name: string) => `ÂæΩÊ†á '${name}' Â∑≤ÊòæÁ§∫„ÄÇ`,
        logoCopied: (logoName: string) => `${logoName} ÁöÑ ASCII Ëâ∫ÊúØÂ∑≤Â§çÂà∂ÔºÅ`,
        logoChosen: (logo: string[]) => `Ë¶ÅÊòæÁ§∫ÁöÑÂæΩÊ†áÔºö${JSON.stringify(logo)}`,
        logoNotFound: () => "Êú™ÊâæÂà∞ÂæΩÊ†á",
        logoCopyAscii: () => "Â§çÂà∂ ASCII",
        logoZoomIn: () => "ÊîæÂ§ß",
        logoZoomOut: () => "Áº©Â∞è",
        noCommentToShow: () => "Ê≤°ÊúâÂèØÊòæÁ§∫ÁöÑËØÑËÆ∫„ÄÇ",
        unknown: () => "Êú™Áü•",
        headerOpenerFound: () => "ÊâæÂà∞Â§¥ÈÉ®ÂºÄÂßãÊ†áËÆ∞„ÄÇ",
        headerOpenerAndCloserFound: () => "ÊâæÂà∞Â§¥ÈÉ®ÂºÄÂßãÂíåÁªìÊùüÊ†áËÆ∞ÔºåËøõË°åÊó•ÊúüÊõ¥Êñ∞ÂâçÁöÑÊ£ÄÊü•„ÄÇ",
        headerWriteFailed: () => "ÂÜôÂÖ•Â§¥ÈÉ®Â§±Ë¥•ÔºåËØ∑Ê£ÄÊü•Êó•Âøó„ÄÇ",
        headerWriteSuccess: () => "Â§¥ÈÉ®ÂÜôÂÖ•ÊàêÂäü„ÄÇ",
        headerNotFound: () => "Êú™ÊâæÂà∞Â§¥ÈÉ®„ÄÇ",
        headerInjectQuestion: () => "Êú™ÊâæÂà∞Â§¥ÈÉ®„ÄÇÊòØÂê¶Ê∑ªÂä†‰∏Ä‰∏™Ôºü",
        headerInjectQuestionRefused: () => "ÊÇ®ÈÄâÊã©‰∏çÂêëÊñá‰ª∂Ê∑ªÂä†Â§¥ÈÉ®„ÄÇ",
        morseConverted: (input: string, final: string) => `Â∑≤ËΩ¨Êç¢Ôºö${input} -> ${final}`,
        morseDecoded: (input: string, final: string) => `Â∑≤Ëß£Á†ÅÔºö${input} -> ${final}`,
        fileLoaded: (absolutePath: string) => `Êñá‰ª∂ ${absolutePath} Â∑≤Âä†ËΩΩÔºÅ`,
        fileParseError: (filePath: string, error: string) => `Êñá‰ª∂ÂÜÖÂÆπ (${filePath}) Âä†ËΩΩÂ§±Ë¥•„ÄÇÈîôËØØÔºö${error}„ÄÇ`,
        fileRefreshed: () => "Âà∑Êñ∞Êñá‰ª∂ÂÜÖÂÆπ„ÄÇ",
        filePathUpdated: (oldFilePath: string, newFilePath: string) => `Ë∑ØÂæÑÂ∑≤‰ªé ${oldFilePath} Êõ¥Êñ∞‰∏∫ ${newFilePath}„ÄÇ`,
        fileUnloaded: (filePath: string) => `Êñá‰ª∂ ${filePath} Â∑≤‰ªéÂÜÖÂ≠òÂç∏ËΩΩ„ÄÇ`,
        fileExcludedActivationDisabled: () => "ÊøÄÊ¥ªÂ∑≤Á¶ÅÁî®ÔºåÊñá‰ª∂Âú®ÊéíÈô§ÂàóË°®‰∏≠„ÄÇ",
        fileSaveFailed: () => "‰øùÂ≠òÊñá‰ª∂Â§±Ë¥•ÔºåËØ∑ÈáçËØï„ÄÇ",
        cwdUpdated: (oldCwd: string, newCwd: string) => `ÂΩìÂâçÂ∑•‰ΩúÁõÆÂΩïÂ∑≤‰ªé ${oldCwd} Êõ¥Êñ∞‰∏∫ ${newCwd}„ÄÇ`,
        cwdDoesNotExist: (cwd: string) => `Êèê‰æõÁöÑÂ∑•‰ΩúÁõÆÂΩï ${cwd} ‰∏çÂ≠òÂú®„ÄÇ`,
        updatingEditionDate: () => "Êõ¥Êñ∞ÁâàÊú¨Êó•Êúü„ÄÇ",
        documentLineScanExceeded: (maxScanLength: number) => `Êâ´ÊèèÊñá‰ª∂Ââç ${maxScanLength} Ë°åÔºå‰ΩÜÊú™ÊâæÂà∞Â§¥ÈÉ®„ÄÇ`,
        closedDocument: () => "ÊñáÊ°£Â∑≤ÂÖ≥Èó≠ÔºåÂÅúÊ≠¢Êìç‰Ωú„ÄÇ",
        emptyDocument: () => "ÊñáÊ°£‰∏∫Á©∫ÔºåÊó†Ê≥ïÊìç‰Ωú„ÄÇ",
        brokenHeader: () => "Ê£ÄÊµãÂà∞Á†¥ÊçüÁöÑÂ§¥ÈÉ®ÔºåÊ≠£Âú®Ê≥®ÂÖ•Êñ∞ÁöÑÔºåËØ∑Âà†Èô§ÊóßÁöÑ„ÄÇ",
        extensionActivated: (moduleName: string) => `üöÄ Êâ©Â±ï "${moduleName}" Â∑≤ÊøÄÊ¥ªÔºÅ`,
        helloWorldGreetingsCommand: (moduleName: string) => `Êù•Ëá™ ${moduleName} ÁöÑ Hello WorldÔºÅ`,
        noActiveEditor: () => "Ê≤°ÊúâÊ¥ªÂä®Êñá‰ª∂ÔºÅ",
        noFocusedEditors: () => "Ê≤°ÊúâÁÑ¶ÁÇπÊñá‰ª∂„ÄÇ",
        noLogoInstanceProvided: () => "Êú™Êèê‰æõÂæΩÊ†áÈöèÊú∫ÂÆû‰æã„ÄÇ",
        randomLogoGatheringFailed: (error: string) => `ÈöèÊú∫ÂæΩÊ†áÊî∂ÈõÜÂ§±Ë¥•Ôºå‰ΩøÁî®ÈªòËÆ§ÂæΩÊ†áÔºåÈîôËØØÔºö${error}`,
        ramdomLogoGatheringLogoUndefined: () => "ÂæΩÊ†áÂÜÖÂÆπÊú™ÂÆö‰πâ„ÄÇ",
        openFileToApplyHeader: () => "ËØ∑ÊâìÂºÄ‰∏Ä‰∏™Êñá‰ª∂‰ª•Â∫îÁî®Â§¥ÈÉ®„ÄÇ",
        corruptedFileMetaData: () => "Êñá‰ª∂ÂÖÉÊï∞ÊçÆÊú™Ê≠£Á°ÆÊî∂ÈõÜÔºå‰∏≠Ê≠¢Êìç‰Ωú„ÄÇ",
        messageWritten: () => "Ê∂àÊÅØÂ∑≤ÂÜôÂÖ•",
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string) => `Hello worldÔºÅÊâ©Â±ïÂêçÔºö${fileExtension}ÔºåÊñá‰ª∂ÂêçÔºö${fileName}ÔºåË∑ØÂæÑÔºö${filePath}ÔºåËØ≠Ë®ÄÔºö${languageId}\n`,
        missingFileError: () => "Áº∫Â∞ëËØ≠Ë®ÄÂ≠óÂÖ∏ÔºåÂõ†Ê≠§ËØÑËÆ∫ÈÄÇÈÖçË¢´Á¶ÅÁî®„ÄÇ",
        unknownFileStructure: () => "ËØ≠Ë®ÄÂ≠óÂÖ∏ÁªìÊûÑÊú™Áü•ÔºåÂõ†Ê≠§ËØÑËÆ∫ÈÄÇÈÖçË¢´Á¶ÅÁî®„ÄÇ",
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]) => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}„ÄÇ`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string) =>
            `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        identifiedLanguage: (langName: string) => `ËØÜÂà´ÁöÑËØ≠Ë®ÄÔºö${langName}„ÄÇ`,
        errorDuringFunctionCall: (functionName: string) => `Ë∞ÉÁî®ÂáΩÊï∞ (${functionName}) Êó∂Âá∫ÈîôÔºåËØ∑Êü•ÁúãÊó•Âøó„ÄÇ`,
        missingLanguageComment: () => "Êú™Êèê‰æõËØ≠Ë®ÄÊ≥®ÈáäÔºåË∑≥ËøáÂàÜÈÖç„ÄÇ",
        getHeaderDescription: () => "ËØ∑ËæìÂÖ•ÊèèËø∞Ôºö",
        getHeaderTags: () => "ËØ∑ËæìÂÖ•Êñá‰ª∂Ê†áÁ≠æÔºåÁî®ÈÄóÂè∑ÂàÜÈöîÔºö",
        getHeaderPurpose: () => "ËØ∑ËæìÂÖ•Êñá‰ª∂Áî®ÈÄîÔºö",
        noProvidedCommentOptions: () => "Êú™Êèê‰æõÊ≥®ÈáäÈÄâÈ°π„ÄÇ",
        chooseSingleLineCommentOption: () => "ËØ∑ÈÄâÊã©‰ª•‰∏ãÈÄâÈ°π‰∏≠ÁöÑÈ¶ñÈÄâÊ≥®ÈáäÂâçÁºÄÔºö",
        toMorseGetInput: (): string => "ËØ∑ËæìÂÖ•Ë¶ÅËΩ¨Êç¢ÁöÑÊñáÊú¨",
        fromMorseGetInput: (): string => "ËØ∑ËæìÂÖ•Ë¶Å‰ªé‰∏≠ËΩ¨Êç¢ÁöÑÊñáÊú¨",
        operationCanceled: (): string => "Êìç‰ΩúÂ∑≤ÂèñÊ∂à",
        convertedContentCli: (content: string): string => `ËΩ¨Êç¢ÂêéÁöÑÂÜÖÂÆπ: ${content}`,
        convertedContentGui: (): string => "ËΩ¨Êç¢ÂêéÁöÑÂÜÖÂÆπ: ",
        updateAbortedBecauseFileClosedSyncCancelled: () => "Êõ¥Êñ∞‰∏≠Ê≠¢ÔºåÂõ†‰∏∫Êñá‰ª∂Â∑≤ÂÖ≥Èó≠‰∏î‰∏ç‰ºöÂêåÊ≠•„ÄÇ",
        updateEditDateMissingBounds: () => "Êó†Ê≥ïÊõ¥Êñ∞Â§¥ÈÉ®ÔºöÊú™ÊâæÂà∞ÂÜÖÈÉ®Ê†áËÆ∞„ÄÇ",
        lastModifiedLineNotFound: () => "Â§¥ÈÉ®‰∏≠Êú™ÊâæÂà∞‚ÄúÊúÄÂêé‰øÆÊîπ‚ÄùË°å‰ª•Êõ¥Êñ∞„ÄÇ",
        lastModifiedUpdated: () => "‚ÄúÊúÄÂêé‰øÆÊîπ‚ÄùÊó•ÊúüÂ∑≤ÊàêÂäüÊõ¥Êñ∞„ÄÇ",
        languageNotFound: (LanguageId: string, fileExtension: string) => `Êó†Ê≥ïËØÜÂà´Êñá‰ª∂ËØ≠Ë®ÄÔºålanguageID: ${LanguageId}ÔºåÊâ©Â±ïÂêçÔºö${fileExtension}`,
        jsonContent: (jsonContentString: String) => `ËØÑËÆ∫ JSON Êñá‰ª∂ÂÜÖÂÆπÔºö${jsonContentString}`,
        messageNotFound: (key: string) => `Êú™ÊâæÂà∞Ê∂àÊÅØ '${key}'„ÄÇ`
    },
    "zh-tw": {
        inputboxError: (promptText: string, err: string) => `Ëº∏ÂÖ•Ê°ÜÈåØË™§Ôºö${promptText}ÔºåÈåØË™§Ôºö${err}`,
        quickPickError: (err: string) => `Âø´ÈÄüÈÅ∏ÊìáÈåØË™§Ôºö${err}`,
        quickPickYes: () => "ÊòØ",
        quickPickNo: () => "Âê¶",
        watermarkView: () => "Ê∞¥Âç∞Ê™¢Ë¶ñ",
        watermarkJsonFileInvalid: () => "Ê∞¥Âç∞ JSON Ê™îÊ°àÁÇ∫Á©∫ÊàñÁÑ°Êïà",
        watermarkName: () => "Ê∞¥Âç∞ÂêçÁ®±",
        watermarkCopyAscii: () => "Ë§áË£Ω ASCII",
        watermarkZoomIn: () => "ÊîæÂ§ß",
        watermarkZoomOut: () => "Á∏ÆÂ∞è",
        watermarkPersonDisplayed: (name: string) => `Ê∞¥Âç∞ '${name}' Â∑≤È°ØÁ§∫„ÄÇ`,
        watermarkChosen: (watermark: string[]) => `Ë¶ÅÈ°ØÁ§∫ÁöÑÊ∞¥Âç∞Ôºö${JSON.stringify(watermark)}`,
        watermarkNotFound: () => "Êú™ÊâæÂà∞Ê∞¥Âç∞",
        watermarkCopied: (name: string) => `${name} ÁöÑ ASCII ËóùË°ìÂ∑≤Ë§áË£ΩÔºÅ`,
        watermarkAuthorName: () => "‰ΩúËÄÖÂêçÁ®±",
        darlingView: () => "ËßíËâ≤Ê™¢Ë¶ñ",
        darlingJsonFileInvalid: () => "Darling JSON Ê™îÊ°àÁÇ∫Á©∫ÊàñÁÑ°Êïà",
        darlingPersonDisplayed: (name: string) => `ËßíËâ≤ '${name}' Â∑≤È°ØÁ§∫„ÄÇ`,
        darlingCopyAscii: () => "Ë§áË£Ω ASCII",
        darlingZoomIn: () => "ÊîæÂ§ß",
        darlingZoomOut: () => "Á∏ÆÂ∞è",
        darlingType: () => "È°ûÂûã",
        darlingAge: () => "Âπ¥ÈΩ°",
        darlingHeight: () => "Ë∫´È´ò",
        darlingAlias: () => "Âà•Âêç",
        darlingDescription: () => "ÊèèËø∞",
        darlingQuote: () => "ÂºïÁî®",
        darlingMoreInfo: () => "Êõ¥Â§öË≥áË®ä",
        darlingImage: () => "ÂúñÁâá",
        darlingCopied: (name: string) => `${name} ÁöÑ ASCII ËóùË°ìÂ∑≤Ë§áË£ΩÔºÅ`,
        logoView: () => "ÂæΩÊ®ôÊ™¢Ë¶ñ",
        logoName: () => "ÂæΩÊ®ôÂêçÁ®±",
        logoMessage: (logoPath: string) => `Ê™îÊ°à (${logoPath}) Ë¢´ÂøΩÁï•ÔºåÂõ†ÁÇ∫ÂÆÉ‰∏çÊòØÊâÄÈúÄÈ°ûÂûã„ÄÇ`,
        logoNoRootDir: () => "Êú™Êèê‰æõÁî®ÊñºÊî∂ÈõÜÂæΩÊ®ôÁöÑÊ†πÁõÆÈåÑ",
        logoRootDirUpdateError: (error: string) => `Êõ¥Êñ∞ÂæΩÊ®ôÊ™îÊ°àÊôÇÂá∫ÈåØÔºåÈåØË™§Ôºö${error}`,
        logoDisplayed: (name: string) => `ÂæΩÊ®ô '${name}' Â∑≤È°ØÁ§∫„ÄÇ`,
        logoCopied: (logoName: string) => `${logoName} ÁöÑ ASCII ËóùË°ìÂ∑≤Ë§áË£ΩÔºÅ`,
        logoChosen: (logo: string[]) => `Ë¶ÅÈ°ØÁ§∫ÁöÑÂæΩÊ®ôÔºö${JSON.stringify(logo)}`,
        logoNotFound: () => "Êú™ÊâæÂà∞ÂæΩÊ®ô",
        logoCopyAscii: () => "Ë§áË£Ω ASCII",
        logoZoomIn: () => "ÊîæÂ§ß",
        logoZoomOut: () => "Á∏ÆÂ∞è",
        noCommentToShow: () => "Ê≤íÊúâÂèØÈ°ØÁ§∫ÁöÑË©ïË´ñ„ÄÇ",
        unknown: () => "Êú™Áü•",
        headerOpenerFound: () => "ÊâæÂà∞È†≠ÈÉ®ÈñãÂßãÊ®ôË®ò„ÄÇ",
        headerOpenerAndCloserFound: () => "ÊâæÂà∞È†≠ÈÉ®ÈñãÂßãÂíåÁµêÊùüÊ®ôË®òÔºåÈÄ≤Ë°åÊó•ÊúüÊõ¥Êñ∞ÂâçÁöÑÊ™¢Êü•„ÄÇ",
        headerWriteFailed: () => "ÂØ´ÂÖ•È†≠ÈÉ®Â§±ÊïóÔºåË´ãÊ™¢Êü•Êó•Ë™å„ÄÇ",
        headerWriteSuccess: () => "È†≠ÈÉ®ÂØ´ÂÖ•ÊàêÂäü„ÄÇ",
        headerNotFound: () => "Êú™ÊâæÂà∞È†≠ÈÉ®„ÄÇ",
        headerInjectQuestion: () => "Êú™ÊâæÂà∞È†≠ÈÉ®„ÄÇÊòØÂê¶Ê∑ªÂä†‰∏ÄÂÄãÔºü",
        headerInjectQuestionRefused: () => "ÊÇ®ÈÅ∏Êìá‰∏çÂêëÊ™îÊ°àÊ∑ªÂä†È†≠ÈÉ®„ÄÇ",
        morseConverted: (input: string, final: string) => `Â∑≤ËΩâÊèõÔºö${input} -> ${final}`,
        morseDecoded: (input: string, final: string) => `Â∑≤Ëß£Á¢ºÔºö${input} -> ${final}`,
        fileLoaded: (absolutePath: string) => `Ê™îÊ°à ${absolutePath} Â∑≤Âä†ËºâÔºÅ`,
        fileParseError: (filePath: string, error: string) => `Ê™îÊ°àÂÖßÂÆπ (${filePath}) Âä†ËºâÂ§±Êïó„ÄÇÈåØË™§Ôºö${error}„ÄÇ`,
        fileRefreshed: () => "Âà∑Êñ∞Ê™îÊ°àÂÖßÂÆπ„ÄÇ",
        filePathUpdated: (oldFilePath: string, newFilePath: string) => `Ë∑ØÂæëÂ∑≤Âæû ${oldFilePath} Êõ¥Êñ∞ÁÇ∫ ${newFilePath}„ÄÇ`,
        fileUnloaded: (filePath: string) => `Ê™îÊ°à ${filePath} Â∑≤ÂæûË®òÊÜ∂È´îÂç∏Ëºâ„ÄÇ`,
        fileExcludedActivationDisabled: () => "ÂïüÁî®Â∑≤Á¶ÅÁî®ÔºåÊ™îÊ°àÂú®ÊéíÈô§Ê∏ÖÂñÆ‰∏≠„ÄÇ",
        fileSaveFailed: () => "‰øùÂ≠òÊ™îÊ°àÂ§±ÊïóÔºåË´ãÈáçË©¶„ÄÇ",
        cwdUpdated: (oldCwd: string, newCwd: string) => `Áï∂ÂâçÂ∑•‰ΩúÁõÆÈåÑÂ∑≤Âæû ${oldCwd} Êõ¥Êñ∞ÁÇ∫ ${newCwd}„ÄÇ`,
        cwdDoesNotExist: (cwd: string) => `Êèê‰æõÁöÑÂ∑•‰ΩúÁõÆÈåÑ ${cwd} ‰∏çÂ≠òÂú®„ÄÇ`,
        updatingEditionDate: () => "Êõ¥Êñ∞ÁâàÊú¨Êó•Êúü„ÄÇ",
        documentLineScanExceeded: (maxScanLength: number) => `ÊéÉÊèèÊ™îÊ°àÂâç ${maxScanLength} Ë°åÔºå‰ΩÜÊú™ÊâæÂà∞È†≠ÈÉ®„ÄÇ`,
        closedDocument: () => "Êñá‰ª∂Â∑≤ÈóúÈñâÔºåÂÅúÊ≠¢Êìç‰Ωú„ÄÇ",
        emptyDocument: () => "Êñá‰ª∂ÁÇ∫Á©∫ÔºåÁÑ°Ê≥ïÊìç‰Ωú„ÄÇ",
        brokenHeader: () => "Ê™¢Ê∏¨Âà∞Á†¥ÊêçÁöÑÈ†≠ÈÉ®ÔºåÊ≠£Âú®Ê≥®ÂÖ•Êñ∞ÁöÑÔºåË´ãÂà™Èô§ËàäÁöÑ„ÄÇ",
        extensionActivated: (moduleName: string) => `üöÄ Êì¥Â±ï "${moduleName}" Â∑≤ÂïüÂãïÔºÅ`,
        helloWorldGreetingsCommand: (moduleName: string) => `‰æÜËá™ ${moduleName} ÁöÑ Hello WorldÔºÅ`,
        noActiveEditor: () => "Ê≤íÊúâÊ¥ªÂãïÊ™îÊ°àÔºÅ",
        noFocusedEditors: () => "Ê≤íÊúâÁÑ¶ÈªûÊ™îÊ°à„ÄÇ",
        noLogoInstanceProvided: () => "Êú™Êèê‰æõÂæΩÊ®ôÈö®Ê©üÂØ¶‰æã„ÄÇ",
        randomLogoGatheringFailed: (error: string) => `Èö®Ê©üÂæΩÊ®ôÊî∂ÈõÜÂ§±ÊïóÔºå‰ΩøÁî®È†êË®≠ÂæΩÊ®ôÔºåÈåØË™§Ôºö${error}`,
        ramdomLogoGatheringLogoUndefined: () => "ÂæΩÊ®ôÂÖßÂÆπÊú™ÂÆöÁæ©„ÄÇ",
        openFileToApplyHeader: () => "Ë´ãÊâìÈñã‰∏ÄÂÄãÊ™îÊ°à‰ª•ÊáâÁî®È†≠ÈÉ®„ÄÇ",
        corruptedFileMetaData: () => "Ê™îÊ°àÂÖÉË≥áÊñôÊú™Ê≠£Á¢∫Êî∂ÈõÜÔºå‰∏≠Ê≠¢Êìç‰Ωú„ÄÇ",
        messageWritten: () => "Ê∂àÊÅØÂ∑≤ÂØ´ÂÖ•",
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string) => `Hello worldÔºÅÂâØÊ™îÂêçÔºö${fileExtension}ÔºåÊ™îÂêçÔºö${fileName}ÔºåË∑ØÂæëÔºö${filePath}ÔºåË™ûË®ÄÔºö${languageId}\n`,
        missingFileError: () => "Áº∫Â∞ëË™ûË®ÄÂ≠óÂÖ∏ÔºåÂõ†Ê≠§Ë©ïË´ñÈÅ©ÈÖçË¢´Á¶ÅÁî®„ÄÇ",
        unknownFileStructure: () => "Ë™ûË®ÄÂ≠óÂÖ∏ÁµêÊßãÊú™Áü•ÔºåÂõ†Ê≠§Ë©ïË´ñÈÅ©ÈÖçË¢´Á¶ÅÁî®„ÄÇ",
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]) => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}„ÄÇ`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string) =>
            `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        identifiedLanguage: (langName: string) => `Ë≠òÂà•ÁöÑË™ûË®ÄÔºö${langName}„ÄÇ`,
        errorDuringFunctionCall: (functionName: string) => `ÂëºÂè´ÂáΩÊï∏ (${functionName}) ÊôÇÁôºÁîüÈåØË™§ÔºåË´ãÊü•ÁúãÊó•Ë™å„ÄÇ`,
        missingLanguageComment: () => "Êú™Êèê‰æõË™ûË®ÄË®ªËß£ÔºåË∑≥ÈÅéÂàÜÈÖç„ÄÇ",
        getHeaderDescription: () => "Ë´ãÊèê‰æõÊèèËø∞Ôºö",
        getHeaderTags: () => "Ë´ãËº∏ÂÖ•Ê™îÊ°àÊ®ôÁ±§ÔºåÁî®ÈÄóËôüÂàÜÈöîÔºö",
        getHeaderPurpose: () => "Ë´ãÊèê‰æõÊ™îÊ°àÁî®ÈÄîÔºö",
        noProvidedCommentOptions: () => "Êú™Êèê‰æõË®ªËß£ÈÅ∏È†Ö„ÄÇ",
        chooseSingleLineCommentOption: () => "Ë´ãÂæû‰∏ãÂàóÈÅ∏È†Ö‰∏≠ÈÅ∏ÊìáÈ¶ñÈÅ∏Ë®ªËß£ÂâçÁ∂¥Ôºö",
        toMorseGetInput: (): string => "Ë´ãËº∏ÂÖ•Ë¶ÅËΩâÊèõÁöÑÊñáÂ≠ó",
        fromMorseGetInput: (): string => "Ë´ãËº∏ÂÖ•Ë¶ÅÂæû‰∏≠ËΩâÊèõÁöÑÊñáÂ≠ó",
        operationCanceled: (): string => "Êìç‰ΩúÂ∑≤ÂèñÊ∂à",
        convertedContentCli: (content: string): string => `ËΩâÊèõÂæåÁöÑÂÖßÂÆπ: ${content}`,
        convertedContentGui: (): string => "ËΩâÊèõÂæåÁöÑÂÖßÂÆπ: ",
        updateAbortedBecauseFileClosedSyncCancelled: () => "Êõ¥Êñ∞‰∏≠Ê≠¢ÔºåÂõ†ÁÇ∫Ê™îÊ°àÂ∑≤ÈóúÈñâ‰∏î‰∏çÊúÉÂêåÊ≠•„ÄÇ",
        updateEditDateMissingBounds: () => "ÁÑ°Ê≥ïÊõ¥Êñ∞È†≠ÈÉ®ÔºöÊú™ÊâæÂà∞ÂÖßÈÉ®Ê®ôË®ò„ÄÇ",
        lastModifiedLineNotFound: () => "È†≠ÈÉ®‰∏≠Êú™ÊâæÂà∞‚ÄúÊúÄÂæå‰øÆÊîπ‚ÄùË°å‰ª•Êõ¥Êñ∞„ÄÇ",
        lastModifiedUpdated: () => "‚ÄúÊúÄÂæå‰øÆÊîπ‚ÄùÊó•ÊúüÂ∑≤ÊàêÂäüÊõ¥Êñ∞„ÄÇ",
        languageNotFound: (LanguageId: string, fileExtension: string) => `ÁÑ°Ê≥ïË≠òÂà•Ê™îÊ°àË™ûË®ÄÔºålanguageID: ${LanguageId}ÔºåÂâØÊ™îÂêçÔºö${fileExtension}`,
        jsonContent: (jsonContentString: String) => `Ë®ªËß£ JSON Ê™îÊ°àÂÖßÂÆπÔºö${jsonContentString}`,
        messageNotFound: (key: string) => `Êú™ÊâæÂà∞Ê∂àÊÅØ '${key}'„ÄÇ`
    },
    "de": {
        inputboxError: (promptText: string, err: string) => `Fehler im Eingabefeld f√ºr ${promptText}: ${err}`,
        quickPickError: (err: string) => `Fehler in QuickPick: ${err}`,
        quickPickYes: () => "Ja",
        quickPickNo: () => "Nein",
        watermarkView: () => "Wasserzeichen-Ansicht",
        watermarkJsonFileInvalid: () => "Wasserzeichen JSON-Datei ist leer oder ung√ºltig",
        watermarkName: () => "Wasserzeichenname",
        watermarkCopyAscii: () => "ASCII kopieren",
        watermarkZoomIn: () => "Vergr√∂√üern",
        watermarkZoomOut: () => "Verkleinern",
        watermarkPersonDisplayed: (name: string) => `Wasserzeichen '${name}' angezeigt.`,
        watermarkChosen: (watermark: string[]) => `Anzuzeigendes Wasserzeichen: ${JSON.stringify(watermark)}`,
        watermarkNotFound: () => "Wasserzeichen nicht gefunden",
        watermarkCopied: (name: string) => `ASCII-Kunst f√ºr ${name} kopiert!`,
        watermarkAuthorName: () => "Autor",
        darlingView: () => "Charakter-Ansicht",
        darlingJsonFileInvalid: () => "Darling JSON-Datei ist leer oder ung√ºltig",
        darlingPersonDisplayed: (name: string) => `Charakter '${name}' angezeigt.`,
        darlingCopyAscii: () => "ASCII kopieren",
        darlingZoomIn: () => "Vergr√∂√üern",
        darlingZoomOut: () => "Verkleinern",
        darlingType: () => "Typ",
        darlingAge: () => "Alter",
        darlingHeight: () => "Gr√∂√üe",
        darlingAlias: () => "Alias",
        darlingDescription: () => "Beschreibung",
        darlingQuote: () => "Zitat",
        darlingMoreInfo: () => "Weitere Infos",
        darlingImage: () => "Bild",
        darlingCopied: (name: string) => `ASCII-Kunst f√ºr ${name} kopiert!`,
        logoView: () => "Logo-Ansicht",
        logoName: () => "Logoname",
        logoMessage: (logoPath: string) => `Datei (${logoPath}) ignoriert, da sie nicht vom gesuchten Typ ist.`,
        logoNoRootDir: () => "Kein Stammverzeichnis zur Sammlung von Logos angegeben",
        logoRootDirUpdateError: (error: string) => `Fehler beim Aktualisieren der Logodateien, Fehler: ${error}`,
        logoDisplayed: (name: string) => `Logo '${name}' angezeigt.`,
        logoCopied: (logoName: string) => `ASCII-Kunst f√ºr ${logoName} kopiert!`,
        logoChosen: (logo: string[]) => `Anzuzeigendes Logo: ${JSON.stringify(logo)}`,
        logoNotFound: () => "Logo nicht gefunden",
        logoCopyAscii: () => "ASCII kopieren",
        logoZoomIn: () => "Vergr√∂√üern",
        logoZoomOut: () => "Verkleinern",
        noCommentToShow: () => "Kein Kommentar zum Anzeigen.",
        unknown: () => "Unbekannt",
        headerOpenerFound: () => "Header-Start gefunden.",
        headerOpenerAndCloserFound: () => "Header-Start und -Ende gefunden, aktualisiere das Datum nach √úberpr√ºfung.",
        headerWriteFailed: () => "Header konnte nicht in die Datei geschrieben werden, pr√ºfen Sie die Logs.",
        headerWriteSuccess: () => "Header erfolgreich geschrieben.",
        headerNotFound: () => "Kein Header in diesem Dokument gefunden.",
        headerInjectQuestion: () => "Kein Header gefunden. M√∂chten Sie einen hinzuf√ºgen?",
        headerInjectQuestionRefused: () => "Sie haben entschieden, keinen Header hinzuzuf√ºgen.",
        morseConverted: (input: string, final: string) => `Konvertiert: ${input} -> ${final}`,
        morseDecoded: (input: string, final: string) => `Dekodiert: ${input} -> ${final}`,
        fileLoaded: (absolutePath: string) => `Datei ${absolutePath} geladen!`,
        fileParseError: (filePath: string, error: string) => `Dateiinhalt (${filePath}) konnte nicht erfolgreich geladen werden. Fehler: ${error}.`,
        fileRefreshed: () => "Dateiinhalt wird aktualisiert.",
        filePathUpdated: (oldFilePath: string, newFilePath: string) => `Pfad wurde von ${oldFilePath} auf ${newFilePath} aktualisiert.`,
        fileUnloaded: (filePath: string) => `Datei ${filePath} aus dem Speicher entfernt.`,
        fileExcludedActivationDisabled: () => "Aktivierung deaktiviert, Datei ist auf der Ausschlussliste.",
        fileSaveFailed: () => "Datei konnte nicht gespeichert werden, bitte erneut versuchen.",
        cwdUpdated: (oldCwd: string, newCwd: string) => `Das aktuelle Arbeitsverzeichnis wurde von ${oldCwd} auf ${newCwd} aktualisiert.`,
        cwdDoesNotExist: (cwd: string) => `Das angegebene Arbeitsverzeichnis ${cwd} existiert nicht.`,
        updatingEditionDate: () => "Aktualisiere das Erstellungsdatum.",
        documentLineScanExceeded: (maxScanLength: number) => `Erste ${maxScanLength} Zeilen der Datei gescannt, kein Header gefunden.`,
        closedDocument: () => "Das Dokument ist geschlossen, Operationen gestoppt.",
        emptyDocument: () => "Kein Dokument vorhanden.",
        brokenHeader: () => "Besch√§digter Header erkannt, f√ºge neuen Header ein, bitte vorherigen entfernen.",
        extensionActivated: (moduleName: string) => `üöÄ Erweiterung "${moduleName}" ist jetzt aktiv!`,
        helloWorldGreetingsCommand: (moduleName: string) => `Hello World von ${moduleName}!`,
        noActiveEditor: () => "Keine aktive Datei!",
        noFocusedEditors: () => "Keine fokussierten Dateien.",
        noLogoInstanceProvided: () => "Keine Logo-Randomizer-Instanz bereitgestellt.",
        randomLogoGatheringFailed: (error: string) => `Zuf√§lliges Logo konnte nicht geladen werden, Standardlogo wird verwendet, Fehler: "${error}"`,
        ramdomLogoGatheringLogoUndefined: () => "Logo-Inhalt ist undefiniert.",
        openFileToApplyHeader: () => "Bitte √∂ffnen Sie eine Datei, um den Header anzuwenden.",
        corruptedFileMetaData: () => "Datei-Metadaten wurden nicht korrekt gesammelt, Abbruch.",
        messageWritten: () => "Nachricht geschrieben",
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string) => `Hello World! Dateiendung: ${fileExtension}, Name: ${fileName}, Pfad: ${filePath}, Sprache: ${languageId}\n`,
        missingFileError: () => "Sprachw√∂rterbuch fehlt, Kommentar-Anpassung deaktiviert.",
        unknownFileStructure: () => "Sprachw√∂rterbuchstruktur unbekannt, Kommentar-Anpassung deaktiviert.",
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]) => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}.`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string) =>
            `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        identifiedLanguage: (langName: string) => `Identifizierte Sprache: ${langName}.`,
        errorDuringFunctionCall: (functionName: string) => `Fehler beim Aufruf der Funktion (${functionName}), pr√ºfen Sie die Logs.`,
        missingLanguageComment: () => "Sprachkommentar nicht bereitgestellt, Zuweisung √ºbersprungen.",
        getHeaderDescription: () => "Bitte Beschreibung angeben:",
        getHeaderTags: () => "Bitte Tags f√ºr diese Datei eingeben, durch Kommas getrennt:",
        getHeaderPurpose: () => "Bitte Zweck der Datei angeben:",
        noProvidedCommentOptions: () => "Keine Kommentaroptionen bereitgestellt.",
        chooseSingleLineCommentOption: () => "Bitte bevorzugten Kommentarpr√§fix aus den Optionen unten ausw√§hlen:",
        toMorseGetInput: (): string => "Bitte geben Sie den zu konvertierenden Text ein",
        fromMorseGetInput: (): string => "Bitte geben Sie den Text ein, der konvertiert werden soll",
        operationCanceled: (): string => "Vorgang abgebrochen",
        convertedContentCli: (content: string): string => `Konvertierter Inhalt: ${content}`,
        convertedContentGui: (): string => "Konvertierter Inhalt: ",
        updateAbortedBecauseFileClosedSyncCancelled: () => "Update abgebrochen, da die Datei geschlossen ist und nicht synchronisiert wird.",
        updateEditDateMissingBounds: () => "Header konnte nicht aktualisiert werden: interne Marker nicht gefunden.",
        lastModifiedLineNotFound: () => "Header enth√§lt keine 'Zuletzt ge√§ndert'-Zeile zum Aktualisieren.",
        lastModifiedUpdated: () => "'Zuletzt ge√§ndert'-Datum erfolgreich aktualisiert.",
        languageNotFound: (LanguageId: string, fileExtension: string) => `Dateisprache konnte nicht erkannt werden, languageID: ${LanguageId}, Dateierweiterung: ${fileExtension}`,
        jsonContent: (jsonContentString: String) => `Inhalt der Kommentar-JSON-Datei: ${jsonContentString}`,
        messageNotFound: (key: string) => `Nachricht '${key}' nicht gefunden.`
    },
    "ja": {
        inputboxError: (promptText: string, err: string) => `${promptText} „ÅÆÂÖ•Âäõ„Éú„ÉÉ„ÇØ„Çπ„Åß„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü: ${err}`,
        quickPickError: (err: string) => `QuickPick „Åß„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü: ${err}`,
        quickPickYes: () => "„ÅØ„ÅÑ",
        quickPickNo: () => "„ÅÑ„ÅÑ„Åà",
        watermarkView: () => "„Ç¶„Ç©„Éº„Çø„Éº„Éû„Éº„ÇØ„Éì„É•„Éº",
        watermarkJsonFileInvalid: () => "„Ç¶„Ç©„Éº„Çø„Éº„Éû„Éº„ÇØ JSON „Éï„Ç°„Ç§„É´„ÅåÁ©∫„Åæ„Åü„ÅØÁÑ°Âäπ„Åß„Åô",
        watermarkName: () => "„Ç¶„Ç©„Éº„Çø„Éº„Éû„Éº„ÇØÂêç",
        watermarkCopyAscii: () => "ASCII „Çí„Ç≥„Éî„Éº",
        watermarkZoomIn: () => "„Ç∫„Éº„É†„Ç§„É≥",
        watermarkZoomOut: () => "„Ç∫„Éº„É†„Ç¢„Ç¶„Éà",
        watermarkPersonDisplayed: (name: string) => `„Ç¶„Ç©„Éº„Çø„Éº„Éû„Éº„ÇØ '${name}' „ÇíË°®Á§∫„Åó„Åæ„Åó„Åü„ÄÇ`,
        watermarkChosen: (watermark: string[]) => `Ë°®Á§∫„Åô„Çã„Ç¶„Ç©„Éº„Çø„Éº„Éû„Éº„ÇØ: ${JSON.stringify(watermark)}`,
        watermarkNotFound: () => "„Ç¶„Ç©„Éº„Çø„Éº„Éû„Éº„ÇØ„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì",
        watermarkCopied: (name: string) => `${name} „ÅÆ ASCII „Ç¢„Éº„Éà„Çí„Ç≥„Éî„Éº„Åó„Åæ„Åó„ÅüÔºÅ`,
        watermarkAuthorName: () => "‰ΩúÊàêËÄÖÂêç",
        darlingView: () => "„Ç≠„É£„É©„ÇØ„Çø„Éº„Éì„É•„Éº",
        darlingJsonFileInvalid: () => "Darling JSON „Éï„Ç°„Ç§„É´„ÅåÁ©∫„Åæ„Åü„ÅØÁÑ°Âäπ„Åß„Åô",
        darlingPersonDisplayed: (name: string) => `„Ç≠„É£„É©„ÇØ„Çø„Éº '${name}' „ÇíË°®Á§∫„Åó„Åæ„Åó„Åü„ÄÇ`,
        darlingCopyAscii: () => "ASCII „Çí„Ç≥„Éî„Éº",
        darlingZoomIn: () => "„Ç∫„Éº„É†„Ç§„É≥",
        darlingZoomOut: () => "„Ç∫„Éº„É†„Ç¢„Ç¶„Éà",
        darlingType: () => "„Çø„Ç§„Éó",
        darlingAge: () => "Âπ¥ÈΩ¢",
        darlingHeight: () => "Ë∫´Èï∑",
        darlingAlias: () => "Âà•Âêç",
        darlingDescription: () => "Ë™¨Êòé",
        darlingQuote: () => "ÂºïÁî®",
        darlingMoreInfo: () => "Ë©≥Á¥∞ÊÉÖÂ†±",
        darlingImage: () => "ÁîªÂÉè",
        darlingCopied: (name: string) => `${name} „ÅÆ ASCII „Ç¢„Éº„Éà„Çí„Ç≥„Éî„Éº„Åó„Åæ„Åó„ÅüÔºÅ`,
        logoView: () => "„É≠„Ç¥„Éì„É•„Éº",
        logoName: () => "„É≠„Ç¥Âêç",
        logoMessage: (logoPath: string) => `„Éï„Ç°„Ç§„É´ (${logoPath}) „ÅØÂØæË±°„Çø„Ç§„Éó„Åß„ÅØ„Å™„ÅÑ„Åü„ÇÅÁÑ°Ë¶ñ„Åï„Çå„Åæ„Åó„Åü„ÄÇ`,
        logoNoRootDir: () => "„É≠„Ç¥„ÇíÂèéÈõÜ„Åô„Çã„Åü„ÇÅ„ÅÆ„É´„Éº„Éà„Éá„Ç£„É¨„ÇØ„Éà„É™„ÅåÊèê‰æõ„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì",
        logoRootDirUpdateError: (error: string) => `„É≠„Ç¥„Éï„Ç°„Ç§„É´„ÅÆÊõ¥Êñ∞‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü: ${error}`,
        logoDisplayed: (name: string) => `„É≠„Ç¥ '${name}' „ÇíË°®Á§∫„Åó„Åæ„Åó„Åü„ÄÇ`,
        logoCopied: (logoName: string) => `${logoName} „ÅÆ ASCII „Ç¢„Éº„Éà„Çí„Ç≥„Éî„Éº„Åó„Åæ„Åó„ÅüÔºÅ`,
        logoChosen: (logo: string[]) => `Ë°®Á§∫„Åô„Çã„É≠„Ç¥: ${JSON.stringify(logo)}`,
        logoNotFound: () => "„É≠„Ç¥„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì",
        logoCopyAscii: () => "ASCII „Çí„Ç≥„Éî„Éº",
        noCommentToShow: () => "Ë°®Á§∫„Åô„Çã„Ç≥„É°„É≥„Éà„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ",
        unknown: () => "‰∏çÊòé",
        headerOpenerFound: () => "„Éò„ÉÉ„ÉÄ„Éº„ÅÆÈñãÂßã„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åó„Åü„ÄÇ",
        headerOpenerAndCloserFound: () => "„Éò„ÉÉ„ÉÄ„Éº„ÅÆÈñãÂßã„Å®ÁµÇ‰∫Ü„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åó„Åü„ÄÇ„ÉÅ„Çß„ÉÉ„ÇØÂæå„ÄÅÊó•‰ªò„ÇíÊõ¥Êñ∞„Åó„Åæ„Åô„ÄÇ",
        headerWriteFailed: () => "„Éï„Ç°„Ç§„É´„Å´„Éò„ÉÉ„ÉÄ„Éº„ÇíÊõ∏„ÅçËæº„ÇÅ„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ„É≠„Ç∞„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ",
        headerWriteSuccess: () => "„Éò„ÉÉ„ÉÄ„Éº„ÇíÊõ∏„ÅçËæº„Åø„Åæ„Åó„Åü„ÄÇ",
        headerNotFound: () => "„Åì„ÅÆ„Éâ„Ç≠„É•„É°„É≥„Éà„Å´„Éò„ÉÉ„ÉÄ„Éº„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇ",
        headerInjectQuestion: () => "„Åì„ÅÆ„Éâ„Ç≠„É•„É°„É≥„Éà„Å´„Éò„ÉÉ„ÉÄ„Éº„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇËøΩÂä†„Åó„Åæ„Åô„ÅãÔºü",
        headerInjectQuestionRefused: () => "„Éï„Ç°„Ç§„É´„Å´„Éò„ÉÉ„ÉÄ„Éº„ÇíËøΩÂä†„Åó„Å™„ÅÑ„Åì„Å®„Å´„Åó„Åæ„Åó„Åü„ÄÇ",
        morseConverted: (input: string, final: string) => `Â§âÊèõ: ${input} ‚Üí ${final}`,
        morseDecoded: (input: string, final: string) => `Âæ©Âè∑: ${input} ‚Üí ${final}`,
        fileLoaded: (absolutePath: string) => `„Éï„Ç°„Ç§„É´ ${absolutePath} „ÇíË™≠„ÅøËæº„Åø„Åæ„Åó„ÅüÔºÅ`,
        fileParseError: (filePath: string, error: string) => `„Éï„Ç°„Ç§„É´„ÅÆÂÜÖÂÆπ (${filePath}) „ÇíÊ≠£Â∏∏„Å´Ë™≠„ÅøËæº„ÇÅ„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ„Ç®„É©„Éº: ${error}„ÄÇ`,
        fileRefreshed: () => "„Éï„Ç°„Ç§„É´ÂÜÖÂÆπ„ÇíÊõ¥Êñ∞„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ",
        filePathUpdated: (oldFilePath: string, newFilePath: string) => `„Éë„Çπ„Çí ${oldFilePath} „Åã„Çâ ${newFilePath} „Å´Êõ¥Êñ∞„Åó„Åæ„Åó„Åü„ÄÇ`,
        fileUnloaded: (filePath: string) => `„Éï„Ç°„Ç§„É´ ${filePath} „Çí„É°„É¢„É™„Åã„Çâ„Ç¢„É≥„É≠„Éº„Éâ„Åó„Åæ„Åó„Åü„ÄÇ`,
        fileExcludedActivationDisabled: () => "„Ç¢„ÇØ„ÉÜ„Ç£„Éô„Éº„Ç∑„Éß„É≥„ÅØÁÑ°Âäπ„Åß„Åô„ÄÇ„Éï„Ç°„Ç§„É´„ÅØÈô§Â§ñ„É™„Çπ„Éà„Å´„ÅÇ„Çä„Åæ„Åô„ÄÇ",
        fileSaveFailed: () => "„Éï„Ç°„Ç§„É´„ÅÆ‰øùÂ≠ò„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ„ÇÇ„ÅÜ‰∏ÄÂ∫¶‰øùÂ≠ò„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ",
        cwdUpdated: (oldCwd: string, newCwd: string) => `ÁèæÂú®„ÅÆ‰ΩúÊ•≠„Éá„Ç£„É¨„ÇØ„Éà„É™„Çí ${oldCwd} „Åã„Çâ ${newCwd} „Å´Êõ¥Êñ∞„Åó„Åæ„Åó„Åü„ÄÇ`,
        cwdDoesNotExist: (cwd: string) => `ÊåáÂÆö„Åï„Çå„Åü‰ΩúÊ•≠„Éá„Ç£„É¨„ÇØ„Éà„É™ ${cwd} „ÅØÂ≠òÂú®„Åó„Åæ„Åõ„Çì„ÄÇ`,
        updatingEditionDate: () => "Á∑®ÈõÜÊó•„ÇíÊõ¥Êñ∞„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ",
        documentLineScanExceeded: (maxScanLength: number) => `„Éï„Ç°„Ç§„É´„ÅÆÊúÄÂàù„ÅÆ ${maxScanLength} Ë°å„Çí„Çπ„Ç≠„É£„É≥„Åó„Åæ„Åó„Åü„Åå„ÄÅ„Éò„ÉÉ„ÉÄ„Éº„ÅØË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ`,
        closedDocument: () => "„Éâ„Ç≠„É•„É°„É≥„Éà„ÅØÈñâ„Åò„Çâ„Çå„Åæ„Åó„Åü„ÄÇÊìç‰Ωú„ÇíÂÅúÊ≠¢„Åó„Åæ„Åô„ÄÇ",
        emptyDocument: () => "„Éâ„Ç≠„É•„É°„É≥„Éà„ÅÆÊú¨Êñá„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ",
        brokenHeader: () => "Â£ä„Çå„Åü„Éò„ÉÉ„ÉÄ„Éº„ÅåÊ§úÂá∫„Åï„Çå„Åæ„Åó„Åü„ÄÇÊñ∞„Åó„ÅÑ„Éò„ÉÉ„ÉÄ„Éº„ÇíÊåøÂÖ•„Åó„Åæ„Åô„ÄÇÂâç„ÅÆ„ÇÇ„ÅÆ„ÇíÂâäÈô§„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ",
        extensionActivated: (moduleName: string) => `üöÄ "${moduleName}" Êã°ÂºµÊ©üËÉΩ„Åå„Ç¢„ÇØ„ÉÜ„Ç£„Éñ„Å´„Å™„Çä„Åæ„Åó„ÅüÔºÅ`,
        helloWorldGreetingsCommand: (moduleName: string) => `Hello World from ${moduleName}ÔºÅ`,
        noActiveEditor: () => "„Ç¢„ÇØ„ÉÜ„Ç£„Éñ„Å™„Éï„Ç°„Ç§„É´„Åå„ÅÇ„Çä„Åæ„Åõ„ÇìÔºÅ",
        noFocusedEditors: () => "„Éï„Ç©„Éº„Ç´„Çπ„Åï„Çå„Å¶„ÅÑ„Çã„Éï„Ç°„Ç§„É´„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ",
        noLogoInstanceProvided: () => "Êèê‰æõ„Åï„Çå„Åü„É≠„Ç¥„É©„É≥„ÉÄ„Éû„Ç§„Ç∂„Éº„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ",
        randomLogoGatheringFailed: (error: string) => `„É©„É≥„ÉÄ„É†„É≠„Ç¥„ÅÆÂèéÈõÜ„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ„Éá„Éï„Ç©„É´„Éà„É≠„Ç¥„Çí‰ΩøÁî®„Åó„Åæ„Åô„ÄÇ„Ç®„É©„Éº: "${error}"`,
        ramdomLogoGatheringLogoUndefined: () => "„É≠„Ç¥„ÅÆÂÜÖÂÆπ„ÅåÊú™ÂÆöÁæ©„Åß„Åô„ÄÇ",
        openFileToApplyHeader: () => "„Éò„ÉÉ„ÉÄ„Éº„ÇíÈÅ©Áî®„Åô„Çã„Éï„Ç°„Ç§„É´„ÇíÈñã„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ",
        corruptedFileMetaData: () => "ÂøÖË¶Å„Å™„Éï„Ç°„Ç§„É´„É°„Çø„Éá„Éº„Çø„ÅåÊ≠£„Åó„ÅèÂèéÈõÜ„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ‰∏≠Ê≠¢„Åó„Åæ„Åô„ÄÇ",
        messageWritten: () => "„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÊõ∏„ÅçËæº„Åø„Åæ„Åó„Åü",
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string) =>
            `Hello World! „Éï„Ç°„Ç§„É´„ÅÆÊã°ÂºµÂ≠ê: ${fileExtension}, ÂêçÂâç: ${fileName}, „Éë„Çπ: ${filePath}, Ë®ÄË™û: ${languageId}\n`,
        missingFileError: () => "Ë®ÄË™ûËæûÊõ∏„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ„Ç≥„É°„É≥„Éà„ÅÆÈÅ©ÂøúÊÄß„ÅØÁÑ°Âäπ„Åß„Åô„ÄÇ",
        unknownFileStructure: () => "Ë®ÄË™ûËæûÊõ∏„ÅÆÊßãÈÄ†„Åå‰∏çÊòé„Åß„Åô„ÄÇ„Ç≥„É°„É≥„Éà„ÅÆÈÅ©ÂøúÊÄß„ÅØÁÑ°Âäπ„Åß„Åô„ÄÇ",
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]) =>
            `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}„ÄÇ`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string) =>
            `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        identifiedLanguage: (langName: string) => `Ë≠òÂà•„Åï„Çå„ÅüË®ÄË™û: ${langName}„ÄÇ`,
        errorDuringFunctionCall: (functionName: string) => `Èñ¢Êï∞ (${functionName}) „ÅÆÂëº„Å≥Âá∫„Åó‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ„É≠„Ç∞„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ`,
        missingLanguageComment: () => "Ë®ÄË™û„Ç≥„É°„É≥„Éà„ÅåÊèê‰æõ„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇÂâ≤„ÇäÂΩì„Å¶„Çí„Çπ„Ç≠„ÉÉ„Éó„Åó„Åæ„Åô„ÄÇ",
        getHeaderDescription: () => "Ë™¨Êòé„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ: ",
        getHeaderTags: () => "„Åì„ÅÆ„Éï„Ç°„Ç§„É´„ÅÆ„Çø„Ç∞„Çí„Ç´„É≥„Éû„ÅßÂå∫Âàá„Å£„Å¶ÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ: ",
        getHeaderPurpose: () => "„Éï„Ç°„Ç§„É´„ÅÆÁõÆÁöÑ„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ: ",
        noProvidedCommentOptions: () => "Êèê‰æõ„Åï„Çå„Åü„Ç≥„É°„É≥„Éà„Ç™„Éó„Ç∑„Éß„É≥„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ",
        chooseSingleLineCommentOption: () => "‰ª•‰∏ã„ÅÆ„Ç™„Éó„Ç∑„Éß„É≥„Åã„Çâ„Ç≥„É°„É≥„Éà„ÅÆ„Éó„É¨„Éï„Ç£„ÉÉ„ÇØ„Çπ„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ: ",
        toMorseGetInput: (): string => "Â§âÊèõ„Åô„Çã„ÉÜ„Ç≠„Çπ„Éà„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ",
        fromMorseGetInput: (): string => "Â§âÊèõÂÖÉ„ÅÆ„ÉÜ„Ç≠„Çπ„Éà„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ",
        operationCanceled: (): string => "Êìç‰Ωú„Åå„Ç≠„É£„É≥„Çª„É´„Åï„Çå„Åæ„Åó„Åü",
        convertedContentCli: (content: string): string => `Â§âÊèõ„Åï„Çå„ÅüÂÜÖÂÆπ: ${content}`,
        convertedContentGui: (): string => "Â§âÊèõ„Åï„Çå„ÅüÂÜÖÂÆπ: ",
        updateAbortedBecauseFileClosedSyncCancelled: () => "„Éï„Ç°„Ç§„É´„ÅåÈñâ„Åò„Çâ„Çå„Å¶„ÅÑ„Çã„Åü„ÇÅ„ÄÅÊõ¥Êñ∞„ÅØ‰∏≠Ê≠¢„Åï„ÇåÂêåÊúü„Åï„Çå„Åæ„Åõ„Çì„ÄÇ",
        updateEditDateMissingBounds: () => "„Éò„ÉÉ„ÉÄ„Éº„ÇíÊõ¥Êñ∞„Åß„Åç„Åæ„Åõ„Çì: ÂÜÖÈÉ®„Éû„Éº„Ç´„Éº„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇ",
        lastModifiedLineNotFound: () => "„Éò„ÉÉ„ÉÄ„Éº„Å´„ÄåÊúÄÁµÇÊõ¥Êñ∞Êó•„ÄçË°å„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ",
        lastModifiedUpdated: () => "„ÄåÊúÄÁµÇÊõ¥Êñ∞Êó•„Äç„ÅåÊ≠£Â∏∏„Å´Êõ¥Êñ∞„Åï„Çå„Åæ„Åó„Åü„ÄÇ",
        languageNotFound: (LanguageId: string, fileExtension: string) =>
            `„Åì„ÅÆ„Éâ„Ç≠„É•„É°„É≥„Éà„ÅÆ„Éï„Ç°„Ç§„É´Ë®ÄË™û„ÇíË≠òÂà•„Åß„Åç„Åæ„Åõ„Çì„ÄÇlanguageID: ${LanguageId}, „Éï„Ç°„Ç§„É´Êã°ÂºµÂ≠ê: ${fileExtension}`,
        jsonContent: (jsonContentString: String) => `„Ç≥„É°„É≥„Éà JSON „Éï„Ç°„Ç§„É´„ÅÆÂÜÖÂÆπ: ${jsonContentString}`,
        messageNotFound: (key: string) => `„É°„ÉÉ„Çª„Éº„Ç∏ '${key}' „ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇ`
    },
    "ko": {
        inputboxError: (promptText: string, err: string) => `${promptText} ÏûÖÎ†• ÏÉÅÏûêÏóêÏÑú Ïò§Î•ò Î∞úÏÉù: ${err}`,
        quickPickError: (err: string) => `QuickPickÏóêÏÑú Ïò§Î•ò Î∞úÏÉù: ${err}`,
        quickPickYes: () => "Ïòà",
        quickPickNo: () => "ÏïÑÎãàÏò§",
        watermarkView: () => "ÏõåÌÑ∞ÎßàÌÅ¨ Î∑∞",
        watermarkJsonFileInvalid: () => "ÏõåÌÑ∞ÎßàÌÅ¨ JSON ÌååÏùºÏù¥ ÎπÑÏñ¥ ÏûàÍ±∞ÎÇò Ïú†Ìö®ÌïòÏßÄ ÏïäÏäµÎãàÎã§",
        watermarkName: () => "ÏõåÌÑ∞ÎßàÌÅ¨ Ïù¥Î¶Ñ",
        watermarkCopyAscii: () => "ASCII Î≥µÏÇ¨",
        watermarkZoomIn: () => "ÌôïÎåÄ",
        watermarkZoomOut: () => "Ï∂ïÏÜå",
        watermarkPersonDisplayed: (name: string) => `ÏõåÌÑ∞ÎßàÌÅ¨ '${name}' ÌëúÏãúÎê®.`,
        watermarkChosen: (watermark: string[]) => `ÌëúÏãúÌï† ÏõåÌÑ∞ÎßàÌÅ¨: ${JSON.stringify(watermark)}`,
        watermarkNotFound: () => "ÏõåÌÑ∞ÎßàÌÅ¨Î•º Ï∞æÏùÑ Ïàò ÏóÜÏùå",
        watermarkCopied: (name: string) => `${name}Ïùò ASCII ÏïÑÌä∏Í∞Ä Î≥µÏÇ¨ÎêòÏóàÏäµÎãàÎã§!`,
        watermarkAuthorName: () => "ÏûëÏÑ±Ïûê Ïù¥Î¶Ñ",
        darlingView: () => "Ï∫êÎ¶≠ÌÑ∞ Î∑∞",
        darlingJsonFileInvalid: () => "Darling JSON ÌååÏùºÏù¥ ÎπÑÏñ¥ ÏûàÍ±∞ÎÇò Ïú†Ìö®ÌïòÏßÄ ÏïäÏäµÎãàÎã§",
        darlingPersonDisplayed: (name: string) => `Ï∫êÎ¶≠ÌÑ∞ '${name}' ÌëúÏãúÎê®.`,
        darlingCopyAscii: () => "ASCII Î≥µÏÇ¨",
        darlingZoomIn: () => "ÌôïÎåÄ",
        darlingZoomOut: () => "Ï∂ïÏÜå",
        darlingType: () => "Ïú†Ìòï",
        darlingAge: () => "ÎÇòÏù¥",
        darlingHeight: () => "ÌÇ§",
        darlingAlias: () => "Î≥ÑÎ™Ö",
        darlingDescription: () => "ÏÑ§Î™Ö",
        darlingQuote: () => "Ïù∏Ïö©Íµ¨",
        darlingMoreInfo: () => "Ï∂îÍ∞Ä Ï†ïÎ≥¥",
        darlingImage: () => "Ïù¥ÎØ∏ÏßÄ",
        darlingCopied: (name: string) => `${name}Ïùò ASCII ÏïÑÌä∏Í∞Ä Î≥µÏÇ¨ÎêòÏóàÏäµÎãàÎã§!`,
        logoView: () => "Î°úÍ≥† Î∑∞",
        logoName: () => "Î°úÍ≥† Ïù¥Î¶Ñ",
        logoMessage: (logoPath: string) => `ÌååÏùº (${logoPath})ÏùÄ(Îäî) ÏõêÌïòÎäî Ïú†ÌòïÏù¥ ÏïÑÎãàÎØÄÎ°ú Î¨¥ÏãúÎê©ÎãàÎã§.`,
        logoNoRootDir: () => "Î°úÍ≥†Î•º ÏàòÏßëÌï† Î£®Ìä∏ ÎîîÎ†âÌÑ∞Î¶¨Í∞Ä Ï†úÍ≥µÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§",
        logoRootDirUpdateError: (error: string) => `Î°úÍ≥† ÌååÏùº ÏóÖÎç∞Ïù¥Ìä∏ Ï§ë Ïò§Î•ò Î∞úÏÉù: ${error}`,
        logoDisplayed: (name: string) => `Î°úÍ≥† '${name}' ÌëúÏãúÎê®.`,
        logoCopied: (logoName: string) => `${logoName}Ïùò ASCII ÏïÑÌä∏Í∞Ä Î≥µÏÇ¨ÎêòÏóàÏäµÎãàÎã§!`,
        logoChosen: (logo: string[]) => `ÌëúÏãúÌï† Î°úÍ≥†: ${JSON.stringify(logo)}`,
        logoNotFound: () => "Î°úÍ≥†Î•º Ï∞æÏùÑ Ïàò ÏóÜÏùå",
        logoCopyAscii: () => "ASCII Î≥µÏÇ¨",
        noCommentToShow: () => "ÌëúÏãúÌï† Ï£ºÏÑùÏù¥ ÏóÜÏäµÎãàÎã§.",
        unknown: () => "Ïïå Ïàò ÏóÜÏùå",
        headerOpenerFound: () => "Ìó§Îçî ÏãúÏûë Î∞úÍ≤¨.",
        headerOpenerAndCloserFound: () => "Ìó§Îçî ÏãúÏûë Î∞è Ï¢ÖÎ£å Î∞úÍ≤¨, Í≤ÄÏÇ¨ ÌõÑ ÎÇ†ÏßúÎ•º ÏóÖÎç∞Ïù¥Ìä∏Ìï©ÎãàÎã§.",
        headerWriteFailed: () => "ÌååÏùºÏóê Ìó§ÎçîÎ•º Ïì∏ Ïàò ÏóÜÏäµÎãàÎã§. Î°úÍ∑∏Î•º ÌôïÏù∏ÌïòÏÑ∏Ïöî.",
        headerWriteSuccess: () => "Ìó§ÎçîÍ∞Ä ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÏûëÏÑ±ÎêòÏóàÏäµÎãàÎã§.",
        headerNotFound: () => "Ïù¥ Î¨∏ÏÑúÏóêÏÑú Ìó§ÎçîÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.",
        headerInjectQuestion: () => "Ïù¥ Î¨∏ÏÑúÏóêÏÑú Ìó§ÎçîÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§. Ï∂îÍ∞ÄÌïòÏãúÍ≤†ÏäµÎãàÍπå?",
        headerInjectQuestionRefused: () => "ÌååÏùºÏóê Ìó§ÎçîÎ•º Ï∂îÍ∞ÄÌïòÏßÄ ÏïäÍ∏∞Î°ú Í≤∞Ï†ïÌñàÏäµÎãàÎã§.",
        morseConverted: (input: string, final: string) => `Î≥ÄÌôòÎê®: ${input} ‚Üí ${final}`,
        morseDecoded: (input: string, final: string) => `Î≥µÌò∏ÌôîÎê®: ${input} ‚Üí ${final}`,
        fileLoaded: (absolutePath: string) => `ÌååÏùº ${absolutePath} Î°úÎìú ÏôÑÎ£å!`,
        fileParseError: (filePath: string, error: string) => `ÌååÏùº ÎÇ¥Ïö© (${filePath})ÏùÑ(Î•º) Ï†ïÏÉÅÏ†ÅÏúºÎ°ú Î°úÎìúÌï† Ïàò ÏóÜÏäµÎãàÎã§. Ïò§Î•ò: ${error}.`,
        fileRefreshed: () => "ÌååÏùº ÎÇ¥Ïö©ÏùÑ ÏÉàÎ°ú Í≥†ÏπòÎäî Ï§ëÏûÖÎãàÎã§.",
        filePathUpdated: (oldFilePath: string, newFilePath: string) => `Í≤ΩÎ°úÍ∞Ä ${oldFilePath}ÏóêÏÑú ${newFilePath}Î°ú ÏóÖÎç∞Ïù¥Ìä∏ÎêòÏóàÏäµÎãàÎã§.`,
        fileUnloaded: (filePath: string) => `ÌååÏùº ${filePath}Ïù¥(Í∞Ä) Î©îÎ™®Î¶¨ÏóêÏÑú Ïñ∏Î°úÎìúÎêòÏóàÏäµÎãàÎã§.`,
        fileExcludedActivationDisabled: () => "ÌôúÏÑ±Ìôî ÎπÑÌôúÏÑ±ÌôîÎê®, ÌååÏùºÏù¥ Ï†úÏô∏ Î™©Î°ùÏóê ÏûàÏäµÎãàÎã§.",
        fileSaveFailed: () => "ÌååÏùº Ï†ÄÏû• Ïã§Ìå®, Îã§Ïãú ÏãúÎèÑÌïòÏã≠ÏãúÏò§.",
        cwdUpdated: (oldCwd: string, newCwd: string) => `ÌòÑÏû¨ ÏûëÏóÖ ÎîîÎ†âÌÑ∞Î¶¨Í∞Ä ${oldCwd}ÏóêÏÑú ${newCwd}Î°ú ÏóÖÎç∞Ïù¥Ìä∏ÎêòÏóàÏäµÎãàÎã§.`,
        cwdDoesNotExist: (cwd: string) => `Ï†úÍ≥µÎêú ÏûëÏóÖ ÎîîÎ†âÌÑ∞Î¶¨ ${cwd}Í∞Ä Ï°¥Ïû¨ÌïòÏßÄ ÏïäÏäµÎãàÎã§.`,
        updatingEditionDate: () => "ÏàòÏ†ïÏùºÏùÑ ÏóÖÎç∞Ïù¥Ìä∏ Ï§ëÏûÖÎãàÎã§.",
        documentLineScanExceeded: (maxScanLength: number) => `ÌååÏùºÏùò Ï≤òÏùå ${maxScanLength}Ï§ÑÏùÑ Ïä§Ï∫îÌñàÏßÄÎßå Ìó§ÎçîÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.`,
        closedDocument: () => "Î¨∏ÏÑúÍ∞Ä Îã´ÌòÄ ÏûàÏñ¥ ÏûëÏóÖÏùÑ Ï§ëÎã®Ìï©ÎãàÎã§.",
        emptyDocument: () => "ÏûëÏóÖÌï† Î¨∏ÏÑú ÎÇ¥Ïö©Ïù¥ ÏóÜÏäµÎãàÎã§.",
        brokenHeader: () => "ÏÜêÏÉÅÎêú Ìó§ÎçîÍ∞Ä Í∞êÏßÄÎêòÏóàÏäµÎãàÎã§. ÏÉà Ìó§ÎçîÎ•º ÏÇΩÏûÖÌï©ÎãàÎã§. Ïù¥Ï†Ñ Í≤ÉÏùÑ ÏÇ≠Ï†úÌïòÏÑ∏Ïöî.",
        extensionActivated: (moduleName: string) => `üöÄ "${moduleName}" ÌôïÏû•Ïù¥ ÌôúÏÑ±ÌôîÎêòÏóàÏäµÎãàÎã§!`,
        helloWorldGreetingsCommand: (moduleName: string) => `Hello World from ${moduleName}!`,
        noActiveEditor: () => "ÌôúÏÑ± ÌååÏùºÏù¥ ÏóÜÏäµÎãàÎã§!",
        noFocusedEditors: () => "Ìè¨Ïª§Ïä§Îêú ÌååÏùºÏù¥ ÏóÜÏäµÎãàÎã§.",
        noLogoInstanceProvided: () => "Ï†úÍ≥µÎêú Î°úÍ≥† ÎûúÎç§ Ïù∏Ïä§ÌÑ¥Ïä§Í∞Ä ÏóÜÏäµÎãàÎã§.",
        randomLogoGatheringFailed: (error: string) => `ÎûúÎç§ Î°úÍ≥† ÏàòÏßë Ïã§Ìå®, Í∏∞Î≥∏ Î°úÍ≥† ÏÇ¨Ïö©, Ïò§Î•ò: "${error}"`,
        ramdomLogoGatheringLogoUndefined: () => "Î°úÍ≥† ÎÇ¥Ïö©Ïù¥ Ï†ïÏùòÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.",
        openFileToApplyHeader: () => "Ìó§ÎçîÎ•º Ï†ÅÏö©Ìï† ÌååÏùºÏùÑ Ïó¥Ïñ¥Ï£ºÏÑ∏Ïöî.",
        corruptedFileMetaData: () => "ÌïÑÏöîÌïú ÌååÏùº Î©îÌÉÄÎç∞Ïù¥ÌÑ∞Í∞Ä Ïò¨Î∞îÎ•¥Í≤å ÏàòÏßëÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§. Ï§ëÎã®Ìï©ÎãàÎã§.",
        messageWritten: () => "Î©îÏãúÏßÄ ÏûëÏÑ± ÏôÑÎ£å",
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string) =>
            `Hello World! ÌååÏùº ÌôïÏû•Ïûê: ${fileExtension}, Ïù¥Î¶Ñ: ${fileName}, Í≤ΩÎ°ú: ${filePath}, Ïñ∏Ïñ¥: ${languageId}\n`,
        missingFileError: () => "Ïñ∏Ïñ¥ ÏÇ¨Ï†ÑÏù¥ ÏóÜÏäµÎãàÎã§. Ï£ºÏÑù Ï†ÅÏùë Í∏∞Îä•Ïù¥ ÎπÑÌôúÏÑ±ÌôîÎê©ÎãàÎã§.",
        unknownFileStructure: () => "Ïñ∏Ïñ¥ ÏÇ¨Ï†Ñ Íµ¨Ï°∞Î•º Ïïå Ïàò ÏóÜÏäµÎãàÎã§. Ï£ºÏÑù Ï†ÅÏùë Í∏∞Îä•Ïù¥ ÎπÑÌôúÏÑ±ÌôîÎê©ÎãàÎã§.",
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]) => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}.`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string) =>
            `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        identifiedLanguage: (langName: string) => `ÏãùÎ≥ÑÎêú Ïñ∏Ïñ¥: ${langName}.`,
        errorDuringFunctionCall: (functionName: string) => `Ìï®Ïàò (${functionName}) Ìò∏Ï∂ú Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§. Î°úÍ∑∏Î•º ÌôïÏù∏ÌïòÏÑ∏Ïöî.`,
        missingLanguageComment: () => "Ïñ∏Ïñ¥ Ï£ºÏÑùÏù¥ Ï†úÍ≥µÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§. Ìï†ÎãπÏùÑ Í±¥ÎÑàÎúÅÎãàÎã§.",
        getHeaderDescription: () => "ÏÑ§Î™ÖÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî: ",
        getHeaderTags: () => "Ïù¥ ÌååÏùºÏùò ÌÉúÍ∑∏Î•º ÏâºÌëúÎ°ú Íµ¨Î∂ÑÌïòÏó¨ ÏûÖÎ†•ÌïòÏÑ∏Ïöî: ",
        getHeaderPurpose: () => "ÌååÏùºÏùò Î™©Ï†ÅÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî: ",
        noProvidedCommentOptions: () => "Ï†úÍ≥µÎêú Ï£ºÏÑù ÏòµÏÖòÏù¥ ÏóÜÏäµÎãàÎã§.",
        chooseSingleLineCommentOption: () => "ÏïÑÎûò ÏòµÏÖòÏóêÏÑú ÏõêÌïòÎäî Ï£ºÏÑù Ï†ëÎëêÏÇ¨Î•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî: ",
        toMorseGetInput: (): string => "Î≥ÄÌôòÌï† ÌÖçÏä§Ìä∏Î•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî",
        fromMorseGetInput: (): string => "Î≥ÄÌôòÌï† ÏõêÎ≥∏ ÌÖçÏä§Ìä∏Î•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî",
        operationCanceled: (): string => "ÏûëÏóÖÏù¥ Ï∑®ÏÜåÎêòÏóàÏäµÎãàÎã§",
        convertedContentCli: (content: string): string => `Î≥ÄÌôòÎêú ÎÇ¥Ïö©: ${content}`,
        convertedContentGui: (): string => "Î≥ÄÌôòÎêú ÎÇ¥Ïö©: ",
        updateAbortedBecauseFileClosedSyncCancelled: () => "ÌååÏùºÏù¥ Îã´ÌòÄ ÏûàÏñ¥ ÏóÖÎç∞Ïù¥Ìä∏Í∞Ä Ï§ëÎã®ÎêòÏóàÏúºÎ©∞ ÎèôÍ∏∞ÌôîÎêòÏßÄ ÏïäÏäµÎãàÎã§.",
        updateEditDateMissingBounds: () => "Ìó§ÎçîÎ•º ÏóÖÎç∞Ïù¥Ìä∏Ìï† Ïàò ÏóÜÏäµÎãàÎã§: ÎÇ¥Î∂Ä ÎßàÏª§Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.",
        lastModifiedLineNotFound: () => "Ìó§ÎçîÏóê 'ÎßàÏßÄÎßâ ÏàòÏ†ïÏùº' ÎùºÏù∏Ïù¥ ÏóÜÏäµÎãàÎã§.",
        lastModifiedUpdated: () => "'ÎßàÏßÄÎßâ ÏàòÏ†ïÏùº'Ïù¥ ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÏóÖÎç∞Ïù¥Ìä∏ÎêòÏóàÏäµÎãàÎã§.",
        languageNotFound: (LanguageId: string, fileExtension: string) => `Ïù¥ Î¨∏ÏÑúÏùò ÌååÏùº Ïñ∏Ïñ¥Î•º ÏãùÎ≥ÑÌï† Ïàò ÏóÜÏäµÎãàÎã§. languageID: ${LanguageId}, ÌååÏùº ÌôïÏû•Ïûê: ${fileExtension}`,
        jsonContent: (jsonContentString: String) => `Ï£ºÏÑù JSON ÌååÏùº ÎÇ¥Ïö©: ${jsonContentString}`,
        messageNotFound: (key: string) => `Î©îÏãúÏßÄ '${key}'Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.`
    },
    "ru": {
        inputboxError: (promptText: string, err: string) => `–û—à–∏–±–∫–∞ –≤ –ø–æ–ª–µ –≤–≤–æ–¥–∞ –¥–ª—è ${promptText}: ${err}`,
        quickPickError: (err: string) => `–û—à–∏–±–∫–∞ –≤ quickPick: ${err}`,
        quickPickYes: () => "–î–∞",
        quickPickNo: () => "–ù–µ—Ç",
        watermarkView: () => "–ø—Ä–æ—Å–º–æ—Ç—Ä –≤–æ–¥—è–Ω–æ–≥–æ –∑–Ω–∞–∫–∞",
        watermarkJsonFileInvalid: () => "–§–∞–π–ª JSON –≤–æ–¥—è–Ω–æ–≥–æ –∑–Ω–∞–∫–∞ –ø—É—Å—Ç –∏–ª–∏ –Ω–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª–µ–Ω",
        watermarkName: () => "–ù–∞–∑–≤–∞–Ω–∏–µ –≤–æ–¥—è–Ω–æ–≥–æ –∑–Ω–∞–∫–∞",
        watermarkCopyAscii: () => "–°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å ASCII",
        watermarkZoomIn: () => "–£–≤–µ–ª–∏—á–∏—Ç—å",
        watermarkZoomOut: () => "–£–º–µ–Ω—å—à–∏—Ç—å",
        watermarkPersonDisplayed: (name: string) => `–í–æ–¥—è–Ω–æ–π –∑–Ω–∞–∫ '${name}' –æ—Ç–æ–±—Ä–∞–∂–µ–Ω.`,
        watermarkChosen: (watermark: string[]) => `–í—ã–±—Ä–∞–Ω–Ω—ã–π –≤–æ–¥—è–Ω–æ–π –∑–Ω–∞–∫: ${JSON.stringify(watermark)}`,
        watermarkNotFound: () => "–í–æ–¥—è–Ω–æ–π –∑–Ω–∞–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω",
        watermarkCopied: (name: string) => `ASCII-–∞—Ä—Ç –¥–ª—è ${name} —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω!`,
        watermarkAuthorName: () => "–ò–º—è –∞–≤—Ç–æ—Ä–∞",
        darlingView: () => "–ø—Ä–æ—Å–º–æ—Ç—Ä –ø–µ—Ä—Å–æ–Ω–∞–∂–∞",
        darlingJsonFileInvalid: () => "–§–∞–π–ª JSON –ø–µ—Ä—Å–æ–Ω–∞–∂–∞ –ø—É—Å—Ç –∏–ª–∏ –Ω–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª–µ–Ω",
        darlingPersonDisplayed: (name: string) => `–ü–µ—Ä—Å–æ–Ω–∞–∂ '${name}' –æ—Ç–æ–±—Ä–∞–∂–µ–Ω.`,
        darlingCopyAscii: () => "–°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å ASCII",
        darlingZoomIn: () => "–£–≤–µ–ª–∏—á–∏—Ç—å",
        darlingZoomOut: () => "–£–º–µ–Ω—å—à–∏—Ç—å",
        darlingType: () => "–¢–∏–ø",
        darlingAge: () => "–í–æ–∑—Ä–∞—Å—Ç",
        darlingHeight: () => "–†–æ—Å—Ç",
        darlingAlias: () => "–ü—Å–µ–≤–¥–æ–Ω–∏–º",
        darlingDescription: () => "–û–ø–∏—Å–∞–Ω–∏–µ",
        darlingQuote: () => "–¶–∏—Ç–∞—Ç–∞",
        darlingMoreInfo: () => "–î–æ–ø. –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è",
        darlingImage: () => "–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ",
        darlingCopied: (name: string) => `ASCII-–∞—Ä—Ç –¥–ª—è ${name} —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω!`,
        logoView: () => "–ø—Ä–æ—Å–º–æ—Ç—Ä –ª–æ–≥–æ—Ç–∏–ø–∞",
        logoName: () => "–ù–∞–∑–≤–∞–Ω–∏–µ –ª–æ–≥–æ—Ç–∏–ø–∞",
        logoMessage: (logoPath: string) => `–§–∞–π–ª (${logoPath}) –ø—Ä–æ–∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω, —Ç–∞–∫ –∫–∞–∫ —ç—Ç–æ –Ω–µ –Ω—É–∂–Ω—ã–π —Ç–∏–ø.`,
        logoNoRootDir: () => "–ù–µ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω –∫–æ—Ä–Ω–µ–≤–æ–π –∫–∞—Ç–∞–ª–æ–≥ –¥–ª—è —Å–±–æ—Ä–∞ –ª–æ–≥–æ—Ç–∏–ø–æ–≤",
        logoRootDirUpdateError: (error: string) => `–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —Ñ–∞–π–ª–æ–≤ –ª–æ–≥–æ—Ç–∏–ø–∞: ${error}`,
        logoDisplayed: (name: string) => `–õ–æ–≥–æ—Ç–∏–ø '${name}' –æ—Ç–æ–±—Ä–∞–∂–µ–Ω.`,
        logoCopied: (logoName: string) => `ASCII-–∞—Ä—Ç –¥–ª—è ${logoName} —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω!`,
        logoChosen: (logo: string[]) => `–í—ã–±—Ä–∞–Ω–Ω—ã–π –ª–æ–≥–æ—Ç–∏–ø: ${JSON.stringify(logo)}`,
        logoNotFound: () => "–õ–æ–≥–æ—Ç–∏–ø –Ω–µ –Ω–∞–π–¥–µ–Ω",
        logoCopyAscii: () => "–°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å ASCII",
        noCommentToShow: () => "–ù–µ—Ç –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–≤ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è.",
        unknown: () => "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ",
        headerOpenerFound: () => "–ù–∞—á–∞–ª–æ –∑–∞–≥–æ–ª–æ–≤–∫–∞ –Ω–∞–π–¥–µ–Ω–æ.",
        headerOpenerAndCloserFound: () => "–ù–∞—á–∞–ª–æ –∏ –∫–æ–Ω–µ—Ü –∑–∞–≥–æ–ª–æ–≤–∫–∞ –Ω–∞–π–¥–µ–Ω—ã, –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –¥–∞—Ç—ã –ø–æ—Å–ª–µ –ø—Ä–æ–≤–µ—Ä–∫–∏.",
        headerWriteFailed: () => "–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–ø–∏—Å–∞—Ç—å –∑–∞–≥–æ–ª–æ–≤–æ–∫ –≤ —Ñ–∞–π–ª, –ø—Ä–æ–≤–µ—Ä—å—Ç–µ –ª–æ–≥–∏.",
        headerWriteSuccess: () => "–ó–∞–≥–æ–ª–æ–≤–æ–∫ —É—Å–ø–µ—à–Ω–æ –∑–∞–ø–∏—Å–∞–Ω.",
        headerNotFound: () => "–ó–∞–≥–æ–ª–æ–≤–æ–∫ –≤ —ç—Ç–æ–º –¥–æ–∫—É–º–µ–Ω—Ç–µ –Ω–µ –Ω–∞–π–¥–µ–Ω.",
        headerInjectQuestion: () => "–ó–∞–≥–æ–ª–æ–≤–æ–∫ –≤ —ç—Ç–æ–º –¥–æ–∫—É–º–µ–Ω—Ç–µ –Ω–µ –Ω–∞–π–¥–µ–Ω. –•–æ—Ç–∏—Ç–µ –¥–æ–±–∞–≤–∏—Ç—å –µ–≥–æ?",
        headerInjectQuestionRefused: () => "–í—ã —Ä–µ—à–∏–ª–∏ –Ω–µ –¥–æ–±–∞–≤–ª—è—Ç—å –∑–∞–≥–æ–ª–æ–≤–æ–∫ –≤ —Ñ–∞–π–ª.",
        morseConverted: (input: string, final: string) => `–ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–æ: ${input} ‚Üí ${final}`,
        morseDecoded: (input: string, final: string) => `–î–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–æ: ${input} ‚Üí ${final}`,
        fileLoaded: (absolutePath: string) => `–§–∞–π–ª ${absolutePath} –∑–∞–≥—Ä—É–∂–µ–Ω!`,
        fileParseError: (filePath: string, error: string) => `–°–æ–¥–µ—Ä–∂–∏–º–æ–µ —Ñ–∞–π–ª–∞ (${filePath}) –Ω–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å. –û—à–∏–±–∫–∞: ${error}.`,
        fileRefreshed: () => "–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ —Ñ–∞–π–ª–∞.",
        filePathUpdated: (oldFilePath: string, newFilePath: string) => `–ü—É—Ç—å –æ–±–Ω–æ–≤–ª–µ–Ω —Å ${oldFilePath} –Ω–∞ ${newFilePath}.`,
        fileUnloaded: (filePath: string) => `–§–∞–π–ª ${filePath} –≤—ã–≥—Ä—É–∂–µ–Ω –∏–∑ –ø–∞–º—è—Ç–∏.`,
        fileExcludedActivationDisabled: () => "–ê–∫—Ç–∏–≤–∞—Ü–∏—è –æ—Ç–∫–ª—é—á–µ–Ω–∞, —Ñ–∞–π–ª –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ —Å–ø–∏—Å–∫–µ –∏—Å–∫–ª—é—á–µ–Ω–∏–π.",
        fileSaveFailed: () => "–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ñ–∞–π–ª, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.",
        cwdUpdated: (oldCwd: string, newCwd: string) => `–¢–µ–∫—É—â–∏–π —Ä–∞–±–æ—á–∏–π –∫–∞—Ç–∞–ª–æ–≥ –æ–±–Ω–æ–≤–ª–µ–Ω —Å ${oldCwd} –Ω–∞ ${newCwd}.`,
        cwdDoesNotExist: (cwd: string) => `–£–∫–∞–∑–∞–Ω–Ω—ã–π —Ä–∞–±–æ—á–∏–π –∫–∞—Ç–∞–ª–æ–≥ ${cwd} –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç.`,
        updatingEditionDate: () => "–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –¥–∞—Ç—ã —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è.",
        documentLineScanExceeded: (maxScanLength: number) => `–ü—Ä–æ—Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–æ –ø–µ—Ä–≤—ã–µ ${maxScanLength} —Å—Ç—Ä–æ–∫–∏ —Ñ–∞–π–ª–∞, –∑–∞–≥–æ–ª–æ–≤–æ–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω.`,
        closedDocument: () => "–î–æ–∫—É–º–µ–Ω—Ç –∑–∞–∫—Ä—ã—Ç, –æ–ø–µ—Ä–∞—Ü–∏—è –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞.",
        emptyDocument: () => "–ù–µ—Ç —Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ –¥–æ–∫—É–º–µ–Ω—Ç–∞ –¥–ª—è —Ä–∞–±–æ—Ç—ã.",
        brokenHeader: () => "–û–±–Ω–∞—Ä—É–∂–µ–Ω –ø–æ–≤—Ä–µ–∂–¥–µ–Ω–Ω—ã–π –∑–∞–≥–æ–ª–æ–≤–æ–∫, –≤—Å—Ç–∞–≤–ª—è–µ—Ç—Å—è –Ω–æ–≤—ã–π, —É–¥–∞–ª–∏—Ç–µ –ø—Ä–µ–¥—ã–¥—É—â–∏–π.",
        extensionActivated: (moduleName: string) => `üöÄ –†–∞—Å—à–∏—Ä–µ–Ω–∏–µ "${moduleName}" —Ç–µ–ø–µ—Ä—å –∞–∫—Ç–∏–≤–Ω–æ!`,
        helloWorldGreetingsCommand: (moduleName: string) => `Hello World –∏–∑ ${moduleName}!`,
        noActiveEditor: () => "–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–≥–æ —Ñ–∞–π–ª–∞!",
        noFocusedEditors: () => "–ù–µ—Ç —Ñ–∞–π–ª–æ–≤ –≤ —Ñ–æ–∫—É—Å–µ.",
        noLogoInstanceProvided: () => "–ù–µ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω —ç–∫–∑–µ–º–ø–ª—è—Ä —Ä–∞–Ω–¥–æ–º–∏–∑–∞—Ç–æ—Ä–∞ –ª–æ–≥–æ—Ç–∏–ø–∞.",
        randomLogoGatheringFailed: (error: string) => `–°–±–æ—Ä —Å–ª—É—á–∞–π–Ω–æ–≥–æ –ª–æ–≥–æ—Ç–∏–ø–∞ –Ω–µ —É–¥–∞–ª—Å—è, –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –ª–æ–≥–æ—Ç–∏–ø –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é, –æ—à–∏–±–∫–∞: "${error}"`,
        ramdomLogoGatheringLogoUndefined: () => "–°–æ–¥–µ—Ä–∂–∏–º–æ–µ –ª–æ–≥–æ—Ç–∏–ø–∞ –Ω–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–æ.",
        openFileToApplyHeader: () => "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–∫—Ä–æ–π—Ç–µ —Ñ–∞–π–ª, —á—Ç–æ–±—ã –ø—Ä–∏–º–µ–Ω–∏—Ç—å –∑–∞–≥–æ–ª–æ–≤–æ–∫.",
        corruptedFileMetaData: () => "–ù–µ —É–¥–∞–ª–æ—Å—å –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ —Å–æ–±—Ä–∞—Ç—å –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ —Ñ–∞–π–ª–∞, –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏–µ.",
        messageWritten: () => "–°–æ–æ–±—â–µ–Ω–∏–µ –∑–∞–ø–∏—Å–∞–Ω–æ",
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string) =>
            `Hello World! –†–∞—Å—à–∏—Ä–µ–Ω–∏–µ —Ñ–∞–π–ª–∞: ${fileExtension}, –∏–º—è: ${fileName}, –ø—É—Ç—å: ${filePath}, —è–∑—ã–∫: ${languageId}\n`,
        missingFileError: () => "–°–ª–æ–≤–∞—Ä—å —è–∑—ã–∫–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç, –∞–¥–∞–ø—Ç–∞—Ü–∏—è –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–≤ –æ—Ç–∫–ª—é—á–µ–Ω–∞.",
        unknownFileStructure: () => "–°—Ç—Ä—É–∫—Ç—É—Ä–∞ —Å–ª–æ–≤–∞—Ä—è —è–∑—ã–∫–∞ –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–∞, –∞–¥–∞–ø—Ç–∞—Ü–∏—è –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–≤ –æ—Ç–∫–ª—é—á–µ–Ω–∞.",
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]) => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}.`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string) =>
            `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        identifiedLanguage: (langName: string) => `–û–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã–π —è–∑—ã–∫: ${langName}.`,
        errorDuringFunctionCall: (functionName: string) => `–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–∑–æ–≤–µ —Ñ—É–Ω–∫—Ü–∏–∏ (${functionName}), –ø—Ä–æ–≤–µ—Ä—å—Ç–µ –ª–æ–≥–∏.`,
        missingLanguageComment: () => "–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –¥–ª—è —è–∑—ã–∫–∞ –Ω–µ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω, –ø—Ä–æ–ø—É—Å–∫ –ø—Ä–∏—Å–≤–æ–µ–Ω–∏—è.",
        getHeaderDescription: () => "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø—Ä–µ–¥–æ—Å—Ç–∞–≤—å—Ç–µ –æ–ø–∏—Å–∞–Ω–∏–µ: ",
        getHeaderTags: () => "–í–≤–µ–¥–∏—Ç–µ —Ç–µ–≥–∏ –¥–ª—è —ç—Ç–æ–≥–æ —Ñ–∞–π–ª–∞ —á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é: ",
        getHeaderPurpose: () => "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ –Ω–∞–∑–Ω–∞—á–µ–Ω–∏–µ —Ñ–∞–π–ª–∞: ",
        noProvidedCommentOptions: () => "–ù–µ—Ç –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω–Ω—ã—Ö –æ–ø—Ü–∏–π –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–≤.",
        chooseSingleLineCommentOption: () => "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –ø—Ä–µ–¥–ø–æ—á–∏—Ç–∞–µ–º—ã–π –ø—Ä–µ—Ñ–∏–∫—Å –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏—è –∏–∑ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–Ω—ã—Ö –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤: ",
        toMorseGetInput: (): string => "–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –¥–ª—è –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è",
        fromMorseGetInput: (): string => "–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –¥–ª—è –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è –∏–∑",
        operationCanceled: (): string => "–û–ø–µ—Ä–∞—Ü–∏—è –æ—Ç–º–µ–Ω–µ–Ω–∞",
        convertedContentCli: (content: string): string => `–ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–Ω—ã–π –∫–æ–Ω—Ç–µ–Ω—Ç: ${content}`,
        convertedContentGui: (): string => "–ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–Ω—ã–π –∫–æ–Ω—Ç–µ–Ω—Ç: ",
        updateAbortedBecauseFileClosedSyncCancelled: () => "–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—Ä–µ—Ä–≤–∞–Ω–æ, —Ç–∞–∫ –∫–∞–∫ —Ñ–∞–π–ª –∑–∞–∫—Ä—ã—Ç –∏ –Ω–µ –±—É–¥–µ—Ç —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞–Ω.",
        updateEditDateMissingBounds: () => "–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±–Ω–æ–≤–∏—Ç—å –∑–∞–≥–æ–ª–æ–≤–æ–∫: –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ –º–∞—Ä–∫–µ—Ä—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã.",
        lastModifiedLineNotFound: () => "–í –∑–∞–≥–æ–ª–æ–≤–∫–µ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç —Å—Ç—Ä–æ–∫–∞ '–ü–æ—Å–ª–µ–¥–Ω–µ–µ –∏–∑–º–µ–Ω–µ–Ω–∏–µ' –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è.",
        lastModifiedUpdated: () => "–î–∞—Ç–∞ '–ü–æ—Å–ª–µ–¥–Ω–µ–µ –∏–∑–º–µ–Ω–µ–Ω–∏–µ' —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∞.",
        languageNotFound: (LanguageId: string, fileExtension: string) => `–ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å —è–∑—ã–∫ —Ñ–∞–π–ª–∞ —ç—Ç–æ–≥–æ –¥–æ–∫—É–º–µ–Ω—Ç–∞, languageID: ${LanguageId}, —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ —Ñ–∞–π–ª–∞: ${fileExtension}`,
        jsonContent: (jsonContentString: String) => `–°–æ–¥–µ—Ä–∂–∏–º–æ–µ JSON-—Ñ–∞–π–ª–∞ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–≤: ${jsonContentString}`,
        messageNotFound: (key: string) => `–°–æ–æ–±—â–µ–Ω–∏–µ '${key}' –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.`
    },
    "pt-br": {
        inputboxError: (promptText: string, err: string) => `Erro na caixa de entrada para ${promptText}: ${err}`,
        quickPickError: (err: string) => `Erro no quickPick: ${err}`,
        quickPickYes: () => "Sim",
        quickPickNo: () => "N√£o",
        watermarkView: () => "visualiza√ß√£o da marca d'√°gua",
        watermarkJsonFileInvalid: () => "O arquivo JSON da marca d'√°gua est√° vazio ou inv√°lido",
        watermarkName: () => "Nome da marca d'√°gua",
        watermarkCopyAscii: () => "Copiar ASCII",
        watermarkZoomIn: () => "Aumentar zoom",
        watermarkZoomOut: () => "Diminuir zoom",
        watermarkPersonDisplayed: (name: string) => `Marca d'√°gua '${name}' exibida.`,
        watermarkChosen: (watermark: string[]) => `Marca d'√°gua a ser exibida: ${JSON.stringify(watermark)}`,
        watermarkNotFound: () => "Marca d'√°gua n√£o encontrada",
        watermarkCopied: (name: string) => `ASCII art copiado para ${name}!`,
        watermarkAuthorName: () => "Nome do autor",
        darlingView: () => "visualiza√ß√£o do personagem",
        darlingJsonFileInvalid: () => "O arquivo JSON do personagem est√° vazio ou inv√°lido",
        darlingPersonDisplayed: (name: string) => `Personagem '${name}' exibido.`,
        darlingCopyAscii: () => "Copiar ASCII",
        darlingZoomIn: () => "Aumentar zoom",
        darlingZoomOut: () => "Diminuir zoom",
        darlingType: () => "Tipo",
        darlingAge: () => "Idade",
        darlingHeight: () => "Altura",
        darlingAlias: () => "Apelido",
        darlingDescription: () => "Descri√ß√£o",
        darlingQuote: () => "Cita√ß√£o",
        darlingMoreInfo: () => "Mais informa√ß√µes",
        darlingImage: () => "Imagem",
        darlingCopied: (name: string) => `ASCII art copiado para ${name}!`,
        logoView: () => "visualiza√ß√£o do logotipo",
        logoName: () => "Nome do logotipo",
        logoMessage: (logoPath: string) => `Arquivo (${logoPath}) ignorado, pois n√£o √© do tipo esperado.`,
        logoNoRootDir: () => "Nenhum diret√≥rio raiz fornecido para coleta de logotipos",
        logoRootDirUpdateError: (error: string) => `Erro ao atualizar arquivos de logotipo: ${error}`,
        logoDisplayed: (name: string) => `Logotipo '${name}' exibido.`,
        logoCopied: (logoName: string) => `ASCII art copiado para ${logoName}!`,
        logoChosen: (logo: string[]) => `Logotipo a ser exibido: ${JSON.stringify(logo)}`,
        logoNotFound: () => "Logotipo n√£o encontrado",
        logoCopyAscii: () => "Copiar ASCII",
        noCommentToShow: () => "N√£o h√° coment√°rios para exibir.",
        unknown: () => "Desconhecido",
        headerOpenerFound: () => "In√≠cio do cabe√ßalho encontrado.",
        headerOpenerAndCloserFound: () => "In√≠cio e fim do cabe√ßalho encontrados, atualizando data ap√≥s verifica√ß√£o.",
        headerWriteFailed: () => "Falha ao escrever o cabe√ßalho no arquivo, verifique os logs.",
        headerWriteSuccess: () => "Cabe√ßalho escrito com sucesso.",
        headerNotFound: () => "Nenhum cabe√ßalho encontrado neste documento.",
        headerInjectQuestion: () => "Nenhum cabe√ßalho encontrado neste documento. Deseja adicionar um?",
        headerInjectQuestionRefused: () => "Voc√™ optou por n√£o adicionar um cabe√ßalho ao arquivo.",
        morseConverted: (input: string, final: string) => `Convertido: ${input} para ${final}`,
        morseDecoded: (input: string, final: string) => `Decodificado: ${input} para ${final}`,
        fileLoaded: (absolutePath: string) => `Arquivo ${absolutePath} carregado!`,
        fileParseError: (filePath: string, error: string) => `O conte√∫do do arquivo (${filePath}) n√£o p√¥de ser carregado com sucesso. Erro: ${error}.`,
        fileRefreshed: () => "Atualizando o conte√∫do do arquivo.",
        filePathUpdated: (oldFilePath: string, newFilePath: string) => `O caminho foi atualizado de ${oldFilePath} para ${newFilePath}.`,
        fileUnloaded: (filePath: string) => `Arquivo ${filePath} descarregado da mem√≥ria.`,
        fileExcludedActivationDisabled: () => "Ativa√ß√£o desativada, o arquivo est√° na lista de exclus√£o.",
        fileSaveFailed: () => "Falha ao salvar o arquivo, por favor tente novamente.",
        cwdUpdated: (oldCwd: string, newCwd: string) => `O diret√≥rio de trabalho atual foi atualizado de ${oldCwd} para ${newCwd}.`,
        cwdDoesNotExist: (cwd: string) => `O diret√≥rio de trabalho fornecido ${cwd} n√£o existe.`,
        updatingEditionDate: () => "Atualizando a data de edi√ß√£o.",
        documentLineScanExceeded: (maxScanLength: number) => `Verificadas as primeiras ${maxScanLength} linhas do arquivo, mas nenhum cabe√ßalho encontrado.`,
        closedDocument: () => "O documento est√° fechado, interrompendo opera√ß√µes.",
        emptyDocument: () => "N√£o h√° corpo do documento para trabalhar.",
        brokenHeader: () => "Cabe√ßalho corrompido detectado, inserindo novo, por favor remova o anterior.",
        extensionActivated: (moduleName: string) => `üöÄ "${moduleName}" agora est√° ativo!`,
        helloWorldGreetingsCommand: (moduleName: string) => `Ol√° Mundo do ${moduleName}!`,
        noActiveEditor: () => "Nenhum arquivo ativo!",
        noFocusedEditors: () => "N√£o h√° arquivos em foco.",
        noLogoInstanceProvided: () => "Nenhuma inst√¢ncia de randomizador de logotipo fornecida.",
        randomLogoGatheringFailed: (error: string) => `Falha na coleta aleat√≥ria de logotipos, usando logotipo padr√£o, erro: "${error}"`,
        ramdomLogoGatheringLogoUndefined: () => "O conte√∫do do logotipo est√° indefinido.",
        openFileToApplyHeader: () => "Por favor, abra um arquivo para aplicar o cabe√ßalho.",
        corruptedFileMetaData: () => "Os metadados do arquivo n√£o foram coletados corretamente, abortando.",
        messageWritten: () => "Mensagem escrita",
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string) =>
            `Ol√° mundo! Extens√£o do arquivo: ${fileExtension}, nome: ${fileName}, caminho: ${filePath}, idioma: ${languageId}\n`,
        missingFileError: () => "O dicion√°rio de idioma est√° faltando, adaptabilidade de coment√°rio desativada.",
        unknownFileStructure: () => "A estrutura do dicion√°rio de idioma √© desconhecida, adaptabilidade de coment√°rio desativada.",
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]) => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}.`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string) =>
            `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        identifiedLanguage: (langName: string) => `Idioma identificado: ${langName}.`,
        errorDuringFunctionCall: (functionName: string) => `Algo deu errado durante a chamada da fun√ß√£o (${functionName}), verifique os logs.`,
        missingLanguageComment: () => "Coment√°rio de idioma n√£o fornecido, atribui√ß√£o ignorada.",
        getHeaderDescription: () => "Por favor, forne√ßa uma descri√ß√£o: ",
        getHeaderTags: () => "Digite as tags para este arquivo, separadas por v√≠rgulas:",
        getHeaderPurpose: () => "Por favor, forne√ßa o prop√≥sito do arquivo:",
        noProvidedCommentOptions: () => "Nenhuma op√ß√£o de coment√°rio fornecida.",
        chooseSingleLineCommentOption: () => "Por favor, selecione seu prefixo de coment√°rio preferido entre as op√ß√µes abaixo:",
        toMorseGetInput: (): string => "Por favor, insira o texto para converter",
        fromMorseGetInput: (): string => "Por favor, insira o texto para converter de",
        operationCanceled: (): string => "Opera√ß√£o cancelada",
        convertedContentCli: (content: string): string => `Conte√∫do convertido: ${content}`,
        convertedContentGui: (): string => "Conte√∫do convertido: ",
        updateAbortedBecauseFileClosedSyncCancelled: () => "Atualiza√ß√£o abortada porque o arquivo est√° fechado e n√£o ser√° sincronizado.",
        updateEditDateMissingBounds: () => "N√£o foi poss√≠vel atualizar o cabe√ßalho: marcadores internos n√£o encontrados.",
        lastModifiedLineNotFound: () => "O cabe√ßalho n√£o cont√©m uma linha '√öltima Modifica√ß√£o' para atualizar.",
        lastModifiedUpdated: () => "Data de '√öltima Modifica√ß√£o' atualizada com sucesso.",
        languageNotFound: (LanguageId: string, fileExtension: string) => `N√£o foi poss√≠vel identificar o idioma do arquivo deste documento, languageID: ${LanguageId}, extens√£o do arquivo: ${fileExtension}`,
        jsonContent: (jsonContentString: String) => `Conte√∫do do arquivo JSON de coment√°rios: ${jsonContentString}`,
        messageNotFound: (key: string) => `Mensagem '${key}' n√£o encontrada.`
    },
    "tr": {
        inputboxError: (promptText: string, err: string) => `${promptText} i√ßin inputBox hatasƒ±: ${err}`,
        quickPickError: (err: string) => `quickPick hatasƒ±: ${err}`,
        quickPickYes: () => "Evet",
        quickPickNo: () => "Hayƒ±r",
        watermarkView: () => "filigranG√∂r√ºn√ºm√º",
        watermarkJsonFileInvalid: () => "Filigran JSON dosyasƒ± bo≈ü veya ge√ßersiz",
        watermarkName: () => "Filigran adƒ±",
        watermarkCopyAscii: () => "ASCII'yi Kopyala",
        watermarkZoomIn: () => "Yakƒ±nla≈ütƒ±r",
        watermarkZoomOut: () => "Uzakla≈ütƒ±r",
        watermarkPersonDisplayed: (name: string) => `'${name}' filigranƒ± g√∂r√ºnt√ºlendi.`,
        watermarkChosen: (watermark: string[]) => `G√∂sterilecek filigran: ${JSON.stringify(watermark)}`,
        watermarkNotFound: () => "Filigran bulunamadƒ±",
        watermarkCopied: (name: string) => `${name} i√ßin ASCII sanatƒ± kopyalandƒ±!`,
        watermarkAuthorName: () => "Yazar adƒ±",
        darlingView: () => "karakterG√∂r√ºn√ºm√º",
        darlingJsonFileInvalid: () => "Karakter JSON dosyasƒ± bo≈ü veya ge√ßersiz",
        darlingPersonDisplayed: (name: string) => `'${name}' karakteri g√∂r√ºnt√ºlendi.`,
        darlingCopyAscii: () => "ASCII'yi Kopyala",
        darlingZoomIn: () => "Yakƒ±nla≈ütƒ±r",
        darlingZoomOut: () => "Uzakla≈ütƒ±r",
        darlingType: () => "T√ºr",
        darlingAge: () => "Ya≈ü",
        darlingHeight: () => "Boy",
        darlingAlias: () => "Takma ad",
        darlingDescription: () => "A√ßƒ±klama",
        darlingQuote: () => "Alƒ±ntƒ±",
        darlingMoreInfo: () => "Daha fazla bilgi",
        darlingImage: () => "Resim",
        darlingCopied: (name: string) => `${name} i√ßin ASCII sanatƒ± kopyalandƒ±!`,
        logoView: () => "logoG√∂r√ºn√ºm√º",
        logoName: () => "Logo adƒ±",
        logoMessage: (logoPath: string) => `Dosya (${logoPath}) g√∂z ardƒ± edildi, √ß√ºnk√º aranan t√ºr deƒüil.`,
        logoNoRootDir: () => "Logo toplamak i√ßin k√∂k dizin saƒülanmadƒ±",
        logoRootDirUpdateError: (error: string) => `Logo dosyalarƒ± g√ºncellenirken bir hata olu≈ütu: ${error}`,
        logoDisplayed: (name: string) => `'${name}' logosu g√∂r√ºnt√ºlendi.`,
        logoCopied: (logoName: string) => `${logoName} i√ßin ASCII sanatƒ± kopyalandƒ±!`,
        logoChosen: (logo: string[]) => `G√∂sterilecek logo: ${JSON.stringify(logo)}`,
        logoNotFound: () => "Logo bulunamadƒ±",
        logoCopyAscii: () => "ASCII'yi Kopyala",
        noCommentToShow: () => "G√∂sterilecek yorum yok.",
        unknown: () => "Bilinmeyen",
        headerOpenerFound: () => "Ba≈ülƒ±k a√ßƒ±lƒ±≈üƒ± bulundu.",
        headerOpenerAndCloserFound: () => "Ba≈ülƒ±k a√ßƒ±lƒ±≈üƒ± ve kapanƒ±≈üƒ± bulundu, denetim sonrasƒ± tarih g√ºncellemesine ge√ßiliyor.",
        headerWriteFailed: () => "Ba≈ülƒ±k dosyaya yazƒ±lamadƒ±, g√ºnl√ºkleri kontrol edin.",
        headerWriteSuccess: () => "Ba≈ülƒ±k ba≈üarƒ±yla yazƒ±ldƒ±.",
        headerNotFound: () => "Bu belgede ba≈ülƒ±k bulunamadƒ±.",
        headerInjectQuestion: () => "Bu belgede ba≈ülƒ±k bulunamadƒ±. Eklemek ister misiniz?",
        headerInjectQuestionRefused: () => "Dosyaya ba≈ülƒ±k eklememeyi se√ßtiniz.",
        morseConverted: (input: string, final: string) => `D√∂n√º≈üt√ºr√ºld√º: ${input} -> ${final}`,
        morseDecoded: (input: string, final: string) => `√á√∂z√ºld√º: ${input} -> ${final}`,
        fileLoaded: (absolutePath: string) => `Dosya ${absolutePath} y√ºklendi!`,
        fileParseError: (filePath: string, error: string) => `Dosya i√ßeriƒüi (${filePath}) ba≈üarƒ±yla y√ºklenemedi. Hata: ${error}.`,
        fileRefreshed: () => "Dosya i√ßeriƒüi yenileniyor.",
        filePathUpdated: (oldFilePath: string, newFilePath: string) => `Yol ${oldFilePath}‚Äôden ${newFilePath}‚Äôe g√ºncellendi.`,
        fileUnloaded: (filePath: string) => `Dosya ${filePath} hafƒ±zadan bo≈üaltƒ±ldƒ±.`,
        fileExcludedActivationDisabled: () => "Aktivasyon devre dƒ±≈üƒ±, dosya hari√ß tutma listesinde.",
        fileSaveFailed: () => "Dosya kaydedilemedi, l√ºtfen tekrar deneyin.",
        cwdUpdated: (oldCwd: string, newCwd: string) => `Mevcut √ßalƒ±≈üma dizini ${oldCwd}‚Äôden ${newCwd}‚Äôye g√ºncellendi.`,
        cwdDoesNotExist: (cwd: string) => `Saƒülanan √ßalƒ±≈üma dizini ${cwd} mevcut deƒüil.`,
        updatingEditionDate: () => "S√ºr√ºm tarihi g√ºncelleniyor.",
        documentLineScanExceeded: (maxScanLength: number) => `Dosyanƒ±n ilk ${maxScanLength} satƒ±rƒ± tarandƒ±, ba≈ülƒ±k bulunamadƒ±.`,
        closedDocument: () => "Belge kapalƒ±, i≈ülemler durduruluyor.",
        emptyDocument: () => "√úzerinde √ßalƒ±≈üƒ±lacak belge yok.",
        brokenHeader: () => "Bozuk ba≈ülƒ±k tespit edildi, yeni ba≈ülƒ±k ekleniyor, l√ºtfen √∂ncekini kaldƒ±rƒ±n.",
        extensionActivated: (moduleName: string) => `üöÄ "${moduleName}" artƒ±k aktif!`,
        helloWorldGreetingsCommand: (moduleName: string) => `${moduleName}‚Äôden Merhaba D√ºnya!`,
        noActiveEditor: () => "Aktif dosya yok!",
        noFocusedEditors: () => "Odaklanmƒ±≈ü dosya yok.",
        noLogoInstanceProvided: () => "Hi√ßbir logo rastgelele≈ütirici √∂rneƒüi saƒülanmadƒ±.",
        randomLogoGatheringFailed: (error: string) => `Rastgele logo toplama ba≈üarƒ±sƒ±z, varsayƒ±lan logo kullanƒ±lƒ±yor, hata: "${error}"`,
        ramdomLogoGatheringLogoUndefined: () => "Logo i√ßeriƒüi tanƒ±msƒ±z.",
        openFileToApplyHeader: () => "Ba≈ülƒ±ƒüƒ± uygulamak i√ßin bir dosya a√ßƒ±n.",
        corruptedFileMetaData: () => "Gerekli dosya meta verileri doƒüru ≈üekilde alƒ±namadƒ±, i≈ülem durduruldu.",
        messageWritten: () => "Mesaj yazƒ±ldƒ±",
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string) =>
            `Merhaba d√ºnya! Bu dosyanƒ±n uzantƒ±sƒ±: ${fileExtension}, adƒ±: ${fileName}, yolu: ${filePath}, belirlenen dil: ${languageId}\n`,
        missingFileError: () => "Dil s√∂zl√ºƒü√º eksik, yorum uyumluluƒüu devre dƒ±≈üƒ±.",
        unknownFileStructure: () => "Dil s√∂zl√ºƒü√º yapƒ±sƒ± bilinmiyor, yorum uyumluluƒüu devre dƒ±≈üƒ±.",
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]) => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}.`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string) =>
            `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        identifiedLanguage: (langName: string) => `Belirlenen dil: ${langName}.`,
        errorDuringFunctionCall: (functionName: string) => `Fonksiyon (${functionName}) √ßaƒürƒ±lƒ±rken bir hata olu≈ütu, loglarƒ± kontrol edin.`,
        missingLanguageComment: () => "Dil yorumu saƒülanmadƒ±, atlama yapƒ±lƒ±yor.",
        getHeaderDescription: () => "L√ºtfen bir a√ßƒ±klama saƒülayƒ±n: ",
        getHeaderTags: () => "Bu dosya i√ßin etiketleri virg√ºlle ayƒ±rarak girin:",
        getHeaderPurpose: () => "L√ºtfen dosyanƒ±n amacƒ±nƒ± belirtin:",
        noProvidedCommentOptions: () => "Saƒülanmƒ±≈ü yorum se√ßeneƒüi yok.",
        chooseSingleLineCommentOption: () => "A≈üaƒüƒ±daki se√ßeneklerden tercih ettiƒüiniz yorum √∂n ekini se√ßin:",
        toMorseGetInput: (): string => "L√ºtfen d√∂n√º≈üt√ºr√ºlecek metni girin",
        fromMorseGetInput: (): string => "L√ºtfen d√∂n√º≈üt√ºr√ºlecek metni buradan girin",
        operationCanceled: (): string => "ƒ∞≈ülem iptal edildi",
        convertedContentCli: (content: string): string => `D√∂n√º≈üt√ºr√ºlen i√ßerik: ${content}`,
        convertedContentGui: (): string => "D√∂n√º≈üt√ºr√ºlen i√ßerik: ",
        updateAbortedBecauseFileClosedSyncCancelled: () => "Dosya kapalƒ± olduƒüu i√ßin g√ºncelleme iptal edildi ve senkronize edilmeyecek.",
        updateEditDateMissingBounds: () => "Ba≈ülƒ±k g√ºncellenemedi: i√ß ba≈ülƒ±k i≈üaret√ßileri bulunamadƒ±.",
        lastModifiedLineNotFound: () => "Ba≈ülƒ±kta g√ºncellenecek 'Son Deƒüi≈üiklik' satƒ±rƒ± yok.",
        lastModifiedUpdated: () => "'Son Deƒüi≈üiklik' tarihi ba≈üarƒ±yla g√ºncellendi.",
        languageNotFound: (LanguageId: string, fileExtension: string) => `Bu belgenin dosya dili tanƒ±mlanamadƒ±, languageID: ${LanguageId}, dosya uzantƒ±sƒ±: ${fileExtension}`,
        jsonContent: (jsonContentString: String) => `Yorum JSON dosyasƒ±nƒ±n i√ßeriƒüi: ${jsonContentString}`,
        messageNotFound: (key: string) => `'${key}' mesajƒ± bulunamadƒ±.`
    },
    "pl": {
        inputboxError: (promptText: string, err: string) => `B≈ÇƒÖd w inputBox dla ${promptText}: ${err}`,
        quickPickError: (err: string) => `B≈ÇƒÖd w quickPick: ${err}`,
        quickPickYes: () => "Tak",
        quickPickNo: () => "Nie",
        watermarkView: () => "widokWatermark",
        watermarkJsonFileInvalid: () => "Plik JSON filigranu jest pusty lub nieprawid≈Çowy",
        watermarkName: () => "Nazwa filigranu",
        watermarkCopyAscii: () => "Kopiuj ASCII",
        watermarkZoomIn: () => "Powiƒôksz",
        watermarkZoomOut: () => "Pomniejsz",
        watermarkPersonDisplayed: (name: string) => `Filigran '${name}' zosta≈Ç wy≈õwietlony.`,
        watermarkChosen: (watermark: string[]) => `Filigran do wy≈õwietlenia: ${JSON.stringify(watermark)}`,
        watermarkNotFound: () => "Filigran nie zosta≈Ç znaleziony",
        watermarkCopied: (name: string) => `Sztuka ASCII skopiowana dla ${name}!`,
        watermarkAuthorName: () => "Autor",
        darlingView: () => "widokPostaci",
        darlingJsonFileInvalid: () => "Plik JSON postaci jest pusty lub nieprawid≈Çowy",
        darlingPersonDisplayed: (name: string) => `Postaƒá '${name}' zosta≈Ça wy≈õwietlona.`,
        darlingCopyAscii: () => "Kopiuj ASCII",
        darlingZoomIn: () => "Powiƒôksz",
        darlingZoomOut: () => "Pomniejsz",
        darlingType: () => "Typ",
        darlingAge: () => "Wiek",
        darlingHeight: () => "Wzrost",
        darlingAlias: () => "Alias",
        darlingDescription: () => "Opis",
        darlingQuote: () => "Cytat",
        darlingMoreInfo: () => "Wiƒôcej informacji",
        darlingImage: () => "Obraz",
        darlingCopied: (name: string) => `Sztuka ASCII skopiowana dla ${name}!`,
        logoView: () => "widokLogo",
        logoName: () => "Nazwa logo",
        logoMessage: (logoPath: string) => `Plik (${logoPath}) pominiƒôty, poniewa≈º nie jest szukanym typem.`,
        logoNoRootDir: () => "Nie podano katalogu g≈Ç√≥wnego do zbierania logotyp√≥w",
        logoRootDirUpdateError: (error: string) => `WystƒÖpi≈Ç b≈ÇƒÖd podczas aktualizacji plik√≥w logo: ${error}`,
        logoDisplayed: (name: string) => `Logo '${name}' zosta≈Ço wy≈õwietlone.`,
        logoCopied: (logoName: string) => `Sztuka ASCII skopiowana dla ${logoName}!`,
        logoChosen: (logo: string[]) => `Logo do wy≈õwietlenia: ${JSON.stringify(logo)}`,
        logoNotFound: () => "Logo nie znaleziono",
        logoCopyAscii: () => "Kopiuj ASCII",
        noCommentToShow: () => "Brak komentarzy do wy≈õwietlenia.",
        unknown: () => "Nieznany",
        headerOpenerFound: () => "Znaleziono otwieracz nag≈Ç√≥wka.",
        headerOpenerAndCloserFound: () => "Znaleziono otwieracz i zamykacz nag≈Ç√≥wka, kontynuowanie aktualizacji daty po kontroli poprawno≈õci.",
        headerWriteFailed: () => "Nie uda≈Ço siƒô zapisaƒá nag≈Ç√≥wka do pliku, sprawd≈∫ logi.",
        headerWriteSuccess: () => "Nag≈Ç√≥wek zapisany pomy≈õlnie.",
        headerNotFound: () => "Nie znaleziono nag≈Ç√≥wka w tym dokumencie.",
        headerInjectQuestion: () => "Nie znaleziono nag≈Ç√≥wka w tym dokumencie. Czy chcesz dodaƒá jeden?",
        headerInjectQuestionRefused: () => "Zdecydowano nie dodawaƒá nag≈Ç√≥wka do pliku.",
        morseConverted: (input: string, final: string) => `Przekonwertowano: ${input} na ${final}`,
        morseDecoded: (input: string, final: string) => `Rozkodowano: ${input} na ${final}`,
        fileLoaded: (absolutePath: string) => `Plik ${absolutePath} zosta≈Ç za≈Çadowany!`,
        fileParseError: (filePath: string, error: string) => `Zawarto≈õƒá pliku (${filePath}) nie mog≈Ça zostaƒá za≈Çadowana poprawnie. B≈ÇƒÖd: ${error}.`,
        fileRefreshed: () => "Od≈õwie≈ºanie zawarto≈õci pliku.",
        filePathUpdated: (oldFilePath: string, newFilePath: string) => `≈öcie≈ºka zosta≈Ça zaktualizowana z ${oldFilePath} na ${newFilePath}.`,
        fileUnloaded: (filePath: string) => `Plik ${filePath} zosta≈Ç usuniƒôty z pamiƒôci.`,
        fileExcludedActivationDisabled: () => "Aktywacja wy≈ÇƒÖczona, plik znajduje siƒô na li≈õcie wyklucze≈Ñ.",
        fileSaveFailed: () => "Nie uda≈Ço siƒô zapisaƒá pliku, spr√≥buj ponownie.",
        cwdUpdated: (oldCwd: string, newCwd: string) => `Bie≈ºƒÖcy katalog roboczy zaktualizowano z ${oldCwd} na ${newCwd}.`,
        cwdDoesNotExist: (cwd: string) => `Podany katalog roboczy ${cwd} nie istnieje.`,
        updatingEditionDate: () => "Aktualizacja daty edycji.",
        documentLineScanExceeded: (maxScanLength: number) => `Przeskanowano pierwsze ${maxScanLength} linie pliku, ale nie znaleziono nag≈Ç√≥wka.`,
        closedDocument: () => "Dokument jest zamkniƒôty, zatrzymywanie operacji.",
        emptyDocument: () => "Brak zawarto≈õci dokumentu do pracy.",
        brokenHeader: () => "Wykryto uszkodzony nag≈Ç√≥wek, wstrzykiwanie nowego, usu≈Ñ poprzedni.",
        extensionActivated: (moduleName: string) => `üöÄ "${moduleName}" jest teraz aktywny!`,
        helloWorldGreetingsCommand: (moduleName: string) => `Witaj ≈öwiecie z ${moduleName}!`,
        noActiveEditor: () => "Brak aktywnego pliku!",
        noFocusedEditors: () => "Brak plik√≥w w fokusie.",
        noLogoInstanceProvided: () => "Nie podano instancji losowego loga.",
        randomLogoGatheringFailed: (error: string) => `Losowe zbieranie loga nie powiod≈Ço siƒô, u≈ºycie domy≈õlnego loga, b≈ÇƒÖd: "${error}"`,
        ramdomLogoGatheringLogoUndefined: () => "Zawarto≈õƒá loga jest niezdefiniowana.",
        openFileToApplyHeader: () => "Otw√≥rz plik, aby zastosowaƒá nag≈Ç√≥wek.",
        corruptedFileMetaData: () => "Wymagane metadane pliku nie zosta≈Çy poprawnie zebrane, przerywanie.",
        messageWritten: () => "Wiadomo≈õƒá zapisana",
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string) =>
            `Witaj ≈õwiecie! Rozszerzenie tego pliku: ${fileExtension}, nazwa: ${fileName}, ≈õcie≈ºka: ${filePath}, okre≈õlony jƒôzyk: ${languageId}\n`,
        missingFileError: () => "S≈Çownik jƒôzykowy jest brakujƒÖcy, dostosowanie komentarzy jest wy≈ÇƒÖczone.",
        unknownFileStructure: () => "Struktura s≈Çownika jƒôzykowego jest nieznana, dostosowanie komentarzy jest wy≈ÇƒÖczone.",
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]) => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}.`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string) =>
            `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        identifiedLanguage: (langName: string) => `Zidentyfikowany jƒôzyk: ${langName}.`,
        errorDuringFunctionCall: (functionName: string) => `WystƒÖpi≈Ç b≈ÇƒÖd podczas wywo≈Çania funkcji (${functionName}), sprawd≈∫ logi.`,
        missingLanguageComment: () => "Komentarz jƒôzyka nie zosta≈Ç dostarczony, pomijanie przypisania.",
        getHeaderDescription: () => "Podaj opis: ",
        getHeaderTags: () => "Wprowad≈∫ tagi dla tego pliku, oddzielone przecinkami:",
        getHeaderPurpose: () => "Podaj cel pliku:",
        noProvidedCommentOptions: () => "Nie dostarczono ≈ºadnych opcji komentarza.",
        chooseSingleLineCommentOption: () => "Wybierz preferowany prefiks komentarza z poni≈ºszych opcji:",
        toMorseGetInput: (): string => "Proszƒô wprowadziƒá tekst do konwersji",
        fromMorseGetInput: (): string => "Proszƒô wprowadziƒá tekst do konwersji z",
        operationCanceled: (): string => "Operacja anulowana",
        convertedContentCli: (content: string): string => `Przekonwertowana zawarto≈õƒá: ${content}`,
        convertedContentGui: (): string => "Przekonwertowana zawarto≈õƒá: ",
        updateAbortedBecauseFileClosedSyncCancelled: () => "Aktualizacja przerwana, poniewa≈º plik jest zamkniƒôty i nie zostanie zsynchronizowany.",
        updateEditDateMissingBounds: () => "Nie mo≈ºna zaktualizowaƒá nag≈Ç√≥wka: nie znaleziono wewnƒôtrznych znacznik√≥w nag≈Ç√≥wka.",
        lastModifiedLineNotFound: () => "Nag≈Ç√≥wek nie zawiera wiersza 'Ostatnia modyfikacja' do aktualizacji.",
        lastModifiedUpdated: () => "Data 'Ostatnia modyfikacja' zosta≈Ça pomy≈õlnie zaktualizowana.",
        languageNotFound: (LanguageId: string, fileExtension: string) => `Nie uda≈Ço siƒô zidentyfikowaƒá jƒôzyka pliku tego dokumentu, languageID: ${LanguageId}, rozszerzenie pliku: ${fileExtension}`,
        jsonContent: (jsonContentString: String) => `Zawarto≈õƒá pliku JSON komentarza: ${jsonContentString}`,
        messageNotFound: (key: string) => `Nie znaleziono komunikatu '${key}'.`
    },
    "cs": {
        inputboxError: (promptText: string, err: string) => `Chyba v inputBox pro ${promptText}: ${err}`,
        quickPickError: (err: string) => `Chyba v quickPick: ${err}`,
        quickPickYes: () => "Ano",
        quickPickNo: () => "Ne",
        watermarkView: () => "zobrazen√≠Watermark",
        watermarkJsonFileInvalid: () => "Soubor JSON vodoznaku je pr√°zdn√Ω nebo neplatn√Ω",
        watermarkName: () => "N√°zev vodoznaku",
        watermarkCopyAscii: () => "Kop√≠rovat ASCII",
        watermarkZoomIn: () => "P≈ôibl√≠≈æit",
        watermarkZoomOut: () => "Odd√°lit",
        watermarkPersonDisplayed: (name: string) => `Vodoznak '${name}' zobrazen.`,
        watermarkChosen: (watermark: string[]) => `Vodoznak k zobrazen√≠: ${JSON.stringify(watermark)}`,
        watermarkNotFound: () => "Vodoznak nenalezen",
        watermarkCopied: (name: string) => `ASCII umƒõn√≠ zkop√≠rov√°no pro ${name}!`,
        watermarkAuthorName: () => "Jm√©no autora",
        darlingView: () => "zobrazen√≠Postavy",
        darlingJsonFileInvalid: () => "Soubor JSON postavy je pr√°zdn√Ω nebo neplatn√Ω",
        darlingPersonDisplayed: (name: string) => `Postava '${name}' zobrazena.`,
        darlingCopyAscii: () => "Kop√≠rovat ASCII",
        darlingZoomIn: () => "P≈ôibl√≠≈æit",
        darlingZoomOut: () => "Odd√°lit",
        darlingType: () => "Typ",
        darlingAge: () => "Vƒõk",
        darlingHeight: () => "V√Ω≈°ka",
        darlingAlias: () => "P≈ôezd√≠vka",
        darlingDescription: () => "Popis",
        darlingQuote: () => "Cit√°t",
        darlingMoreInfo: () => "V√≠ce informac√≠",
        darlingImage: () => "Obr√°zek",
        darlingCopied: (name: string) => `ASCII umƒõn√≠ zkop√≠rov√°no pro ${name}!`,
        logoView: () => "zobrazen√≠Loga",
        logoName: () => "N√°zev loga",
        logoMessage: (logoPath: string) => `Soubor (${logoPath}) byl ignorov√°n, proto≈æe nen√≠ po≈æadovan√©ho typu.`,
        logoNoRootDir: () => "Nebyl poskytnut ≈æ√°dn√Ω ko≈ôenov√Ω adres√°≈ô pro sbƒõr log",
        logoRootDirUpdateError: (error: string) => `Do≈°lo k chybƒõ p≈ôi aktualizaci soubor≈Ø loga, chyba: ${error}`,
        logoDisplayed: (name: string) => `Logo '${name}' zobrazeno.`,
        logoCopied: (logoName: string) => `ASCII umƒõn√≠ zkop√≠rov√°no pro ${logoName}!`,
        logoChosen: (logo: string[]) => `Logo k zobrazen√≠: ${JSON.stringify(logo)}`,
        logoNotFound: () => "Logo nenalezeno",
        logoCopyAscii: () => "Kop√≠rovat ASCII",
        noCommentToShow: () => "≈Ω√°dn√Ω koment√°≈ô k zobrazen√≠.",
        unknown: () => "Nezn√°m√Ω",
        headerOpenerFound: () => "Otev√≠raƒç hlaviƒçky nalezen.",
        headerOpenerAndCloserFound: () => "Otev√≠raƒç a zav√≠raƒç hlaviƒçky nalezeny, pokraƒçuje aktualizace data po kontrole spr√°vnosti.",
        headerWriteFailed: () => "Nepoda≈ôilo se zapsat hlaviƒçku do souboru, zkontrolujte protokoly.",
        headerWriteSuccess: () => "Hlaviƒçka √∫spƒõ≈°nƒõ zaps√°na.",
        headerNotFound: () => "V tomto dokumentu nebyla nalezena ≈æ√°dn√° hlaviƒçka.",
        headerInjectQuestion: () => "V tomto dokumentu nebyla nalezena ≈æ√°dn√° hlaviƒçka. Chcete ji p≈ôidat?",
        headerInjectQuestionRefused: () => "Rozhodli jste se nep≈ôid√°vat hlaviƒçku do souboru.",
        morseConverted: (input: string, final: string) => `P≈ôevedeno: ${input} na ${final}`,
        morseDecoded: (input: string, final: string) => `Dek√≥dov√°no: ${input} na ${final}`,
        fileLoaded: (absolutePath: string) => `Soubor ${absolutePath} byl naƒçten!`,
        fileParseError: (filePath: string, error: string) => `Obsah souboru (${filePath}) nelze √∫spƒõ≈°nƒõ naƒç√≠st. Chyba: ${error}.`,
        fileRefreshed: () => "Obnovov√°n√≠ obsahu souboru.",
        filePathUpdated: (oldFilePath: string, newFilePath: string) => `Cesta byla aktualizov√°na z ${oldFilePath} na ${newFilePath}.`,
        fileUnloaded: (filePath: string) => `Soubor ${filePath} byl odstranƒõn z pamƒõti.`,
        fileExcludedActivationDisabled: () => "Aktivace zak√°z√°na, soubor je na seznamu vylouƒçen√≠.",
        fileSaveFailed: () => "Nepoda≈ôilo se ulo≈æit soubor, zkuste to znovu.",
        cwdUpdated: (oldCwd: string, newCwd: string) => `Aktu√°ln√≠ pracovn√≠ adres√°≈ô byl aktualizov√°n z ${oldCwd} na ${newCwd}.`,
        cwdDoesNotExist: (cwd: string) => `Zadan√Ω pracovn√≠ adres√°≈ô ${cwd} neexistuje.`,
        updatingEditionDate: () => "Aktualizace data edice.",
        documentLineScanExceeded: (maxScanLength: number) => `Prohled√°no prvn√≠ch ${maxScanLength} ≈ô√°dk≈Ø souboru, ale hlaviƒçka nebyla nalezena.`,
        closedDocument: () => "Dokument je uzav≈ôen, operace zastaveny.",
        emptyDocument: () => "Neexistuje ≈æ√°dn√Ω obsah dokumentu k pr√°ci.",
        brokenHeader: () => "Byla detekov√°na po≈°kozen√° hlaviƒçka, vkl√°d√° se nov√°, odstra≈àte p≈ôedchoz√≠.",
        extensionActivated: (moduleName: string) => `üöÄ "${moduleName}" je nyn√≠ aktivn√≠!`,
        helloWorldGreetingsCommand: (moduleName: string) => `Hello World z ${moduleName}!`,
        noActiveEditor: () => "≈Ω√°dn√Ω aktivn√≠ soubor!",
        noFocusedEditors: () => "≈Ω√°dn√© soubory nejsou ve fokus.",
        noLogoInstanceProvided: () => "Nebyla poskytnuta instance n√°hodn√©ho loga.",
        randomLogoGatheringFailed: (error: string) => `Shroma≈æƒèov√°n√≠ n√°hodn√©ho loga selhalo, pou≈æit√≠ v√Ωchoz√≠ho loga, chyba: "${error}"`,
        ramdomLogoGatheringLogoUndefined: () => "Obsah loga nen√≠ definov√°n.",
        openFileToApplyHeader: () => "Otev≈ôete soubor, na kter√Ω chcete aplikovat hlaviƒçku.",
        corruptedFileMetaData: () => "Po≈æadovan√° metadata souboru nebyla spr√°vnƒõ shrom√°≈ædƒõna, p≈ôeru≈°en√≠.",
        messageWritten: () => "Zpr√°va zaps√°na",
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string) =>
            `Hello world! P≈ô√≠pona tohoto souboru: ${fileExtension}, n√°zev: ${fileName}, cesta: ${filePath}, urƒçen√Ω jazyk: ${languageId}\n`,
        missingFileError: () => "Slovn√≠k jazyk≈Ø chyb√≠, p≈ôizp≈Øsoben√≠ koment√°≈ô≈Ø je deaktivov√°no.",
        unknownFileStructure: () => "Struktura slovn√≠ku jazyk≈Ø je nezn√°m√°, p≈ôizp≈Øsoben√≠ koment√°≈ô≈Ø je deaktivov√°no.",
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]) => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}.`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string) =>
            `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        identifiedLanguage: (langName: string) => `Identifikovan√Ω jazyk: ${langName}.`,
        errorDuringFunctionCall: (functionName: string) => `Nƒõco se pokazilo bƒõhem vol√°n√≠ funkce (${functionName}), zkontrolujte logy.`,
        missingLanguageComment: () => "Koment√°≈ô jazyka nebyl poskytnut, p≈ôi≈ôazen√≠ p≈ôeskoƒçeno.",
        getHeaderDescription: () => "Zadejte popis: ",
        getHeaderTags: () => "Zadejte tagy pro tento soubor, oddƒõlen√© ƒç√°rkou:",
        getHeaderPurpose: () => "Zadejte √∫ƒçel souboru:",
        noProvidedCommentOptions: () => "Nebyly poskytnuty ≈æ√°dn√© mo≈ænosti koment√°≈ôe.",
        chooseSingleLineCommentOption: () => "Vyberte preferovan√Ω prefix koment√°≈ôe z n√≠≈æe uveden√Ωch mo≈ænost√≠:",
        toMorseGetInput: (): string => "Zadejte pros√≠m text k p≈ôevodu",
        fromMorseGetInput: (): string => "Zadejte pros√≠m text k p≈ôevodu z",
        operationCanceled: (): string => "Operace byla zru≈°ena",
        convertedContentCli: (content: string): string => `P≈ôeveden√Ω obsah: ${content}`,
        convertedContentGui: (): string => "P≈ôeveden√Ω obsah: ",
        updateAbortedBecauseFileClosedSyncCancelled: () => "Aktualizace p≈ôeru≈°ena, proto≈æe soubor je uzav≈ôen a nebude synchronizov√°n.",
        updateEditDateMissingBounds: () => "Nelze aktualizovat hlaviƒçku: intern√≠ markery hlaviƒçky nebyly nalezeny.",
        lastModifiedLineNotFound: () => "Hlaviƒçka neobsahuje ≈ô√°dek 'Posledn√≠ √∫prava' k aktualizaci.",
        lastModifiedUpdated: () => "Datum 'Posledn√≠ √∫prava' bylo √∫spƒõ≈°nƒõ aktualizov√°no.",
        languageNotFound: (LanguageId: string, fileExtension: string) => `Jazyk souboru tohoto dokumentu nelze identifikovat, languageID: ${LanguageId}, p≈ô√≠pona souboru: ${fileExtension}`,
        jsonContent: (jsonContentString: String) => `Obsah JSON souboru koment√°≈ô≈Ø: ${jsonContentString}`,
        messageNotFound: (key: string) => `Zpr√°va '${key}' nenalezena.`
    },
    "hu": {
        inputboxError: (promptText: string, err: string) => `Hiba az inputBox-n√°l a(z) ${promptText} eset√©n: ${err}`,
        quickPickError: (err: string) => `Hiba a quickPick-n√°l: ${err}`,
        quickPickYes: () => "Igen",
        quickPickNo: () => "Nem",
        watermarkView: () => "v√≠zjelN√©zet",
        watermarkJsonFileInvalid: () => "A v√≠zjel JSON f√°jl √ºres vagy √©rv√©nytelen",
        watermarkName: () => "V√≠zjel neve",
        watermarkCopyAscii: () => "M√°sol√°s ASCII",
        watermarkZoomIn: () => "Nagy√≠t√°s",
        watermarkZoomOut: () => "Kicsiny√≠t√©s",
        watermarkPersonDisplayed: (name: string) => `V√≠zjel '${name}' megjelen√≠tve.`,
        watermarkChosen: (watermark: string[]) => `Megjelen√≠tend≈ë v√≠zjel: ${JSON.stringify(watermark)}`,
        watermarkNotFound: () => "V√≠zjel nem tal√°lhat√≥",
        watermarkCopied: (name: string) => `ASCII m≈±v√©szet m√°solva ${name} sz√°m√°ra!`,
        watermarkAuthorName: () => "Szerz≈ë neve",
        darlingView: () => "karakterN√©zet",
        darlingJsonFileInvalid: () => "A karakter JSON f√°jl √ºres vagy √©rv√©nytelen",
        darlingPersonDisplayed: (name: string) => `Karakter '${name}' megjelen√≠tve.`,
        darlingCopyAscii: () => "M√°sol√°s ASCII",
        darlingZoomIn: () => "Nagy√≠t√°s",
        darlingZoomOut: () => "Kicsiny√≠t√©s",
        darlingType: () => "T√≠pus",
        darlingAge: () => "Kor",
        darlingHeight: () => "Magass√°g",
        darlingAlias: () => "Becen√©v",
        darlingDescription: () => "Le√≠r√°s",
        darlingQuote: () => "Id√©zet",
        darlingMoreInfo: () => "Tov√°bbi info",
        darlingImage: () => "K√©p",
        darlingCopied: (name: string) => `ASCII m≈±v√©szet m√°solva ${name} sz√°m√°ra!`,
        logoView: () => "logoN√©zet",
        logoName: () => "Log√≥ neve",
        logoMessage: (logoPath: string) => `F√°jl (${logoPath}) figyelmen k√≠v√ºl hagyva, mert nem a keresett t√≠pus.`,
        logoNoRootDir: () => "Nincs megadva gy√∂k√©rk√∂nyvt√°r a log√≥k gy≈±jt√©s√©hez",
        logoRootDirUpdateError: (error: string) => `Hiba t√∂rt√©nt a log√≥f√°jlok friss√≠t√©se k√∂zben, hiba: ${error}`,
        logoDisplayed: (name: string) => `Log√≥ '${name}' megjelen√≠tve.`,
        logoCopied: (logoName: string) => `ASCII m≈±v√©szet m√°solva ${logoName} sz√°m√°ra!`,
        logoChosen: (logo: string[]) => `Megjelen√≠tend≈ë log√≥: ${JSON.stringify(logo)}`,
        logoNotFound: () => "Log√≥ nem tal√°lhat√≥",
        logoCopyAscii: () => "M√°sol√°s ASCII",
        noCommentToShow: () => "Nincs megjelen√≠thet≈ë komment.",
        unknown: () => "Ismeretlen",
        headerOpenerFound: () => "Fejl√©c nyit√≥ megtal√°lva.",
        headerOpenerAndCloserFound: () => "Fejl√©c nyit√≥ √©s z√°r√≥ megtal√°lva, a d√°tum friss√≠t√©se k√∂vetkezik ellen≈ërz√©s ut√°n.",
        headerWriteFailed: () => "Nem siker√ºlt √≠rni a fejl√©cet a f√°jlba, ellen≈ërizze a napl√≥kat.",
        headerWriteSuccess: () => "Fejl√©c sikeresen √≠rva.",
        headerNotFound: () => "Nem tal√°lhat√≥ fejl√©c ebben a dokumentumban.",
        headerInjectQuestion: () => "Nem tal√°lhat√≥ fejl√©c ebben a dokumentumban. Szeretne hozz√°adni egyet?",
        headerInjectQuestionRefused: () => "√ögy d√∂nt√∂tt, hogy nem ad hozz√° fejl√©cet a f√°jlhoz.",
        morseConverted: (input: string, final: string) => `√Åtalak√≠tva: ${input} -> ${final}`,
        morseDecoded: (input: string, final: string) => `Dek√≥dolva: ${input} -> ${final}`,
        fileLoaded: (absolutePath: string) => `A f√°jl ${absolutePath} bet√∂ltve!`,
        fileParseError: (filePath: string, error: string) => `A f√°jl tartalma (${filePath}) nem t√∂lthet≈ë be sikeresen. Hiba: ${error}.`,
        fileRefreshed: () => "F√°jl tartalm√°nak friss√≠t√©se.",
        filePathUpdated: (oldFilePath: string, newFilePath: string) => `Az √∫tvonal friss√≠tve lett: ${oldFilePath} -> ${newFilePath}.`,
        fileUnloaded: (filePath: string) => `A f√°jl ${filePath} elt√°vol√≠tva a mem√≥ri√°b√≥l.`,
        fileExcludedActivationDisabled: () => "Az aktiv√°l√°s letiltva, a f√°jl a kiz√°r√°si list√°n van.",
        fileSaveFailed: () => "A f√°jl ment√©se sikertelen, pr√≥b√°lja √∫jra.",
        cwdUpdated: (oldCwd: string, newCwd: string) => `A munkak√∂nyvt√°r friss√≠tve lett: ${oldCwd} -> ${newCwd}.`,
        cwdDoesNotExist: (cwd: string) => `A megadott munkak√∂nyvt√°r ${cwd} nem l√©tezik.`,
        updatingEditionDate: () => "Kiad√°s d√°tum√°nak friss√≠t√©se.",
        documentLineScanExceeded: (maxScanLength: number) => `Az els≈ë ${maxScanLength} sor beolvasva, de nem tal√°lhat√≥ fejl√©c.`,
        closedDocument: () => "A dokumentum z√°rva, a m≈±veletek le√°ll√≠tva.",
        emptyDocument: () => "Nincs dokumentumtartalom, amin dolgozni lehetne.",
        brokenHeader: () => "S√©r√ºlt fejl√©c √©szlelve, √∫j besz√∫r√°sa folyamatban, k√©rj√ºk t√°vol√≠tsa el az el≈ëz≈ët.",
        extensionActivated: (moduleName: string) => `üöÄ A(z) "${moduleName}" modul most akt√≠v!`,
        helloWorldGreetingsCommand: (moduleName: string) => `Hello World a ${moduleName}-b√≥l!`,
        noActiveEditor: () => "Nincs akt√≠v f√°jl!",
        noFocusedEditors: () => "Nincsenek f√≥kuszban l√©v≈ë f√°jlok.",
        noLogoInstanceProvided: () => "Nem lett log√≥ randomiz√°l√≥ p√©ld√°ny megadva.",
        randomLogoGatheringFailed: (error: string) => `A v√©letlenszer≈± log√≥gy≈±jt√©s sikertelen, alap√©rtelmezett log√≥ haszn√°lata, hiba: "${error}"`,
        ramdomLogoGatheringLogoUndefined: () => "A log√≥ tartalma nem defini√°lt.",
        openFileToApplyHeader: () => "Nyisson meg egy f√°jlt a fejl√©c alkalmaz√°s√°hoz.",
        corruptedFileMetaData: () => "A sz√ºks√©ges f√°jl metaadatok nem lettek megfelel≈ëen √∂sszegy≈±jtve, megszak√≠t√°s.",
        messageWritten: () => "√úzenet √≠rva",
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string) =>
            `Hello world! A f√°jl kiterjeszt√©se: ${fileExtension}, neve: ${fileName}, √∫tvonala: ${filePath}, nyelv: ${languageId}\n`,
        missingFileError: () => "A nyelvi sz√≥t√°r hi√°nyzik, a komment alkalmazkod√°s le van tiltva.",
        unknownFileStructure: () => "A nyelvi sz√≥t√°r szerkezete ismeretlen, a komment alkalmazkod√°s le van tiltva.",
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]) => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}.`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string) =>
            `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        identifiedLanguage: (langName: string) => `Azonos√≠tott nyelv: ${langName}.`,
        errorDuringFunctionCall: (functionName: string) => `Hiba t√∂rt√©nt a ${functionName} f√ºggv√©ny h√≠v√°sakor, ellen≈ërizze a napl√≥kat.`,
        missingLanguageComment: () => "A nyelvi komment nem lett megadva, a hozz√°rendel√©s kihagyva.",
        getHeaderDescription: () => "Adjon meg egy le√≠r√°st: ",
        getHeaderTags: () => "Adja meg a f√°jl c√≠mk√©it, vessz≈ëvel elv√°lasztva:",
        getHeaderPurpose: () => "Adja meg a f√°jl c√©lj√°t:",
        noProvidedCommentOptions: () => "Nincsenek megadott komment opci√≥k.",
        chooseSingleLineCommentOption: () => "K√©rj√ºk, v√°lassza ki a k√≠v√°nt komment prefixet az al√°bbi lehet≈ës√©gek k√∂z√ºl:",
        toMorseGetInput: (): string => "K√©rj√ºk, adja meg az √°talak√≠tand√≥ sz√∂veget",
        fromMorseGetInput: (): string => "K√©rj√ºk, adja meg a konvert√°land√≥ sz√∂veget innen",
        operationCanceled: (): string => "M≈±velet megszak√≠tva",
        convertedContentCli: (content: string): string => `√Åtalak√≠tott tartalom: ${content}`,
        convertedContentGui: (): string => "√Åtalak√≠tott tartalom: ",
        updateAbortedBecauseFileClosedSyncCancelled: () => "A friss√≠t√©s megszak√≠tva, mert a f√°jl z√°rva van √©s nem lesz szinkroniz√°lva.",
        updateEditDateMissingBounds: () => "Nem siker√ºlt friss√≠teni a fejl√©cet: a bels≈ë jel√∂l≈ëk nem tal√°lhat√≥k.",
        lastModifiedLineNotFound: () => "A fejl√©c nem tartalmaz 'Utols√≥ m√≥dos√≠t√°s' sort a friss√≠t√©shez.",
        lastModifiedUpdated: () => "Az 'Utols√≥ m√≥dos√≠t√°s' d√°tum sikeresen friss√≠tve.",
        languageNotFound: (LanguageId: string, fileExtension: string) => `A dokumentum nyelve nem azonos√≠that√≥, languageID: ${LanguageId}, f√°jlkiterjeszt√©s: ${fileExtension}`,
        jsonContent: (jsonContentString: String) => `A komment JSON f√°jl tartalma: ${jsonContentString}`,
        messageNotFound: (key: string) => `'${key}' √ºzenet nem tal√°lhat√≥.`
    }
};
