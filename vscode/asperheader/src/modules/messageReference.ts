/**
 * @file messageReference.ts
 * @brief Comprehensive multilingual message repository with advanced localization support
 * @author Henry Letellier
 * @version 1.0.8
 * @date 2025-10-03
 * @copyright (c) 2025 Asperguide - All rights reserved
 * 
 * @details This module serves as the authoritative multilingual message repository for the entire
 * AsperHeader extension ecosystem. It implements a sophisticated internationalization
 * framework that provides consistent, culturally-appropriate messaging across all user
 * interfaces, error conditions, and interactive elements while supporting dynamic
 * parameter interpolation and context-aware message generation.
 * 
 * @section Architecture Localization Architecture
 * The module implements a multi-layered localization system with the following components:
 * 
 * @subsection MultiLanguageSupport Multi-Language Support
 * - Complete translations for 15+ languages including English, French, Italian, Spanish, German, Japanese, Korean, Chinese (Simplified & Traditional), Russian, Portuguese, Turkish, Polish, Czech, and Hungarian
 * - Standardized message key consistency across all language variants
 * - Professional native speaker translations with technical domain expertise
 * 
 * @subsection FunctionBasedMessages Function-Based Message System  
 * - Dynamic parameter interpolation with full TypeScript type safety
 * - Named parameter substitution with `{paramName}` syntax support
 * - Automatic type conversion and locale-aware formatting
 * - Security-conscious parameter escaping for HTML contexts
 * 
 * @subsection CulturalAdaptation Cultural Adaptation Framework
 * - Language-specific formatting rules and cultural considerations
 * - Context-sensitive plural forms for different linguistic structures
 * - Locale-appropriate number, currency, and date formatting
 * - Right-to-left (RTL) language preparation for future expansion
 * 
 * @subsection ExtensibilityFramework Extensible Plugin Architecture
 * - Modular design enabling seamless addition of new languages
 * - Standardized message key interface for consistent expansion
 * - Automated validation tools for translation completeness
 * - Hot-reload capability for development and testing scenarios
 * 
 * @section LanguageMatrix Supported Language Matrix
 * @subsection PrimaryLanguages Primary Languages (100% Coverage)
 * - **English (en)**: Primary reference language - complete message coverage with American English conventions
 * - **French (fr)**: Professional translation with French cultural adaptations and technical terminology
 * - **Italian (it)**: Complete localization with Italian conventions and technical domain expertise
 * - **Spanish (es)**: Full Spanish translation with Latin American and European Spanish considerations
 * - **German (de)**: Comprehensive German localization with technical precision and formal register
 * 
 * @subsection AsianLanguages Asian Languages (Full Support)
 * - **Japanese (ja)**: Native Japanese translation with proper honorific usage and technical terminology
 * - **Korean (ko)**: Complete Korean localization with appropriate formality levels
 * - **Chinese Simplified (zh-cn)**: Mainland Chinese translation with simplified characters
 * - **Chinese Traditional (zh-tw)**: Traditional Chinese for Taiwan and Hong Kong regions
 * 
 * @subsection EuropeanLanguages Additional European Languages
 * - **Russian (ru)**: Full Cyrillic script support with Russian technical conventions
 * - **Portuguese (pt-br)**: Brazilian Portuguese with regional adaptations
 * - **Turkish (tr)**: Complete Turkish localization with agglutinative language considerations
 * - **Polish (pl)**: Polish translation with complex grammar and case system support
 * - **Czech (cs)**: Czech localization with Slavic language characteristics
 * - **Hungarian (hu)**: Hungarian translation with unique Finno-Ugric linguistic features
 * 
 * @section MessageClassification Message Classification and Organization
 * Messages are systematically organized into functional categories for maintainability:
 * 
 * @subsection UserInterfaceMessages User Interface Messages
 * - Dialog prompts and confirmation dialogs (`quickPickYes`, `quickPickNo`)
 * - Button labels and interactive element text (`copyAscii`, `zoomIn`, `zoomOut`)
 * - Input field prompts and validation messages (`getHeaderDescription`, `getHeaderTags`)
 * - Menu items and command descriptions
 * 
 * @subsection SystemOperationMessages System Operation Messages
 * - File I/O operations (`fileLoaded`, `fileParseError`, `fileSaveFailed`)
 * - Configuration management and settings validation
 * - Directory and workspace management (`cwdUpdated`, `cwdDoesNotExist`)
 * - Process lifecycle and state management
 * 
 * @subsection HeaderManagementMessages Header Management Messages
 * - Template generation and metadata handling (`headerOpenerFound`, `headerWriteSuccess`)
 * - Content creation and injection workflows (`headerInjectQuestion`)
 * - Date and timestamp management (`lastModifiedUpdated`)
 * - Header validation and integrity checks (`brokenHeader`)
 * 
 * @subsection ErrorReportingMessages Error Reporting and Diagnostics
 * - Comprehensive error messages with actionable guidance
 * - Input validation errors (`inputboxError`, `quickPickError`)
 * - File operation failures with diagnostic information
 * - System state errors and recovery suggestions
 * 
 * @subsection FeatureContentMessages Specialized Feature Messages
 * - Watermark display and management (`watermarkPersonDisplayed`, `watermarkCopied`)
 * - Character showcase functionality (`darlingPersonDisplayed`, `darlingCopied`)
 * - Logo randomization and display (`logoDisplayed`, `logoChosen`)
 * - ASCII art handling and clipboard operations
 * 
 * @subsection ExtensionLifecycleMessages Extension Lifecycle Messages
 * - Activation and initialization (`extensionActivated`)
 * - Deactivation and cleanup procedures
 * - Status updates and operational notifications
 * - Version and compatibility information
 * 
 * @subsection DevelopmentSupportMessages Development Support Messages
 * - Debug output and diagnostic information (`arrayNodeContent`)
 * - Development-oriented logging and tracing
 * - Performance metrics and optimization data
 * - Testing and validation support messages
 * 
 * @section TechnicalImplementation Technical Implementation Details
 * 
 * @subsection FunctionBasedDesign Function-Based Architecture
 * Each message is implemented as a function to enable:
 * - Dynamic parameter injection with compile-time type checking
 * - Runtime parameter validation and sanitization
 * - Contextual message generation based on application state
 * - Deferred execution for performance optimization
 * 
 * @subsection TypeSafetySystem TypeScript Type Safety System
 * - Strongly-typed parameter interfaces ensure consistency across languages
 * - Generic type parameters for flexible message function signatures
 * - Compile-time validation of parameter count and types
 * - Runtime type assertion for development safety
 * 
 * @subsection PerformanceOptimization Performance Optimization Strategies
 * - Lazy evaluation prevents unnecessary message generation
 * - Efficient parameter handling with minimal object allocation
 * - Message caching for frequently accessed strings
 * - Tree-shaking support for production bundle optimization
 * 
 * @subsection MemoryManagement Memory Management
 * - Optimal memory usage through selective message loading
 * - Garbage collection friendly implementation patterns
 * - Minimal closure overhead in message functions
 * - Language pack loading on demand for memory efficiency
 * 
 * @subsection ErrorResilienceFramework Error Resilience Framework
 * - Graceful fallback to English for missing translations
 * - Runtime detection of incomplete language packs
 * - Error logging for missing message keys during development
 * - Automatic recovery from corrupted message data
 * 
 * @section ParameterInterpolation Parameter Interpolation System
 * 
 * @subsection NamedParameters Named Parameter Substitution
 * - Template syntax: `{paramName}` for clear parameter identification
 * - Case-sensitive parameter matching with validation
 * - Nested object property access support: `{object.property}`
 * - Default value specification: `{param|defaultValue}`
 * 
 * @subsection PositionalArguments Positional Parameter System
 * - Sequential parameter replacement for simple message templates
 * - Zero-indexed positional parameters: `{0}`, `{1}`, etc.
 * - Mixed named and positional parameter support
 * - Overflow protection for parameter count mismatches
 * 
 * @subsection TypeConversionSystem Type Conversion and Formatting
 * - Automatic type coercion for string, number, and boolean values
 * - Date and time formatting with locale-aware patterns
 * - Currency formatting with regional currency symbols
 * - Percentage and decimal formatting with locale rules
 * 
 * @subsection SecurityEscaping Security-Conscious Parameter Escaping
 * - HTML entity escaping for web view contexts
 * - URL encoding for parameter values in URLs
 * - JSON escape sequences for data serialization
 * - SQL injection prevention for database contexts
 * 
 * @subsection PluralizationRules Context-Sensitive Pluralization
 * - Language-specific plural form rules (singular, plural, zero, few, many)
 * - Cardinal and ordinal number pluralization support
 * - Gender-sensitive pluralization for applicable languages
 * - Custom pluralization rules for domain-specific terms
 * 
 * @subsection LocaleFormatting Locale-Appropriate Formatting
 * - Number formatting with locale-specific separators and grouping
 * - Currency display with proper symbol placement and precision
 * - Date and time formatting following regional conventions
 * - Unit conversion and display for measurements
 * 
 * Quality Assurance Process:
 * - **Native Speaker Review**: All translations reviewed by native speakers
 * - **Technical Accuracy**: Technical terminology validated by subject matter experts
 * - **Cultural Sensitivity**: Messages adapted for cultural appropriateness
 * - **Consistency Checking**: Automated validation of message key completeness
 * - **Context Validation**: Messages tested in actual usage contexts
 * 
 * Integration Framework:
 * This module provides the foundation for all user-facing text throughout:
 * - **Core Extension**: Primary extension interfaces and workflows
 * - **Configuration System**: Settings descriptions and validation messages
 * - **Interactive Features**: Webview content and user interaction prompts
 * - **Error Handling**: Comprehensive error reporting and diagnostic messages
 * - **Development Tools**: Debug output and development-oriented information
 * 
 * @example Message structure and usage:
 * ```typescript
 * const messages = {
 *   en: {
 *     fileLoaded: (filename: string) => `Successfully loaded ${filename}`,
 *     operationComplete: (count: number, duration: string) => 
 *       `Processed ${count} files in ${duration}`
 *   },
 *   fr: {
 *     fileLoaded: (filename: string) => `Fichier ${filename} chargé avec succès`,
 *     operationComplete: (count: number, duration: string) => 
 *       `${count} fichiers traités en ${duration}`
 *   }
 * };
 * ```
 * 
 * @example Advanced localization features:
 * ```typescript
 * // Context-aware pluralization
 * itemCount: (count: number) => count === 1 ? "1 item" : `${count} items`,
 * 
 * // Cultural adaptations
 * dateFormat: (date: Date) => date.toLocaleDateString('en-US'),
 * 
 * // Technical terminology
 * configurationError: (setting: string, value: any) => 
 *   `Invalid configuration for ${setting}: ${value}`
 * ```
 */

/**
 * @brief Complete message dictionary for all supported languages with type-safe function interfaces
 * @export Exported for use by the MessageProvider system and extension components
 * 
 * @details Central repository of all localized messages used throughout the AsperHeader extension.
 * Each language is represented as a nested object where message keys map to functions
 * that generate the appropriate localized string. The function-based architecture enables
 * sophisticated localization features while maintaining type safety and performance.
 * 
 * @section FunctionBasedMessaging Function-Based Message Architecture
 * Function-based messages provide several key advantages:
 * - **Dynamic Parameter Interpolation**: Contextual information injection at runtime
 * - **Type-Safe Parameter Passing**: Full TypeScript type checking and IntelliSense support
 * - **Consistent Message Formatting**: Uniform parameter handling across all languages
 * - **Runtime Message Generation**: Complex conditional and contextual message creation
 * - **Performance Optimization**: Lazy evaluation and parameter validation
 * 
 * @section LanguageSupport Comprehensive Language Support
 * @subsection PrimaryLanguages Primary Language Support (100% Coverage)
 * - **en**: English (primary) - Complete reference implementation with American English conventions
 * - **fr**: French - Professional translation with French linguistic and cultural adaptations
 * - **it**: Italian - Complete Italian localization with proper grammatical structures
 * - **es**: Spanish - Full Spanish translation covering Latin American and European variants
 * - **de**: German - Comprehensive German localization with technical precision
 * 
 * @subsection GlobalLanguages Extended Global Language Support
 * - **ja**: Japanese - Native Japanese with proper honorifics and technical terminology
 * - **ko**: Korean - Complete Korean with appropriate formality levels
 * - **zh-cn**: Chinese Simplified - Mainland Chinese with simplified character set
 * - **zh-tw**: Chinese Traditional - Traditional Chinese for Taiwan/Hong Kong regions
 * - **ru**: Russian - Full Cyrillic support with Russian technical conventions
 * - **pt-br**: Brazilian Portuguese - Regional Brazilian adaptations
 * - **tr**: Turkish - Turkish localization with agglutinative language considerations
 * - **pl**: Polish - Polish with complex grammar and case system support
 * - **cs**: Czech - Czech localization with Slavic linguistic characteristics
 * - **hu**: Hungarian - Hungarian with unique Finno-Ugric language features
 * 
 * @section UsagePatterns Usage Patterns and Examples
 * @code{.typescript}
 * // Basic parameter interpolation
 * messages.en.fileLoaded("/path/to/file")          // "File /path/to/file loaded!"
 * messages.fr.fileLoaded("/chemin/vers/fichier")   // "Fichier /chemin/vers/fichier chargé !"
 * 
 * // Complex multi-parameter messages
 * messages.en.sayHelloWorldResponse(".ts", "main.ts", "/src/main.ts", "typescript")
 * // "Hello world! This file's extension is: .ts, it's name is: main.ts..."
 * 
 * // Error handling with contextual information
 * messages.en.fileParseError("/invalid.json", "SyntaxError: Unexpected token")
 * // "The file content (/invalid.json) could not be loaded successfully. Error: SyntaxError..."
 * @endcode
 * 
 * @section MessageCategories Functional Message Categories
 * Messages are systematically organized into the following categories:
 * 
 * @subsection IOOperations Input/Output Operations
 * - File loading, saving, and parsing operations (`fileLoaded`, `fileParseError`, `fileSaveFailed`)
 * - Directory and workspace management (`cwdUpdated`, `filePathUpdated`)
 * - Configuration file handling and validation
 * 
 * @subsection UserInterface User Interface Interactions
 * - Dialog prompts and confirmations (`quickPickYes`, `quickPickNo`, `headerInjectQuestion`)
 * - Input field labels and validation messages (`getHeaderDescription`, `getHeaderTags`)
 * - Button labels and interactive element text (`copyAscii`, `zoomIn`, `zoomOut`)
 * 
 * @subsection HeaderManagement Header Management Operations
 * - Header creation, updating, and validation (`headerOpenerFound`, `headerWriteSuccess`)
 * - Template injection and refresh workflows (`headerInjectQuestion`, `lastModifiedUpdated`)
 * - Metadata extraction and timestamp management (`updatingEditionDate`)
 * 
 * @subsection FeatureDisplays Specialized Feature Operations
 * - Watermark display and clipboard operations (`watermarkPersonDisplayed`, `watermarkCopied`)
 * - Character showcase functionality (`darlingPersonDisplayed`, `darlingCopied`)
 * - Logo randomization and display management (`logoDisplayed`, `logoChosen`)
 * - ASCII art processing and user interactions
 * 
 * @subsection ErrorHandling Error Handling and Diagnostics
 * - File operation errors with actionable guidance (`fileSaveFailed`, `fileParseError`)
 * - Input validation failures (`inputboxError`, `quickPickError`)
 * - System state errors and recovery procedures (`closedDocument`, `emptyDocument`)
 * - Language and configuration detection failures (`languageNotFound`, `missingFileError`)
 * 
 * @subsection ExtensionLifecycle Extension Lifecycle Management
 * - Activation and initialization notifications (`extensionActivated`, `helloWorldGreetingsCommand`)
 * - Status updates and operational feedback (`messageWritten`, `extensionActivated`)
 * - Resource management and cleanup procedures
 * 
 * @subsection DevelopmentUtilities Development and Debugging Support
 * - Debug output and diagnostic information (`arrayNodeContent`, `inputArgs`)
 * - Performance monitoring and optimization data
 * - Development-time logging and error tracking (`errorDuringFunctionCall`)
 * 
 * @section TypeSafetyContract Type Safety Contract
 * @note All message functions must maintain consistent parameter signatures across languages
 * @note Parameter types should be explicitly defined in TypeScript for compile-time validation
 * @note Runtime parameter validation should be implemented for production safety
 * 
 * @section FallbackMechanism Fallback and Error Handling
 * @note Missing translations automatically fall back to English through the MessageProvider system
 * @note Undefined message keys return a standardized error message with the missing key identifier
 * @note Language pack validation occurs during extension initialization for early error detection
 * 
 * @since 1.0.0
 * @version 1.0.8
 * @see MessageProvider For the primary interface to access these messages
 * @see Logger For integration with the extension's logging system
 */
export const messages: Record<string, Record<string, (...args: any[]) => string>> = {
    "en": {
        alternateFilePathUpdated: (oldFilePath: string, newFilePath: string): string => `The alternate path has been updated from ${oldFilePath} to ${newFilePath}.`,
        alternateLogoDirectoryNotFound: (alternateRootDirectory: string, error: string = "Not Provided"): string => `The alternate logo root directory '${alternateRootDirectory}' was not found, error: '${error}'.`,
        alternateLogoDirectoryNotProvided: (): string => `No alternate logo directory provided.`,
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]): string => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}.`,
        brokenHeader: (): string => "Broken header detected, injecting new one, please remove the previous one.",
        cacheAlreadyLoaded: (): string => "The cache is already loaded, returning stored instance.",
        chooseSingleLineCommentOption: (): string => "Please select your preferred comment prefix from the options below:",
        closedDocument: (): string => "The document is closed, stopping operations.",
        convertedContentCli: (content: string): string => `Converted content: ${content}`,
        convertedContentGui: (): string => "Converted content: ",
        corruptedFileMetaData: (): string => "The required file meta data appears to not have been gathered correctly, aborting.",
        cwdDoesNotExist: (cwd: string): string => `The provided current working directory ${cwd} does not exist.`,
        cwdUpdated: (oldCwd: string, newCwd: string): string => `The current working directory referential has been updated from ${oldCwd} to ${newCwd}.`,
        darlingAge: (): string => "Age",
        darlingAlias: (): string => "Alias",
        darlingCopied: (name: string): string => `ASCII art copied for ${name}!`,
        darlingCopyAscii: (): string => "Copy ASCII",
        darlingDescription: (): string => "Description",
        darlingHeight: (): string => "Height",
        darlingImage: (): string => "Image",
        darlingJsonFileInvalid: (): string => "Darling JSON file is empty or invalid",
        darlingMoreInfo: (): string => "More info",
        darlingPersonDisplayed: (name: string): string => `Character '${name}' displayed.`,
        darlingQuote: (): string => "Quote",
        darlingType: (): string => "Type",
        darlingView: (): string => "darlingView",
        darlingZoomIn: (): string => "Zoom In",
        darlingZoomOut: (): string => "Zoom Out",
        documentLineScanExceeded: (maxScanLength: number): string => `Scanned the first ${maxScanLength} line(s) of the file but no header was found.`,
        emptyDocument: (): string => "There is no document body to work with.",
        errorDuringFunctionCall: (functionName: string): string => `Something went wrong during the function (${functionName}) call, check logs for more info.`,
        extensionActivated: (moduleName: string): string => `🚀 "${moduleName}" is now active!`,
        fileExcludedActivationDisabled: (): string => "Activation disabled, the file is in the activation exclusion list.",
        fileLength: (filePath: string, fileLength: number): string => `File: '${filePath}', length: ${fileLength} bytes.`,
        fileLoaded: (absolutePath: string): string => `File ${absolutePath} loaded!`,
        fileLoadError: (filePath: string, error: string = "Notprovided"): string => `Failed to load file: '${filePath}'. Error: ${error}.`,
        fileNotFound: (filePath: string): string => `File not found: ${filePath}`,
        fileParseError: (filePath: string, error: string): string => `The file content (${filePath}) could not be loaded successfully. Error: ${error}.`,
        filepathPresenceCheck: (filePath: string): string => `Checking filepath presence: ${filePath}`,
        filePathProcessing: (filepath: string): string => `Processing file path: '${filepath}'.`,
        filePathUpdated: (oldFilePath: string, newFilePath: string): string => `The path has been updated from ${oldFilePath} to ${newFilePath}.`,
        fileRefreshed: (): string => "Refreshing file content.",
        fileSaveFailed: (): string => "Failed to save the file, please try saving it again.",
        fileUnloaded: (filePath: string): string => `File ${filePath} unloaded from memory`,
        foundAlternateFilePathToLoad: (alternateFilePath: string) => `The alternate file path to load is set to '${alternateFilePath}'.`,
        foundAlternateLogoRootDir: (rootDir: string): string => `The current alternate logo root directory is: '${rootDir}'.`,
        foundCurrentWorkingDirectory: (cwd: string): string => `The current working directory has been set to '${cwd}'.`,
        foundFilePath: (filePath: string): string => `The provided file path exists: '${filePath}'.`,
        foundFilePathToLoad: (filePath: string) => `The file path to load is set to '${filePath}'.`,
        foundFocusEditor: (): string => "There is an editor in focus",
        foundLanguageComment: (): string => "Language comment file is present",
        foundLogoInstance: (): string => "There is a logo instance that has been provided.",
        foundLogoRootDir: (rootDir: string): string => `The current logo root directory is: '${rootDir}'.`,
        foundNewLine: (newLineType: string): string => `The new determined line is '${newLineType}'`,
        foundWorkingDirectory: (): string => "The provided current workign directory exists",
        fromMorseGetInput: (): string => "Please enter the text to convert from",
        getHeaderDescription: (): string => "Please provide a description: ",
        getHeaderPurpose: (): string => "Please provide the purpose of the file:",
        getHeaderTags: (): string => "Please enter the tags for this file, separated by commas:",
        headerInjectQuestion: (): string => "No header was found in this document. Would you like to add one?",
        headerInjectQuestionRefused: (): string => "You decided not to add the a header to the file.",
        headerNotFound: (): string => "No header was found in this document.",
        headerOpenerAndCloserFound: (): string => "Header opener and closer found, proceeding to date update after sanity check.",
        headerOpenerFound: (): string => "Header opener found.",
        headerWriteFailed: (): string => "Failed to write the header to the file, check the logs.",
        headerWriteSuccess: (): string => "Header written successfully.",
        helloWorldGreetingsCommand: (moduleName: string): string => `Hello World from ${moduleName}!`,
        identifiedLanguage: (langName: string): string => `Identified language: ${langName}.`,
        inFunction: (functionName: string, className: string = "Not specified") => `In function: '${functionName}' from class: '${className}'`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string): string => `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        inputboxError: (promptText: string, err: string): string => `Error in inputBox for ${promptText}: ${err}`,
        jsonContent: (jsonContentString: String) => `The content of the comment json file: ${jsonContentString}`,
        languageNotFound: (LanguageId: string, fileExtension: string): string => `The file language of this document could not be identified, languageID: ${LanguageId}, fileExtention: ${fileExtension}`,
        lastModifiedLineNotFound: (): string => "The header does not contain a 'Last Modified' line to update.",
        lastModifiedUpdated: (): string => "Last Modified' date has been updated successfully.",
        logoChosen: (logo: string[]): string => `Logo to display: ${JSON.stringify(logo)}`,
        logoCopied: (logoName: string): string => `ASCII art copied for ${logoName}!`,
        logoCopyAscii: (): string => "Copy ASCII",
        logoDisplayed: (name: string): string => `Logo '${name}' displayed.`,
        logoMessage: (logoPath: string): string => `File (${logoPath}) ignored because it is not the type we are looking for.`,
        logoName: (): string => "Logo name",
        logoNoRootDir: (): string => "No root directory was provided for gathering the logos",
        logoNotFound: (): string => "Logo not found",
        logoRootDirUpdateError: (error: string = "Not provided"): string => `An error occurred during the update of the logo files, error: ${error}`,
        logoView: (): string => "logoView",
        logoZoomIn: (): string => "Zoom In",
        logoZoomOut: (): string => "Zoom Out",
        messageNotFound: (key: string): string => `Message '${key}' not found.`,
        messageWritten: (): string => "Message written",
        missingFileError: (): string => "The language dictionary is missing, comment adaptability is thus disabled.",
        missingLanguageComment: (): string => "Language comment not provided, skipping assignement.",
        morseConverted: (input: string, final: string): string => `Converted: ${input} to ${final}`,
        morseDecoded: (input: string, final: string): string => `Converted: ${input} to ${final}`,
        noActiveEditor: (): string => "No active file!",
        noCommentToShow: (): string => "There is no comment to show.",
        noFilesAvailableForLoading: (): string => "There are no file that can be loaded.",
        noFocusedEditors: (): string => "There are no files in focus.",
        noLogoInstanceProvided: (): string => "No provided logo randomiser instance.",
        noProvidedCommentOptions: (): string => "There are no options that were provided.",
        notFoundFilePath: (filePath: string, error: string = "Not provided"): string => `The provided file path does not exist: '${filePath}', error: '${error}'`,
        openFileToApplyHeader: (): string => "Please open a file on which to apply the header.",
        operationCanceled: (): string => "Operation cancelled",
        quickPickError: (err: string = "Not provided"): string => `Error in quickPick: ${err}`,
        quickPickNo: (): string => "No",
        quickPickYes: (): string => "Yes",
        ramdomLogoGatheringLogoUndefined: (): string => "The logo content is undefined.",
        randomLogoGatheringFailed: (error: string = "Not provided"): string => `The random logo gathering failed, using default logo, error: "${error}"`,
        readTimeout: (timeout: number, filePath: string): string => `Read timeout after: ${timeout}ms for ${filePath}`,
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string): string => `Hello world! This file's extension is: ${fileExtension}, it's name is: ${fileName}, it's path is: ${filePath}, determined language: ${languageId}\n`,
        toMorseGetInput: (): string => "Please enter the text to convert",
        unknown: (): string => "Unknown",
        unknownFileStructure: (): string => "The language dictionary structure is unknown, comment adaptability is thus disabled.",
        updateAbortedBecauseFileClosedSyncCancelled: (): string => "Update aborted because the file is closed and will thus not be synced.",
        updateEditDateMissingBounds: (): string => "Could not update the header: internal header markers were not found.",
        updatingEditionDate: (): string => "Updating the edition date.",
        watermarkAuthorName: (): string => "Author name",
        watermarkChosen: (watermark: string[]): string => `Watermark to display: ${JSON.stringify(watermark)}`,
        watermarkCopied: (name: string): string => `ASCII art copied for ${name}!`,
        watermarkCopyAscii: (): string => "Copy ASCII",
        watermarkJsonFileInvalid: (): string => "Watermark JSON file is empty or invalid",
        watermarkName: (): string => "Watermark name",
        watermarkNotFound: (): string => "Watermark not found",
        watermarkPersonDisplayed: (name: string): string => `Watermark '${name}' displayed.`,
        watermarkView: (): string => "watermarkView",
        watermarkZoomIn: (): string => "Zoom In",
        watermarkZoomOut: (): string => "Zoom Out"
    },
    "fr": {
        alternateFilePathUpdated: (oldFilePath: string, newFilePath: string): string => `Le chemin alternatif a été mis à jour de ${oldFilePath} vers ${newFilePath}.`,
        alternateLogoDirectoryNotFound: (alternateRootDirectory: string, error: string = "Non fourni") => `Le répertoire racine du logo alternatif '${alternateRootDirectory}' est introuvable, erreur : '${error}'.`,
        alternateLogoDirectoryNotProvided: () => `Aucun répertoire de logo alternatif n’a été fourni.`,
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]): string => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}.`,
        brokenHeader: (): string => "En-tête corrompu détecté, injection d’un nouveau, veuillez supprimer l’ancien.",
        cacheAlreadyLoaded: (): string => "Le cache est déjà chargé, retour de l'instance stockée.",
        chooseSingleLineCommentOption: (): string => "Veuillez sélectionner votre préfixe de commentaire préféré parmi les options ci-dessous :",
        closedDocument: (): string => "Le document est fermé, arrêt des opérations.",
        convertedContentCli: (content: string): string => `Contenu converti : ${content}`,
        convertedContentGui: (): string => "Contenu converti : ",
        corruptedFileMetaData: (): string => "Les métadonnées nécessaires du fichier n’ont pas été correctement collectées, abandon.",
        cwdDoesNotExist: (cwd: string): string => `Le répertoire de travail fourni ${cwd} n’existe pas.`,
        cwdUpdated: (oldCwd: string, newCwd: string): string => `Le répertoire de travail a été mis à jour de ${oldCwd} vers ${newCwd}.`,
        darlingAge: (): string => "Âge",
        darlingAlias: (): string => "Alias",
        darlingCopied: (name: string): string => `Art ASCII copié pour ${name} !`,
        darlingCopyAscii: (): string => "Copier l'ASCII",
        darlingDescription: (): string => "Description",
        darlingHeight: (): string => "Taille",
        darlingImage: (): string => "Image",
        darlingJsonFileInvalid: (): string => "Le fichier JSON Darling est vide ou invalide",
        darlingMoreInfo: (): string => "Plus d'infos",
        darlingPersonDisplayed: (name: string): string => `Personnage '${name}' affiché.`,
        darlingQuote: (): string => "Citation",
        darlingType: (): string => "Type",
        darlingView: (): string => "vueDarling",
        darlingZoomIn: (): string => "Zoomer",
        darlingZoomOut: (): string => "Dézoomer",
        documentLineScanExceeded: (maxScanLength: number): string => `Analyse des ${maxScanLength} premières lignes du fichier, aucun en-tête trouvé.`,
        emptyDocument: (): string => "Il n’y a aucun document à traiter.",
        errorDuringFunctionCall: (functionName: string): string => `Une erreur est survenue lors de l’appel de la fonction (${functionName}), consultez les journaux.`,
        extensionActivated: (moduleName: string): string => `🚀 L'extension « ${moduleName} » est maintenant active !`,
        fileExcludedActivationDisabled: (): string => "Activation désactivée, le fichier est dans la liste d'exclusion.",
        fileLength: (filePath: string, fileLength: number): string => `Fichier : '${filePath}', longueur : ${fileLength} octets.`,
        fileLoaded: (absolutePath: string): string => `Fichier ${absolutePath} chargé !`,
        fileLoadError: (filePath: string, error: string = "NonFourni"): string => `Échec du chargement du fichier : '${filePath}'. Erreur : ${error}.`,
        fileNotFound: (filePath: string): string => `Fichier introuvable : ${filePath}`,
        fileParseError: (filePath: string, error: string): string => `Le contenu du fichier (${filePath}) n’a pas pu être chargé correctement. Erreur : ${error}.`,
        filepathPresenceCheck: (filePath: string): string => `Vérification de la présence du chemin de fichier : ${filePath}`,
        filePathProcessing: (filepath: string): string => `Traitement du chemin de fichier : '${filepath}'.`,
        filePathUpdated: (oldFilePath: string, newFilePath: string): string => `Le chemin a été mis à jour de ${oldFilePath} vers ${newFilePath}.`,
        fileRefreshed: (): string => "Actualisation du contenu du fichier.",
        fileSaveFailed: (): string => "Échec de la sauvegarde du fichier, veuillez réessayer.",
        fileUnloaded: (filePath: string): string => `Fichier ${filePath} déchargé de la mémoire.`,
        foundAlternateFilePathToLoad: (alternateFilePath: string) => `Le chemin de fichier alternatif à charger est défini sur '${alternateFilePath}'.`,
        foundAlternateLogoRootDir: (rootDir: string) => `Le répertoire racine alternatif du logo actuel est : '${rootDir}'.`,
        foundCurrentWorkingDirectory: (cwd: string) => `Le répertoire de travail actuel est défini sur '${cwd}'.`,
        foundFilePath: (filePath: string) => `Le chemin de fichier fourni existe : '${filePath}'.`,
        foundFilePathToLoad: (filePath: string) => `Le chemin de fichier à charger est défini sur '${filePath}'.`,
        foundFocusEditor: () => `Un éditeur est actuellement actif.`,
        foundLanguageComment: () => `Le fichier de commentaire de langue est présent.`,
        foundLogoInstance: () => `Une instance de logo a été fournie.`,
        foundLogoRootDir: (rootDir: string) => `Le répertoire racine du logo actuel est : '${rootDir}'.`,
        foundNewLine: (newLineType: string) => `Le nouveau type de ligne déterminé est '${newLineType}'.`,
        foundWorkingDirectory: () => `Le répertoire de travail fourni existe.`,
        fromMorseGetInput: (): string => "Veuillez entrer le texte à convertir depuis",
        getHeaderDescription: (): string => "Veuillez fournir une description : ",
        getHeaderPurpose: (): string => "Veuillez fournir l’objectif du fichier :",
        getHeaderTags: (): string => "Veuillez saisir les tags de ce fichier, séparés par des virgules :",
        headerInjectQuestion: (): string => "Aucun en-tête trouvé dans ce document. Souhaitez-vous en ajouter un ?",
        headerInjectQuestionRefused: (): string => "Vous avez décidé de ne pas ajouter d'en-tête au fichier.",
        headerNotFound: (): string => "Aucun en-tête trouvé dans ce document.",
        headerOpenerAndCloserFound: (): string => "Début et fin d’en-tête trouvés, mise à jour de la date après vérification.",
        headerOpenerFound: (): string => "Début d’en-tête trouvé.",
        headerWriteFailed: (): string => "Échec de l’écriture de l’en-tête dans le fichier, consultez les journaux.",
        headerWriteSuccess: (): string => "En-tête écrit avec succès.",
        helloWorldGreetingsCommand: (moduleName: string): string => `Hello World de ${moduleName} !`,
        identifiedLanguage: (langName: string): string => `Langage identifié : ${langName}.`,
        inFunction: (functionName: string, className: string = "Non spécifié") => `Dans la fonction : '${functionName}' de la classe : '${className}'`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string): string => `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        inputboxError: (promptText: string, err: string): string => `Erreur dans la boîte de saisie pour ${promptText} : ${err}`,
        jsonContent: (jsonContentString: String) => `Contenu du fichier JSON de commentaires : ${jsonContentString}`,
        languageNotFound: (LanguageId: string, fileExtension: string): string => `La langue du fichier de ce document n'a pas pu être identifiée, languageID : ${LanguageId}, extension du fichier : ${fileExtension}`,
        lastModifiedLineNotFound: (): string => "L’en-tête ne contient pas de ligne « Dernière modification » à mettre à jour.",
        lastModifiedUpdated: (): string => "La date de « Dernière modification » a été mise à jour avec succès.",
        logoChosen: (logo: string[]): string => `Logo à afficher : ${JSON.stringify(logo)}`,
        logoCopied: (logoName: string): string => `Art ASCII copié pour ${logoName} !`,
        logoCopyAscii: (): string => "Copier l'ASCII",
        logoDisplayed: (name: string): string => `Logo '${name}' affiché.`,
        logoMessage: (logoPath: string): string => `Fichier (${logoPath}) ignoré car ce n'est pas le type recherché.`,
        logoName: (): string => "Nom du logo",
        logoNoRootDir: (): string => "Aucun répertoire racine fourni pour collecter les logos",
        logoNotFound: (): string => "Logo introuvable",
        logoRootDirUpdateError: (error: string): string => `Erreur lors de la mise à jour des fichiers de logo, erreur : ${error}`,
        logoView: (): string => "vueLogo",
        logoZoomIn: (): string => "Zoomer",
        logoZoomOut: (): string => "Dézoomer",
        messageNotFound: (key: string): string => `Message '${key}' introuvable.`,
        messageWritten: (): string => "Message écrit",
        missingFileError: (): string => "Le dictionnaire des langages est manquant, l’adaptabilité des commentaires est désactivée.",
        missingLanguageComment: (): string => "Commentaire de langage non fourni, assignation ignorée.",
        morseConverted: (input: string, final: string): string => `Converti : ${input} en ${final}`,
        morseDecoded: (input: string, final: string): string => `Converti : ${input} en ${final}`,
        noActiveEditor: (): string => "Aucun fichier actif !",
        noCommentToShow: (): string => "Il n’y a aucun commentaire à afficher.",
        noFilesAvailableForLoading: (): string => "Aucun fichier disponible pour le chargement.",
        noFocusedEditors: (): string => "Aucun fichier n’est en focus.",
        noLogoInstanceProvided: (): string => "Aucune instance de randomiseur de logo fournie.",
        noProvidedCommentOptions: (): string => "Aucune option de commentaire n’a été fournie.",
        notFoundFilePath: (filePath: string, error: string = "Non fourni") => `Le chemin de fichier fourni n'existe pas : '${filePath}', erreur : '${error}'`,
        openFileToApplyHeader: (): string => "Veuillez ouvrir un fichier sur lequel appliquer l’en-tête.",
        operationCanceled: (): string => "Opération annulée",
        quickPickError: (err: string): string => `Erreur dans quickPick : ${err}`,
        quickPickNo: (): string => "Non",
        quickPickYes: (): string => "Oui",
        ramdomLogoGatheringLogoUndefined: (): string => "Le contenu du logo est indéfini.",
        randomLogoGatheringFailed: (error: string): string => `La collecte aléatoire de logo a échoué, utilisation du logo par défaut, erreur : "${error}"`,
        readTimeout: (timeout: number, filePath: string): string => `Délai de lecture dépassé après : ${timeout}ms pour ${filePath}`,
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string): string => `Hello world ! Extension : ${fileExtension}, nom : ${fileName}, chemin : ${filePath}, langage : ${languageId}\n`,
        toMorseGetInput: (): string => "Veuillez entrer le texte à convertir",
        unknown: (): string => "Inconnu",
        unknownFileStructure: (): string => "La structure du dictionnaire des langages est inconnue, l’adaptabilité des commentaires est désactivée.",
        updateAbortedBecauseFileClosedSyncCancelled: (): string => "Mise à jour annulée car le fichier est fermé et ne sera pas synchronisé.",
        updateEditDateMissingBounds: (): string => "Impossible de mettre à jour l’en-tête : les marqueurs internes n’ont pas été trouvés.",
        updatingEditionDate: (): string => "Mise à jour de la date de modification.",
        watermarkAuthorName: (): string => "Auteur",
        watermarkChosen: (watermark: string[]): string => `Watermark à afficher : ${JSON.stringify(watermark)}`,
        watermarkCopied: (name: string): string => `Art ASCII copié pour ${name} !`,
        watermarkCopyAscii: (): string => "Copier l'ASCII",
        watermarkJsonFileInvalid: (): string => "Le fichier JSON de watermark est vide ou invalide",
        watermarkName: (): string => "Nom du watermark",
        watermarkNotFound: (): string => "Watermark introuvable",
        watermarkPersonDisplayed: (name: string): string => `Watermark '${name}' affiché.`,
        watermarkView: (): string => "vueWatermark",
        watermarkZoomIn: (): string => "Zoomer",
        watermarkZoomOut: (): string => "Dézoomer"
    },
    "it": {
        alternateFilePathUpdated: (oldFilePath: string, newFilePath: string): string => `Il percorso alternativo è stato aggiornato da ${oldFilePath} a ${newFilePath}.`,
        alternateLogoDirectoryNotFound: (alternateRootDirectory: string, error: string = "Non fornito") => `La directory principale del logo alternativo '${alternateRootDirectory}' non è stata trovata, errore: '${error}'.`,
        alternateLogoDirectoryNotProvided: () => `Nessuna directory alternativa del logo fornita.`,
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]): string => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}.`,
        brokenHeader: (): string => "Intestazione danneggiata rilevata, iniezione di una nuova, si prega di rimuovere la precedente.",
        cacheAlreadyLoaded: (): string => "La cache è già stata caricata, restituzione dell'istanza memorizzata.",
        chooseSingleLineCommentOption: (): string => "Seleziona il prefisso di commento preferito dalle opzioni qui sotto:",
        closedDocument: (): string => "Il documento è chiuso, operazioni interrotte.",
        convertedContentCli: (content: string): string => `Contenuto convertito: ${content}`,
        convertedContentGui: (): string => "Contenuto convertito: ",
        corruptedFileMetaData: (): string => "I metadati richiesti del file non sono stati raccolti correttamente, interruzione.",
        cwdDoesNotExist: (cwd: string): string => `La directory di lavoro fornita ${cwd} non esiste.`,
        cwdUpdated: (oldCwd: string, newCwd: string): string => `La directory di lavoro è stata aggiornata da ${oldCwd} a ${newCwd}.`,
        darlingAge: (): string => "Età",
        darlingAlias: (): string => "Alias",
        darlingCopied: (name: string): string => `Arte ASCII copiata per ${name}!`,
        darlingCopyAscii: (): string => "Copia ASCII",
        darlingDescription: (): string => "Descrizione",
        darlingHeight: (): string => "Altezza",
        darlingImage: (): string => "Immagine",
        darlingJsonFileInvalid: (): string => "Il file JSON Darling è vuoto o non valido",
        darlingMoreInfo: (): string => "Maggiori info",
        darlingPersonDisplayed: (name: string): string => `Personaggio '${name}' visualizzato.`,
        darlingQuote: (): string => "Citazione",
        darlingType: (): string => "Tipo",
        darlingView: (): string => "vistaDarling",
        darlingZoomIn: (): string => "Ingrandisci",
        darlingZoomOut: (): string => "Rimpicciolisci",
        documentLineScanExceeded: (maxScanLength: number): string => `Analizzate le prime ${maxScanLength} righe del file, nessuna intestazione trovata.`,
        emptyDocument: (): string => "Non c’è alcun documento su cui lavorare.",
        errorDuringFunctionCall: (functionName: string): string => `Qualcosa è andato storto durante la chiamata della funzione (${functionName}), controlla i log per maggiori informazioni.`,
        extensionActivated: (moduleName: string): string => `🚀 La tua estensione « ${moduleName} » è ora attiva!`,
        fileExcludedActivationDisabled: (): string => "Attivazione disabilitata, il file è nella lista di esclusione.",
        fileLength: (filePath: string, fileLength: number): string => `File: '${filePath}', lunghezza: ${fileLength} byte.`,
        fileLoaded: (absolutePath: string): string => `File ${absolutePath} caricato!`,
        fileLoadError: (filePath: string, error: string = "NonFornito"): string => `Impossibile caricare il file: '${filePath}'. Errore: ${error}.`,
        fileNotFound: (filePath: string): string => `File non trovato: ${filePath}`,
        fileParseError: (filePath: string, error: string): string => `Il contenuto del file (${filePath}) non è stato caricato correttamente. Errore: ${error}.`,
        filepathPresenceCheck: (filePath: string): string => `Verifica della presenza del percorso del file: ${filePath}`,
        filePathProcessing: (filepath: string): string => `Elaborazione del percorso del file: '${filepath}'.`,
        filePathUpdated: (oldFilePath: string, newFilePath: string): string => `Il percorso è stato aggiornato da ${oldFilePath} a ${newFilePath}.`,
        fileRefreshed: (): string => "Aggiornamento del contenuto del file.",
        fileSaveFailed: (): string => "Salvataggio del file fallito, riprova a salvarlo.",
        fileUnloaded: (filePath: string): string => `File ${filePath} scaricato dalla memoria.`,
        foundAlternateFilePathToLoad: (alternateFilePath: string) => `Il percorso del file alternativo da caricare è impostato su '${alternateFilePath}'.`,
        foundAlternateLogoRootDir: (rootDir: string) => `La directory principale alternativa del logo corrente è: '${rootDir}'.`,
        foundCurrentWorkingDirectory: (cwd: string) => `La directory di lavoro corrente è impostata su '${cwd}'.`,
        foundFilePath: (filePath: string) => `Il percorso del file fornito esiste: '${filePath}'.`,
        foundFilePathToLoad: (filePath: string) => `Il percorso del file da caricare è impostato su '${filePath}'.`,
        foundFocusEditor: () => `C'è un editor attivo.`,
        foundLanguageComment: () => `Il file di commento della lingua è presente.`,
        foundLogoInstance: () => `È stata fornita un'istanza di logo.`,
        foundLogoRootDir: (rootDir: string) => `La directory principale del logo corrente è: '${rootDir}'.`,
        foundNewLine: (newLineType: string) => `Il nuovo tipo di riga determinato è '${newLineType}'.`,
        foundWorkingDirectory: () => `La directory di lavoro fornita esiste.`,
        fromMorseGetInput: (): string => "Inserisci il testo da convertire da",
        getHeaderDescription: (): string => "Fornisci una descrizione: ",
        getHeaderPurpose: (): string => "Fornisci lo scopo del file:",
        getHeaderTags: (): string => "Inserisci i tag per questo file, separati da virgole:",
        headerInjectQuestion: (): string => "Nessuna intestazione trovata in questo documento. Vuoi aggiungerne una?",
        headerInjectQuestionRefused: (): string => "Hai deciso di non aggiungere un'intestazione al file.",
        headerNotFound: (): string => "Nessuna intestazione trovata in questo documento.",
        headerOpenerAndCloserFound: (): string => "Inizio e fine intestazione trovati, aggiornamento della data dopo il controllo.",
        headerOpenerFound: (): string => "Inizio intestazione trovato.",
        headerWriteFailed: (): string => "Impossibile scrivere l’intestazione nel file, controlla i log.",
        headerWriteSuccess: (): string => "Intestazione scritta con successo.",
        helloWorldGreetingsCommand: (moduleName: string): string => `Hello World da ${moduleName}!`,
        identifiedLanguage: (langName: string): string => `Linguaggio identificato: ${langName}.`,
        inFunction: (functionName: string, className: string = "Non specificato") => `Nella funzione: '${functionName}' della classe: '${className}'`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string): string => `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        inputboxError: (promptText: string, err: string): string => `Errore nella inputBox per ${promptText}: ${err}`,
        jsonContent: (jsonContentString: String) => `Contenuto del file JSON dei commenti: ${jsonContentString}`,
        languageNotFound: (LanguageId: string, fileExtension: string): string => `Non è stato possibile identificare la lingua del file di questo documento, languageID: ${LanguageId}, estensione del file: ${fileExtension}`,
        lastModifiedLineNotFound: (): string => "L’intestazione non contiene una riga 'Ultima modifica' da aggiornare.",
        lastModifiedUpdated: (): string => "La data di 'Ultima modifica' è stata aggiornata con successo.",
        logoChosen: (logo: string[]): string => `Logo da visualizzare: ${JSON.stringify(logo)}`,
        logoCopied: (logoName: string): string => `Arte ASCII copiata per ${logoName}!`,
        logoCopyAscii: (): string => "Copia ASCII",
        logoDisplayed: (name: string): string => `Logo '${name}' visualizzato.`,
        logoMessage: (logoPath: string): string => `File (${logoPath}) ignorato perché non è del tipo cercato.`,
        logoName: (): string => "Nome logo",
        logoNoRootDir: (): string => "Nessuna directory radice fornita per raccogliere i loghi",
        logoNotFound: (): string => "Logo non trovato",
        logoRootDirUpdateError: (error: string): string => `Errore durante l'aggiornamento dei file logo, errore: ${error}`,
        logoView: (): string => "vistaLogo",
        logoZoomIn: (): string => "Ingrandisci",
        logoZoomOut: (): string => "Rimpicciolisci",
        messageNotFound: (key: string): string => `Messaggio '${key}' non trovato.`,
        messageWritten: (): string => "Messaggio scritto",
        missingFileError: (): string => "Il dizionario dei linguaggi è mancante, adattabilità dei commenti disabilitata.",
        missingLanguageComment: (): string => "Commento del linguaggio non fornito, assegnazione ignorata.",
        morseConverted: (input: string, final: string): string => `Convertito: ${input} in ${final}`,
        morseDecoded: (input: string, final: string): string => `Convertito: ${input} in ${final}`,
        noActiveEditor: (): string => "Nessun file attivo!",
        noCommentToShow: (): string => "Non ci sono commenti da mostrare.",
        noFilesAvailableForLoading: (): string => "Non ci sono file disponibili per il caricamento.",
        noFocusedEditors: (): string => "Non ci sono file in focus.",
        noLogoInstanceProvided: (): string => "Nessuna istanza di randomizzatore logo fornita.",
        noProvidedCommentOptions: (): string => "Non sono state fornite opzioni di commento.",
        notFoundFilePath: (filePath: string, error: string = "Non fornito") => `Il percorso del file fornito non esiste: '${filePath}', errore: '${error}'`,
        openFileToApplyHeader: (): string => "Apri un file su cui applicare l’intestazione.",
        operationCanceled: (): string => "Operazione annullata",
        quickPickError: (err: string): string => `Errore in quickPick: ${err}`,
        quickPickNo: (): string => "No",
        quickPickYes: (): string => "Sì",
        ramdomLogoGatheringLogoUndefined: (): string => "Il contenuto del logo è indefinito.",
        randomLogoGatheringFailed: (error: string): string => `La raccolta casuale del logo è fallita, uso del logo predefinito, errore: "${error}"`,
        readTimeout: (timeout: number, filePath: string): string => `Timeout di lettura dopo: ${timeout}ms per ${filePath}`,
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string): string => `Hello world! Estensione: ${fileExtension}, nome: ${fileName}, percorso: ${filePath}, linguaggio: ${languageId}\n`,
        toMorseGetInput: (): string => "Inserisci il testo da convertire",
        unknown: (): string => "Sconosciuto",
        unknownFileStructure: (): string => "La struttura del dizionario dei linguaggi è sconosciuta, adattabilità dei commenti disabilitata.",
        updateAbortedBecauseFileClosedSyncCancelled: (): string => "Aggiornamento annullato perché il file è chiuso e non sarà sincronizzato.",
        updateEditDateMissingBounds: (): string => "Impossibile aggiornare l’intestazione: marcatori interni non trovati.",
        updatingEditionDate: (): string => "Aggiornamento della data di modifica.",
        watermarkAuthorName: (): string => "Nome autore: ",
        watermarkChosen: (watermark: string[]): string => `Watermark da visualizzare: ${JSON.stringify(watermark)}`,
        watermarkCopied: (name: string): string => `Arte ASCII copiata per ${name}!`,
        watermarkCopyAscii: (): string => "Copia ASCII",
        watermarkJsonFileInvalid: (): string => "Il file JSON watermark è vuoto o non valido",
        watermarkName: (): string => "Nome watermark",
        watermarkNotFound: (): string => "Watermark non trovato",
        watermarkPersonDisplayed: (name: string): string => `Watermark '${name}' visualizzato.`,
        watermarkView: (): string => "vistaWatermark",
        watermarkZoomIn: (): string => "Ingrandisci",
        watermarkZoomOut: (): string => "Rimpicciolisci"
    },
    "es": {
        alternateFilePathUpdated: (oldFilePath: string, newFilePath: string): string => `La ruta alternativa se ha actualizado de ${oldFilePath} a ${newFilePath}.`,
        alternateLogoDirectoryNotFound: (alternateRootDirectory: string, error: string = "No proporcionado") => `No se encontró el directorio raíz del logotipo alternativo '${alternateRootDirectory}', error: '${error}'.`,
        alternateLogoDirectoryNotProvided: () => `No se ha proporcionado un directorio de logotipos alternativo.`,
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]): string => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}.`,
        brokenHeader: (): string => "Encabezado roto detectado, inyectando uno nuevo, por favor elimina el anterior.",
        cacheAlreadyLoaded: (): string => "La caché ya está cargada, devolviendo la instancia almacenada.",
        chooseSingleLineCommentOption: (): string => "Seleccione su prefijo de comentario preferido de las opciones a continuación:",
        closedDocument: (): string => "El documento está cerrado, deteniendo operaciones.",
        convertedContentCli: (content: string): string => `Contenido convertido: ${content}`,
        convertedContentGui: (): string => "Contenido convertido: ",
        corruptedFileMetaData: (): string => "Los metadatos del archivo no se recopilaron correctamente, abortando.",
        cwdDoesNotExist: (cwd: string): string => `El directorio de trabajo proporcionado ${cwd} no existe.`,
        cwdUpdated: (oldCwd: string, newCwd: string): string => `El directorio de trabajo se actualizó de ${oldCwd} a ${newCwd}.`,
        darlingAge: (): string => "Edad",
        darlingAlias: (): string => "Alias",
        darlingCopied: (name: string): string => `Arte ASCII copiado para ${name}!`,
        darlingCopyAscii: (): string => "Copiar ASCII",
        darlingDescription: (): string => "Descripción",
        darlingHeight: (): string => "Altura",
        darlingImage: (): string => "Imagen",
        darlingJsonFileInvalid: (): string => "El archivo JSON de Darling está vacío o es inválido",
        darlingMoreInfo: (): string => "Más información",
        darlingPersonDisplayed: (name: string): string => `Personaje '${name}' mostrado.`,
        darlingQuote: (): string => "Cita",
        darlingType: (): string => "Tipo",
        darlingView: (): string => "vistaDarling",
        darlingZoomIn: (): string => "Acercar",
        darlingZoomOut: (): string => "Alejar",
        documentLineScanExceeded: (maxScanLength: number): string => `Se escanearon las primeras ${maxScanLength} líneas del archivo pero no se encontró encabezado.`,
        emptyDocument: (): string => "No hay contenido en el documento.",
        errorDuringFunctionCall: (functionName: string): string => `Algo salió mal durante la llamada de la función (${functionName}), revise los registros.`,
        extensionActivated: (moduleName: string): string => `🚀 La extensión "${moduleName}" ahora está activa!`,
        fileExcludedActivationDisabled: (): string => "Activación deshabilitada, el archivo está en la lista de exclusión.",
        fileLength: (filePath: string, fileLength: number): string => `Archivo: '${filePath}', longitud: ${fileLength} bytes.`,
        fileLoaded: (absolutePath: string): string => `Archivo ${absolutePath} cargado!`,
        fileLoadError: (filePath: string, error: string = "NoProporcionado"): string => `Error al cargar el archivo: '${filePath}'. Error: ${error}.`,
        fileNotFound: (filePath: string): string => `Archivo no encontrado: ${filePath}`,
        fileParseError: (filePath: string, error: string): string => `El contenido del archivo (${filePath}) no se pudo cargar correctamente. Error: ${error}.`,
        filepathPresenceCheck: (filePath: string): string => `Verificando la presencia de la ruta del archivo: ${filePath}`,
        filePathProcessing: (filepath: string): string => `Procesando la ruta del archivo: '${filepath}'.`,
        filePathUpdated: (oldFilePath: string, newFilePath: string): string => `La ruta se actualizó de ${oldFilePath} a ${newFilePath}.`,
        fileRefreshed: (): string => "Actualizando contenido del archivo.",
        fileSaveFailed: (): string => "No se pudo guardar el archivo, intente guardarlo nuevamente.",
        fileUnloaded: (filePath: string): string => `Archivo ${filePath} descargado de la memoria.`,
        foundAlternateFilePathToLoad: (alternateFilePath: string) => `La ruta de archivo alternativa para cargar está configurada en '${alternateFilePath}'.`,
        foundAlternateLogoRootDir: (rootDir: string) => `El directorio raíz alternativo del logotipo actual es: '${rootDir}'.`,
        foundCurrentWorkingDirectory: (cwd: string) => `El directorio de trabajo actual está configurado en '${cwd}'.`,
        foundFilePath: (filePath: string) => `La ruta de archivo proporcionada existe: '${filePath}'.`,
        foundFilePathToLoad: (filePath: string) => `La ruta de archivo para cargar está configurada en '${filePath}'.`,
        foundFocusEditor: () => `Hay un editor enfocado.`,
        foundLanguageComment: () => `El archivo de comentarios de idioma está presente.`,
        foundLogoInstance: () => `Se ha proporcionado una instancia de logotipo.`,
        foundLogoRootDir: (rootDir: string) => `El directorio raíz del logotipo actual es: '${rootDir}'.`,
        foundNewLine: (newLineType: string) => `El nuevo tipo de línea determinado es '${newLineType}'.`,
        foundWorkingDirectory: () => `El directorio de trabajo proporcionado existe.`,
        fromMorseGetInput: (): string => "Por favor, introduzca el texto a convertir desde",
        getHeaderDescription: (): string => "Por favor, proporciona una descripción: ",
        getHeaderPurpose: (): string => "Proporcione el propósito del archivo:",
        getHeaderTags: (): string => "Ingrese las etiquetas para este archivo, separadas por comas:",
        headerInjectQuestion: (): string => "No se encontró encabezado en este documento. ¿Desea agregar uno?",
        headerInjectQuestionRefused: (): string => "Decidió no agregar un encabezado al archivo.",
        headerNotFound: (): string => "No se encontró encabezado en este documento.",
        headerOpenerAndCloserFound: (): string => "Inicio y fin del encabezado encontrados, actualizando la fecha tras la verificación.",
        headerOpenerFound: (): string => "Se encontró el inicio del encabezado.",
        headerWriteFailed: (): string => "Error al escribir el encabezado en el archivo, revise los registros.",
        headerWriteSuccess: (): string => "Encabezado escrito con éxito.",
        helloWorldGreetingsCommand: (moduleName: string): string => `¡Hola Mundo desde ${moduleName}!`,
        identifiedLanguage: (langName: string): string => `Idioma identificado: ${langName}.`,
        inFunction: (functionName: string, className: string = "No especificado") => `En la función: '${functionName}' de la clase: '${className}'`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string): string => `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        inputboxError: (promptText: string, err: string): string => `Error en la inputBox para ${promptText}: ${err}`,
        jsonContent: (jsonContentString: String) => `Contenido del archivo JSON de comentarios: ${jsonContentString}`,
        languageNotFound: (LanguageId: string, fileExtension: string): string => `No se pudo identificar el idioma del archivo de este documento, languageID: ${LanguageId}, extensión del archivo: ${fileExtension}`,
        lastModifiedLineNotFound: (): string => "El encabezado no contiene una línea 'Última modificación' para actualizar.",
        lastModifiedUpdated: (): string => "La fecha de 'Última modificación' se actualizó correctamente.",
        logoChosen: (logo: string[]): string => `Logo a mostrar: ${JSON.stringify(logo)}`,
        logoCopied: (logoName: string): string => `Arte ASCII copiado para ${logoName}!`,
        logoCopyAscii: (): string => "Copiar ASCII",
        logoDisplayed: (name: string): string => `Logo '${name}' mostrado.`,
        logoMessage: (logoPath: string): string => `Archivo (${logoPath}) ignorado porque no es el tipo buscado.`,
        logoName: (): string => "Nombre del logo",
        logoNoRootDir: (): string => "No se proporcionó directorio raíz para recopilar los logos",
        logoNotFound: (): string => "Logo no encontrado",
        logoRootDirUpdateError: (error: string): string => `Ocurrió un error durante la actualización de los archivos de logo, error: ${error}`,
        logoView: (): string => "vistaLogo",
        logoZoomIn: (): string => "Acercar",
        logoZoomOut: (): string => "Alejar",
        messageNotFound: (key: string): string => `Mensaje '${key}' no encontrado.`,
        messageWritten: (): string => "Mensaje escrito",
        missingFileError: (): string => "Falta el diccionario de idiomas, la adaptabilidad de comentarios está deshabilitada.",
        missingLanguageComment: (): string => "Comentario de idioma no proporcionado, omitiendo asignación.",
        morseConverted: (input: string, final: string): string => `Convertido: ${input} a ${final}`,
        morseDecoded: (input: string, final: string): string => `Convertido: ${input} a ${final}`,
        noActiveEditor: (): string => "¡No hay archivo activo!",
        noCommentToShow: (): string => "No hay comentarios para mostrar.",
        noFilesAvailableForLoading: (): string => "No hay archivos disponibles para cargar.",
        noFocusedEditors: (): string => "No hay archivos enfocados.",
        noLogoInstanceProvided: (): string => "No se proporcionó instancia de randomizador de logo.",
        noProvidedCommentOptions: (): string => "No se proporcionaron opciones de comentario.",
        notFoundFilePath: (filePath: string, error: string = "No proporcionado") => `La ruta de archivo proporcionada no existe: '${filePath}', error: '${error}'`,
        openFileToApplyHeader: (): string => "Por favor, abre un archivo para aplicar el encabezado.",
        operationCanceled: (): string => "Operación cancelada",
        quickPickError: (err: string): string => `Error en quickPick: ${err}`,
        quickPickNo: (): string => "No",
        quickPickYes: (): string => "Sí",
        ramdomLogoGatheringLogoUndefined: (): string => "El contenido del logo es indefinido.",
        randomLogoGatheringFailed: (error: string): string => `La recopilación aleatoria de logos falló, usando el logo predeterminado, error: "${error}"`,
        readTimeout: (timeout: number, filePath: string): string => `Tiempo de lectura agotado después de: ${timeout}ms para ${filePath}`,
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string): string => `¡Hola mundo! La extensión de este archivo es: ${fileExtension}, su nombre es: ${fileName}, su ruta es: ${filePath}, lenguaje determinado: ${languageId}\n`,
        toMorseGetInput: (): string => "Por favor, introduzca el texto a convertir",
        unknown: (): string => "Desconocido",
        unknownFileStructure: (): string => "La estructura del diccionario de idiomas es desconocida, la adaptabilidad de comentarios está deshabilitada.",
        updateAbortedBecauseFileClosedSyncCancelled: (): string => "Actualización abortada porque el archivo está cerrado y no se sincronizará.",
        updateEditDateMissingBounds: (): string => "No se pudo actualizar el encabezado: no se encontraron los marcadores internos.",
        updatingEditionDate: (): string => "Actualizando la fecha de edición.",
        watermarkAuthorName: (): string => "Nombre del autor",
        watermarkChosen: (watermark: string[]): string => `Marca de agua a mostrar: ${JSON.stringify(watermark)}`,
        watermarkCopied: (name: string): string => `Arte ASCII copiado para ${name}!`,
        watermarkCopyAscii: (): string => "Copiar ASCII",
        watermarkJsonFileInvalid: (): string => "El archivo JSON de la marca de agua está vacío o es inválido",
        watermarkName: (): string => "Nombre de la marca de agua",
        watermarkNotFound: (): string => "Marca de agua no encontrada",
        watermarkPersonDisplayed: (name: string): string => `Marca de agua '${name}' mostrada.`,
        watermarkView: (): string => "vistaMarcaAgua",
        watermarkZoomIn: (): string => "Acercar",
        watermarkZoomOut: (): string => "Alejar"
    },
    "de": {
        alternateFilePathUpdated: (oldFilePath: string, newFilePath: string): string => `Der alternative Pfad wurde von ${oldFilePath} auf ${newFilePath} aktualisiert.`,
        alternateLogoDirectoryNotFound: (alternateRootDirectory: string, error: string = "Nicht angegeben") => `Das alternative Logo-Stammverzeichnis '${alternateRootDirectory}' wurde nicht gefunden, Fehler: '${error}'.`,
        alternateLogoDirectoryNotProvided: () => `Kein alternatives Logo-Verzeichnis angegeben.`,
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]) => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}.`,
        brokenHeader: () => "Beschädigter Header erkannt, füge neuen Header ein, bitte vorherigen entfernen.",
        cacheAlreadyLoaded: (): string => "Der Cache ist bereits geladen, gespeicherte Instanz wird zurückgegeben.",
        chooseSingleLineCommentOption: () => "Bitte bevorzugten Kommentarpräfix aus den Optionen unten auswählen:",
        closedDocument: () => "Das Dokument ist geschlossen, Operationen gestoppt.",
        convertedContentCli: (content: string): string => `Konvertierter Inhalt: ${content}`,
        convertedContentGui: (): string => "Konvertierter Inhalt: ",
        corruptedFileMetaData: () => "Datei-Metadaten wurden nicht korrekt gesammelt, Abbruch.",
        cwdDoesNotExist: (cwd: string) => `Das angegebene Arbeitsverzeichnis ${cwd} existiert nicht.`,
        cwdUpdated: (oldCwd: string, newCwd: string) => `Das aktuelle Arbeitsverzeichnis wurde von ${oldCwd} auf ${newCwd} aktualisiert.`,
        darlingAge: () => "Alter",
        darlingAlias: () => "Alias",
        darlingCopied: (name: string) => `ASCII-Kunst für ${name} kopiert!`,
        darlingCopyAscii: () => "ASCII kopieren",
        darlingDescription: () => "Beschreibung",
        darlingHeight: () => "Größe",
        darlingImage: () => "Bild",
        darlingJsonFileInvalid: () => "Darling JSON-Datei ist leer oder ungültig",
        darlingMoreInfo: () => "Weitere Infos",
        darlingPersonDisplayed: (name: string) => `Charakter '${name}' angezeigt.`,
        darlingQuote: () => "Zitat",
        darlingType: () => "Typ",
        darlingView: () => "Charakter-Ansicht",
        darlingZoomIn: () => "Vergrößern",
        darlingZoomOut: () => "Verkleinern",
        documentLineScanExceeded: (maxScanLength: number) => `Erste ${maxScanLength} Zeilen der Datei gescannt, kein Header gefunden.`,
        emptyDocument: () => "Kein Dokument vorhanden.",
        errorDuringFunctionCall: (functionName: string) => `Fehler beim Aufruf der Funktion (${functionName}), prüfen Sie die Logs.`,
        extensionActivated: (moduleName: string) => `🚀 Erweiterung "${moduleName}" ist jetzt aktiv!`,
        fileExcludedActivationDisabled: () => "Aktivierung deaktiviert, Datei ist auf der Ausschlussliste.",
        fileLength: (filePath: string, fileLength: number): string => `Datei: '${filePath}', Länge: ${fileLength} Bytes.`,
        fileLoaded: (absolutePath: string) => `Datei ${absolutePath} geladen!`,
        fileLoadError: (filePath: string, error: string = "NichtBereitgestellt"): string => `Fehler beim Laden der Datei: '${filePath}'. Fehler: ${error}.`,
        fileNotFound: (filePath: string): string => `Datei nicht gefunden: ${filePath}`,
        fileParseError: (filePath: string, error: string) => `Dateiinhalt (${filePath}) konnte nicht erfolgreich geladen werden. Fehler: ${error}.`,
        filepathPresenceCheck: (filePath: string): string => `Überprüfung des Dateipfads: ${filePath}`,
        filePathProcessing: (filepath: string): string => `Verarbeitung des Dateipfads: '${filepath}'.`,
        filePathUpdated: (oldFilePath: string, newFilePath: string) => `Pfad wurde von ${oldFilePath} auf ${newFilePath} aktualisiert.`,
        fileRefreshed: () => "Dateiinhalt wird aktualisiert.",
        fileSaveFailed: () => "Datei konnte nicht gespeichert werden, bitte erneut versuchen.",
        fileUnloaded: (filePath: string) => `Datei ${filePath} aus dem Speicher entfernt.`,
        foundAlternateFilePathToLoad: (alternateFilePath: string) => `Der alternative zu ladende Dateipfad ist auf '${alternateFilePath}' gesetzt.`,
        foundAlternateLogoRootDir: (rootDir: string) => `Das aktuelle alternative Logo-Stammverzeichnis ist: '${rootDir}'.`,
        foundCurrentWorkingDirectory: (cwd: string) => `Das aktuelle Arbeitsverzeichnis ist auf '${cwd}' gesetzt.`,
        foundFilePath: (filePath: string) => `Der angegebene Dateipfad existiert: '${filePath}'.`,
        foundFilePathToLoad: (filePath: string) => `Der zu ladende Dateipfad ist auf '${filePath}' gesetzt.`,
        foundFocusEditor: () => `Ein Editor ist im Fokus.`,
        foundLanguageComment: () => `Die Sprachkommentar-Datei ist vorhanden.`,
        foundLogoInstance: () => `Eine Logo-Instanz wurde bereitgestellt.`,
        foundLogoRootDir: (rootDir: string) => `Das aktuelle Logo-Stammverzeichnis ist: '${rootDir}'.`,
        foundNewLine: (newLineType: string) => `Die neu bestimmte Zeile ist '${newLineType}'.`,
        foundWorkingDirectory: () => `Das angegebene Arbeitsverzeichnis existiert.`,
        fromMorseGetInput: (): string => "Bitte geben Sie den Text ein, der konvertiert werden soll",
        getHeaderDescription: () => "Bitte Beschreibung angeben:",
        getHeaderPurpose: () => "Bitte Zweck der Datei angeben:",
        getHeaderTags: () => "Bitte Tags für diese Datei eingeben, durch Kommas getrennt:",
        headerInjectQuestion: () => "Kein Header gefunden. Möchten Sie einen hinzufügen?",
        headerInjectQuestionRefused: () => "Sie haben entschieden, keinen Header hinzuzufügen.",
        headerNotFound: () => "Kein Header in diesem Dokument gefunden.",
        headerOpenerAndCloserFound: () => "Header-Start und -Ende gefunden, aktualisiere das Datum nach Überprüfung.",
        headerOpenerFound: () => "Header-Start gefunden.",
        headerWriteFailed: () => "Header konnte nicht in die Datei geschrieben werden, prüfen Sie die Logs.",
        headerWriteSuccess: () => "Header erfolgreich geschrieben.",
        helloWorldGreetingsCommand: (moduleName: string) => `Hello World von ${moduleName}!`,
        identifiedLanguage: (langName: string) => `Identifizierte Sprache: ${langName}.`,
        inFunction: (functionName: string, className: string = "Nicht angegeben") => `In Funktion: '${functionName}' aus Klasse: '${className}'`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string) => `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        inputboxError: (promptText: string, err: string) => `Fehler im Eingabefeld für ${promptText}: ${err}`,
        jsonContent: (jsonContentString: String) => `Inhalt der Kommentar-JSON-Datei: ${jsonContentString}`,
        languageNotFound: (LanguageId: string, fileExtension: string) => `Dateisprache konnte nicht erkannt werden, languageID: ${LanguageId}, Dateierweiterung: ${fileExtension}`,
        lastModifiedLineNotFound: () => "Header enthält keine 'Zuletzt geändert'-Zeile zum Aktualisieren.",
        lastModifiedUpdated: () => "'Zuletzt geändert'-Datum erfolgreich aktualisiert.",
        logoChosen: (logo: string[]) => `Anzuzeigendes Logo: ${JSON.stringify(logo)}`,
        logoCopied: (logoName: string) => `ASCII-Kunst für ${logoName} kopiert!`,
        logoCopyAscii: () => "ASCII kopieren",
        logoDisplayed: (name: string) => `Logo '${name}' angezeigt.`,
        logoMessage: (logoPath: string) => `Datei (${logoPath}) ignoriert, da sie nicht vom gesuchten Typ ist.`,
        logoName: () => "Logoname",
        logoNoRootDir: () => "Kein Stammverzeichnis zur Sammlung von Logos angegeben",
        logoNotFound: () => "Logo nicht gefunden",
        logoRootDirUpdateError: (error: string) => `Fehler beim Aktualisieren der Logodateien, Fehler: ${error}`,
        logoView: () => "Logo-Ansicht",
        logoZoomIn: () => "Vergrößern",
        logoZoomOut: () => "Verkleinern",
        messageNotFound: (key: string) => `Nachricht '${key}' nicht gefunden.`,
        messageWritten: () => "Nachricht geschrieben",
        missingFileError: () => "Sprachwörterbuch fehlt, Kommentar-Anpassung deaktiviert.",
        missingLanguageComment: () => "Sprachkommentar nicht bereitgestellt, Zuweisung übersprungen.",
        morseConverted: (input: string, final: string) => `Konvertiert: ${input} -> ${final}`,
        morseDecoded: (input: string, final: string) => `Dekodiert: ${input} -> ${final}`,
        noActiveEditor: () => "Keine aktive Datei!",
        noCommentToShow: () => "Kein Kommentar zum Anzeigen.",
        noFilesAvailableForLoading: (): string => "Es sind keine Dateien zum Laden verfügbar.",
        noFocusedEditors: () => "Keine fokussierten Dateien.",
        noLogoInstanceProvided: () => "Keine Logo-Randomizer-Instanz bereitgestellt.",
        noProvidedCommentOptions: () => "Keine Kommentaroptionen bereitgestellt.",
        notFoundFilePath: (filePath: string, error: string = "Nicht angegeben") => `Der angegebene Dateipfad existiert nicht: '${filePath}', Fehler: '${error}'`,
        openFileToApplyHeader: () => "Bitte öffnen Sie eine Datei, um den Header anzuwenden.",
        operationCanceled: (): string => "Vorgang abgebrochen",
        quickPickError: (err: string) => `Fehler in QuickPick: ${err}`,
        quickPickNo: () => "Nein",
        quickPickYes: () => "Ja",
        ramdomLogoGatheringLogoUndefined: () => "Logo-Inhalt ist undefiniert.",
        randomLogoGatheringFailed: (error: string) => `Zufälliges Logo konnte nicht geladen werden, Standardlogo wird verwendet, Fehler: "${error}"`,
        readTimeout: (timeout: number, filePath: string): string => `Lesezeitüberschreitung nach: ${timeout}ms für ${filePath}`,
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string) => `Hello World! Dateiendung: ${fileExtension}, Name: ${fileName}, Pfad: ${filePath}, Sprache: ${languageId}\n`,
        toMorseGetInput: (): string => "Bitte geben Sie den zu konvertierenden Text ein",
        unknown: () => "Unbekannt",
        unknownFileStructure: () => "Sprachwörterbuchstruktur unbekannt, Kommentar-Anpassung deaktiviert.",
        updateAbortedBecauseFileClosedSyncCancelled: () => "Update abgebrochen, da die Datei geschlossen ist und nicht synchronisiert wird.",
        updateEditDateMissingBounds: () => "Header konnte nicht aktualisiert werden: interne Marker nicht gefunden.",
        updatingEditionDate: () => "Aktualisiere das Erstellungsdatum.",
        watermarkAuthorName: () => "Autor",
        watermarkChosen: (watermark: string[]) => `Anzuzeigendes Wasserzeichen: ${JSON.stringify(watermark)}`,
        watermarkCopied: (name: string) => `ASCII-Kunst für ${name} kopiert!`,
        watermarkCopyAscii: () => "ASCII kopieren",
        watermarkJsonFileInvalid: () => "Wasserzeichen JSON-Datei ist leer oder ungültig",
        watermarkName: () => "Wasserzeichenname",
        watermarkNotFound: () => "Wasserzeichen nicht gefunden",
        watermarkPersonDisplayed: (name: string) => `Wasserzeichen '${name}' angezeigt.`,
        watermarkView: () => "Wasserzeichen-Ansicht",
        watermarkZoomIn: () => "Vergrößern",
        watermarkZoomOut: () => "Verkleinern"
    },
    "ja": {
        alternateFilePathUpdated: (oldFilePath: string, newFilePath: string): string => `代替パスが ${oldFilePath} から ${newFilePath} に更新されました。`,
        alternateLogoDirectoryNotFound: (alternateRootDirectory: string, error: string = "未提供") => `代替ロゴのルートディレクトリ '${alternateRootDirectory}' が見つかりません、エラー: '${error}'。`,
        alternateLogoDirectoryNotProvided: () => `代替ロゴディレクトリが指定されていません。`,
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]) => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}。`,
        brokenHeader: () => "壊れたヘッダーが検出されました。新しいヘッダーを挿入します。前のものを削除してください。",
        cacheAlreadyLoaded: (): string => "キャッシュはすでに読み込まれています。保存されたインスタンスを返します。",
        chooseSingleLineCommentOption: () => "以下のオプションからコメントのプレフィックスを選択してください: ",
        closedDocument: () => "ドキュメントは閉じられました。操作を停止します。",
        convertedContentCli: (content: string): string => `変換された内容: ${content}`,
        convertedContentGui: (): string => "変換された内容: ",
        corruptedFileMetaData: () => "必要なファイルメタデータが正しく収集されていません。中止します。",
        cwdDoesNotExist: (cwd: string) => `指定された作業ディレクトリ ${cwd} は存在しません。`,
        cwdUpdated: (oldCwd: string, newCwd: string) => `現在の作業ディレクトリを ${oldCwd} から ${newCwd} に更新しました。`,
        darlingAge: () => "年齢",
        darlingAlias: () => "別名",
        darlingCopied: (name: string) => `${name} の ASCII アートをコピーしました！`,
        darlingCopyAscii: () => "ASCII をコピー",
        darlingDescription: () => "説明",
        darlingHeight: () => "身長",
        darlingImage: () => "画像",
        darlingJsonFileInvalid: () => "Darling JSON ファイルが空または無効です",
        darlingMoreInfo: () => "詳細情報",
        darlingPersonDisplayed: (name: string) => `キャラクター '${name}' を表示しました。`,
        darlingQuote: () => "引用",
        darlingType: () => "タイプ",
        darlingView: () => "キャラクタービュー",
        darlingZoomIn: () => "ズームイン",
        darlingZoomOut: () => "ズームアウト",
        documentLineScanExceeded: (maxScanLength: number) => `ファイルの最初の ${maxScanLength} 行をスキャンしましたが、ヘッダーは見つかりませんでした。`,
        emptyDocument: () => "ドキュメントの本文がありません。",
        errorDuringFunctionCall: (functionName: string) => `関数 (${functionName}) の呼び出し中にエラーが発生しました。ログを確認してください。`,
        extensionActivated: (moduleName: string) => `🚀 "${moduleName}" 拡張機能がアクティブになりました！`,
        fileExcludedActivationDisabled: () => "アクティベーションは無効です。ファイルは除外リストにあります。",
        fileLength: (filePath: string, fileLength: number): string => `ファイル: '${filePath}'、長さ: ${fileLength} バイト。`,
        fileLoaded: (absolutePath: string) => `ファイル ${absolutePath} を読み込みました！`,
        fileLoadError: (filePath: string, error: string = "未指定"): string => `ファイル '${filePath}' の読み込みに失敗しました。エラー: ${error}。`,
        fileNotFound: (filePath: string): string => `ファイルが見つかりません: ${filePath}`,
        fileParseError: (filePath: string, error: string) => `ファイルの内容 (${filePath}) を正常に読み込めませんでした。エラー: ${error}。`,
        filepathPresenceCheck: (filePath: string): string => `ファイルパスの存在を確認中: ${filePath}`,
        filePathProcessing: (filepath: string): string => `ファイルパスを処理中: '${filepath}'。`,
        filePathUpdated: (oldFilePath: string, newFilePath: string) => `パスを ${oldFilePath} から ${newFilePath} に更新しました。`,
        fileRefreshed: () => "ファイル内容を更新しています。",
        fileSaveFailed: () => "ファイルの保存に失敗しました。もう一度保存してください。",
        fileUnloaded: (filePath: string) => `ファイル ${filePath} をメモリからアンロードしました。`,
        foundAlternateFilePathToLoad: (alternateFilePath: string) => `読み込む代替ファイルパスは '${alternateFilePath}' に設定されています。`,
        foundAlternateLogoRootDir: (rootDir: string) => `現在の代替ロゴのルートディレクトリは '${rootDir}' です。`,
        foundCurrentWorkingDirectory: (cwd: string) => `現在の作業ディレクトリは '${cwd}' に設定されています。`,
        foundFilePath: (filePath: string) => `指定されたファイルパスは存在します: '${filePath}'。`,
        foundFilePathToLoad: (filePath: string) => `読み込むファイルパスは '${filePath}' に設定されています。`,
        foundFocusEditor: () => `フォーカスされているエディターがあります。`,
        foundLanguageComment: () => `言語コメントファイルが存在します。`,
        foundLogoInstance: () => `ロゴインスタンスが提供されました。`,
        foundLogoRootDir: (rootDir: string) => `現在のロゴのルートディレクトリは '${rootDir}' です。`,
        foundNewLine: (newLineType: string) => `新しく検出された改行タイプは '${newLineType}' です。`,
        foundWorkingDirectory: () => `指定された作業ディレクトリは存在します。`,
        fromMorseGetInput: (): string => "変換元のテキストを入力してください",
        getHeaderDescription: () => "説明を入力してください: ",
        getHeaderPurpose: () => "ファイルの目的を入力してください: ",
        getHeaderTags: () => "このファイルのタグをカンマで区切って入力してください: ",
        headerInjectQuestion: () => "このドキュメントにヘッダーが見つかりません。追加しますか？",
        headerInjectQuestionRefused: () => "ファイルにヘッダーを追加しないことにしました。",
        headerNotFound: () => "このドキュメントにヘッダーが見つかりません。",
        headerOpenerAndCloserFound: () => "ヘッダーの開始と終了が見つかりました。チェック後、日付を更新します。",
        headerOpenerFound: () => "ヘッダーの開始が見つかりました。",
        headerWriteFailed: () => "ファイルにヘッダーを書き込めませんでした。ログを確認してください。",
        headerWriteSuccess: () => "ヘッダーを書き込みました。",
        helloWorldGreetingsCommand: (moduleName: string) => `Hello World from ${moduleName}！`,
        identifiedLanguage: (langName: string) => `識別された言語: ${langName}。`,
        inFunction: (functionName: string, className: string = "未指定") => `関数: '${functionName}' （クラス: '${className}'）内`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string) => `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        inputboxError: (promptText: string, err: string) => `${promptText} の入力ボックスでエラーが発生しました: ${err}`,
        jsonContent: (jsonContentString: String) => `コメント JSON ファイルの内容: ${jsonContentString}`,
        languageNotFound: (LanguageId: string, fileExtension: string) => `このドキュメントのファイル言語を識別できません。languageID: ${LanguageId}, ファイル拡張子: ${fileExtension}`,
        lastModifiedLineNotFound: () => "ヘッダーに「最終更新日」行がありません。",
        lastModifiedUpdated: () => "「最終更新日」が正常に更新されました。",
        logoChosen: (logo: string[]) => `表示するロゴ: ${JSON.stringify(logo)}`,
        logoCopied: (logoName: string) => `${logoName} の ASCII アートをコピーしました！`,
        logoCopyAscii: () => "ASCII をコピー",
        logoDisplayed: (name: string) => `ロゴ '${name}' を表示しました。`,
        logoMessage: (logoPath: string) => `ファイル (${logoPath}) は対象タイプではないため無視されました。`,
        logoName: () => "ロゴ名",
        logoNoRootDir: () => "ロゴを収集するためのルートディレクトリが提供されていません",
        logoNotFound: () => "ロゴが見つかりません",
        logoRootDirUpdateError: (error: string) => `ロゴファイルの更新中にエラーが発生しました: ${error}`,
        logoView: () => "ロゴビュー",
        logoZoomIn: (): string => "ズームイン",
        logoZoomOut: (): string => "ズームアウト",
        messageNotFound: (key: string) => `メッセージ '${key}' が見つかりません。`,
        messageWritten: () => "メッセージを書き込みました",
        missingFileError: () => "言語辞書がありません。コメントの適応性は無効です。",
        missingLanguageComment: () => "言語コメントが提供されていません。割り当てをスキップします。",
        morseConverted: (input: string, final: string) => `変換: ${input} → ${final}`,
        morseDecoded: (input: string, final: string) => `復号: ${input} → ${final}`,
        noActiveEditor: () => "アクティブなファイルがありません！",
        noCommentToShow: () => "表示するコメントはありません。",
        noFilesAvailableForLoading: (): string => "読み込むことができるファイルがありません。",
        noFocusedEditors: () => "フォーカスされているファイルはありません。",
        noLogoInstanceProvided: () => "提供されたロゴランダマイザーのインスタンスがありません。",
        noProvidedCommentOptions: () => "提供されたコメントオプションはありません。",
        notFoundFilePath: (filePath: string, error: string = "未提供") => `指定されたファイルパスは存在しません: '${filePath}'、エラー: '${error}'`,
        openFileToApplyHeader: () => "ヘッダーを適用するファイルを開いてください。",
        operationCanceled: (): string => "操作がキャンセルされました",
        quickPickError: (err: string) => `QuickPick でエラーが発生しました: ${err}`,
        quickPickNo: () => "いいえ",
        quickPickYes: () => "はい",
        ramdomLogoGatheringLogoUndefined: () => "ロゴの内容が未定義です。",
        randomLogoGatheringFailed: (error: string) => `ランダムロゴの収集に失敗しました。デフォルトロゴを使用します。エラー: "${error}"`,
        readTimeout: (timeout: number, filePath: string): string => `${filePath} の読み込みが ${timeout}ms 後にタイムアウトしました。`,
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string) => `Hello World! ファイルの拡張子: ${fileExtension}, 名前: ${fileName}, パス: ${filePath}, 言語: ${languageId}\n`,
        toMorseGetInput: (): string => "変換するテキストを入力してください",
        unknown: () => "不明",
        unknownFileStructure: () => "言語辞書の構造が不明です。コメントの適応性は無効です。",
        updateAbortedBecauseFileClosedSyncCancelled: () => "ファイルが閉じられているため、更新は中止され同期されません。",
        updateEditDateMissingBounds: () => "ヘッダーを更新できません: 内部マーカーが見つかりません。",
        updatingEditionDate: () => "編集日を更新しています。",
        watermarkAuthorName: () => "作成者名",
        watermarkChosen: (watermark: string[]) => `表示するウォーターマーク: ${JSON.stringify(watermark)}`,
        watermarkCopied: (name: string) => `${name} の ASCII アートをコピーしました！`,
        watermarkCopyAscii: () => "ASCII をコピー",
        watermarkJsonFileInvalid: () => "ウォーターマーク JSON ファイルが空または無効です",
        watermarkName: () => "ウォーターマーク名",
        watermarkNotFound: () => "ウォーターマークが見つかりません",
        watermarkPersonDisplayed: (name: string) => `ウォーターマーク '${name}' を表示しました。`,
        watermarkView: () => "ウォーターマークビュー",
        watermarkZoomIn: () => "ズームイン",
        watermarkZoomOut: () => "ズームアウト"
    },
    "ko": {
        alternateFilePathUpdated: (oldFilePath: string, newFilePath: string): string => `대체 경로가 ${oldFilePath} 에서 ${newFilePath}(으)로 업데이트되었습니다.`,
        alternateLogoDirectoryNotFound: (alternateRootDirectory: string, error: string = "제공되지 않음") => `대체 로고 루트 디렉터리 '${alternateRootDirectory}'를 찾을 수 없습니다, 오류: '${error}'.`,
        alternateLogoDirectoryNotProvided: () => `대체 로고 디렉터리가 제공되지 않았습니다.`,
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]) => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}.`,
        brokenHeader: () => "손상된 헤더가 감지되었습니다. 새 헤더를 삽입합니다. 이전 것을 삭제하세요.",
        cacheAlreadyLoaded: (): string => "캐시가 이미 로드되어 저장된 인스턴스를 반환합니다.",
        chooseSingleLineCommentOption: () => "아래 옵션에서 원하는 주석 접두사를 선택하세요: ",
        closedDocument: () => "문서가 닫혀 있어 작업을 중단합니다.",
        convertedContentCli: (content: string): string => `변환된 내용: ${content}`,
        convertedContentGui: (): string => "변환된 내용: ",
        corruptedFileMetaData: () => "필요한 파일 메타데이터가 올바르게 수집되지 않았습니다. 중단합니다.",
        cwdDoesNotExist: (cwd: string) => `제공된 작업 디렉터리 ${cwd}가 존재하지 않습니다.`,
        cwdUpdated: (oldCwd: string, newCwd: string) => `현재 작업 디렉터리가 ${oldCwd}에서 ${newCwd}로 업데이트되었습니다.`,
        darlingAge: () => "나이",
        darlingAlias: () => "별명",
        darlingCopied: (name: string) => `${name}의 ASCII 아트가 복사되었습니다!`,
        darlingCopyAscii: () => "ASCII 복사",
        darlingDescription: () => "설명",
        darlingHeight: () => "키",
        darlingImage: () => "이미지",
        darlingJsonFileInvalid: () => "Darling JSON 파일이 비어 있거나 유효하지 않습니다",
        darlingMoreInfo: () => "추가 정보",
        darlingPersonDisplayed: (name: string) => `캐릭터 '${name}' 표시됨.`,
        darlingQuote: () => "인용구",
        darlingType: () => "유형",
        darlingView: () => "캐릭터 뷰",
        darlingZoomIn: () => "확대",
        darlingZoomOut: () => "축소",
        documentLineScanExceeded: (maxScanLength: number) => `파일의 처음 ${maxScanLength}줄을 스캔했지만 헤더를 찾을 수 없습니다.`,
        emptyDocument: () => "작업할 문서 내용이 없습니다.",
        errorDuringFunctionCall: (functionName: string) => `함수 (${functionName}) 호출 중 오류가 발생했습니다. 로그를 확인하세요.`,
        extensionActivated: (moduleName: string) => `🚀 "${moduleName}" 확장이 활성화되었습니다!`,
        fileExcludedActivationDisabled: () => "활성화 비활성화됨, 파일이 제외 목록에 있습니다.",
        fileLength: (filePath: string, fileLength: number): string => `파일: '${filePath}', 길이: ${fileLength}바이트.`,
        fileLoaded: (absolutePath: string) => `파일 ${absolutePath} 로드 완료!`,
        fileLoadError: (filePath: string, error: string = "제공되지않음"): string => `파일 '${filePath}'을(를) 로드하지 못했습니다. 오류: ${error}.`,
        fileNotFound: (filePath: string): string => `파일을 찾을 수 없습니다: ${filePath}`,
        fileParseError: (filePath: string, error: string) => `파일 내용 (${filePath})을(를) 정상적으로 로드할 수 없습니다. 오류: ${error}.`,
        filepathPresenceCheck: (filePath: string): string => `파일 경로 존재 여부 확인 중: ${filePath}`,
        filePathProcessing: (filepath: string): string => `파일 경로 처리 중: '${filepath}'.`,
        filePathUpdated: (oldFilePath: string, newFilePath: string) => `경로가 ${oldFilePath}에서 ${newFilePath}로 업데이트되었습니다.`,
        fileRefreshed: () => "파일 내용을 새로 고치는 중입니다.",
        fileSaveFailed: () => "파일 저장 실패, 다시 시도하십시오.",
        fileUnloaded: (filePath: string) => `파일 ${filePath}이(가) 메모리에서 언로드되었습니다.`,
        foundAlternateFilePathToLoad: (alternateFilePath: string) => `로드할 대체 파일 경로가 '${alternateFilePath}'로 설정되었습니다.`,
        foundAlternateLogoRootDir: (rootDir: string) => `현재 대체 로고 루트 디렉터리는 '${rootDir}'입니다.`,
        foundCurrentWorkingDirectory: (cwd: string) => `현재 작업 디렉터리가 '${cwd}'로 설정되었습니다.`,
        foundFilePath: (filePath: string) => `제공된 파일 경로가 존재합니다: '${filePath}'.`,
        foundFilePathToLoad: (filePath: string) => `로드할 파일 경로가 '${filePath}'로 설정되었습니다.`,
        foundFocusEditor: () => `포커스된 에디터가 있습니다.`,
        foundLanguageComment: () => `언어 주석 파일이 존재합니다.`,
        foundLogoInstance: () => `로고 인스턴스가 제공되었습니다.`,
        foundLogoRootDir: (rootDir: string) => `현재 로고 루트 디렉터리는 '${rootDir}'입니다.`,
        foundNewLine: (newLineType: string) => `새로 감지된 줄바꿈 유형은 '${newLineType}'입니다.`,
        foundWorkingDirectory: () => `제공된 작업 디렉터리가 존재합니다.`,
        fromMorseGetInput: (): string => "변환할 원본 텍스트를 입력하세요",
        getHeaderDescription: () => "설명을 입력하세요: ",
        getHeaderPurpose: () => "파일의 목적을 입력하세요: ",
        getHeaderTags: () => "이 파일의 태그를 쉼표로 구분하여 입력하세요: ",
        headerInjectQuestion: () => "이 문서에서 헤더를 찾을 수 없습니다. 추가하시겠습니까?",
        headerInjectQuestionRefused: () => "파일에 헤더를 추가하지 않기로 결정했습니다.",
        headerNotFound: () => "이 문서에서 헤더를 찾을 수 없습니다.",
        headerOpenerAndCloserFound: () => "헤더 시작 및 종료 발견, 검사 후 날짜를 업데이트합니다.",
        headerOpenerFound: () => "헤더 시작 발견.",
        headerWriteFailed: () => "파일에 헤더를 쓸 수 없습니다. 로그를 확인하세요.",
        headerWriteSuccess: () => "헤더가 성공적으로 작성되었습니다.",
        helloWorldGreetingsCommand: (moduleName: string) => `Hello World from ${moduleName}!`,
        identifiedLanguage: (langName: string) => `식별된 언어: ${langName}.`,
        inFunction: (functionName: string, className: string = "지정되지 않음") => `함수: '${functionName}' (클래스: '${className}') 내부`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string) => `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        inputboxError: (promptText: string, err: string) => `${promptText} 입력 상자에서 오류 발생: ${err}`,
        jsonContent: (jsonContentString: String) => `주석 JSON 파일 내용: ${jsonContentString}`,
        languageNotFound: (LanguageId: string, fileExtension: string) => `이 문서의 파일 언어를 식별할 수 없습니다. languageID: ${LanguageId}, 파일 확장자: ${fileExtension}`,
        lastModifiedLineNotFound: () => "헤더에 '마지막 수정일' 라인이 없습니다.",
        lastModifiedUpdated: () => "'마지막 수정일'이 성공적으로 업데이트되었습니다.",
        logoChosen: (logo: string[]) => `표시할 로고: ${JSON.stringify(logo)}`,
        logoCopied: (logoName: string) => `${logoName}의 ASCII 아트가 복사되었습니다!`,
        logoCopyAscii: () => "ASCII 복사",
        logoDisplayed: (name: string) => `로고 '${name}' 표시됨.`,
        logoMessage: (logoPath: string) => `파일 (${logoPath})은(는) 원하는 유형이 아니므로 무시됩니다.`,
        logoName: () => "로고 이름",
        logoNoRootDir: () => "로고를 수집할 루트 디렉터리가 제공되지 않았습니다",
        logoNotFound: () => "로고를 찾을 수 없음",
        logoRootDirUpdateError: (error: string) => `로고 파일 업데이트 중 오류 발생: ${error}`,
        logoView: () => "로고 뷰",
        logoZoomIn: (): string => "확대",
        logoZoomOut: (): string => "축소",
        messageNotFound: (key: string) => `메시지 '${key}'를 찾을 수 없습니다.`,
        messageWritten: () => "메시지 작성 완료",
        missingFileError: () => "언어 사전이 없습니다. 주석 적응 기능이 비활성화됩니다.",
        missingLanguageComment: () => "언어 주석이 제공되지 않았습니다. 할당을 건너뜁니다.",
        morseConverted: (input: string, final: string) => `변환됨: ${input} → ${final}`,
        morseDecoded: (input: string, final: string) => `복호화됨: ${input} → ${final}`,
        noActiveEditor: () => "활성 파일이 없습니다!",
        noCommentToShow: () => "표시할 주석이 없습니다.",
        noFilesAvailableForLoading: (): string => "로드할 수 있는 파일이 없습니다.",
        noFocusedEditors: () => "포커스된 파일이 없습니다.",
        noLogoInstanceProvided: () => "제공된 로고 랜덤 인스턴스가 없습니다.",
        noProvidedCommentOptions: () => "제공된 주석 옵션이 없습니다.",
        notFoundFilePath: (filePath: string, error: string = "제공되지 않음") => `제공된 파일 경로가 존재하지 않습니다: '${filePath}', 오류: '${error}'`,
        openFileToApplyHeader: () => "헤더를 적용할 파일을 열어주세요.",
        operationCanceled: (): string => "작업이 취소되었습니다",
        quickPickError: (err: string) => `QuickPick에서 오류 발생: ${err}`,
        quickPickNo: () => "아니오",
        quickPickYes: () => "예",
        ramdomLogoGatheringLogoUndefined: () => "로고 내용이 정의되지 않았습니다.",
        randomLogoGatheringFailed: (error: string) => `랜덤 로고 수집 실패, 기본 로고 사용, 오류: "${error}"`,
        readTimeout: (timeout: number, filePath: string): string => `${filePath}의 읽기 시간이 ${timeout}ms 후 초과되었습니다.`,
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string) => `Hello World! 파일 확장자: ${fileExtension}, 이름: ${fileName}, 경로: ${filePath}, 언어: ${languageId}\n`,
        toMorseGetInput: (): string => "변환할 텍스트를 입력하세요",
        unknown: () => "알 수 없음",
        unknownFileStructure: () => "언어 사전 구조를 알 수 없습니다. 주석 적응 기능이 비활성화됩니다.",
        updateAbortedBecauseFileClosedSyncCancelled: () => "파일이 닫혀 있어 업데이트가 중단되었으며 동기화되지 않습니다.",
        updateEditDateMissingBounds: () => "헤더를 업데이트할 수 없습니다: 내부 마커를 찾을 수 없습니다.",
        updatingEditionDate: () => "수정일을 업데이트 중입니다.",
        watermarkAuthorName: () => "작성자 이름",
        watermarkChosen: (watermark: string[]) => `표시할 워터마크: ${JSON.stringify(watermark)}`,
        watermarkCopied: (name: string) => `${name}의 ASCII 아트가 복사되었습니다!`,
        watermarkCopyAscii: () => "ASCII 복사",
        watermarkJsonFileInvalid: () => "워터마크 JSON 파일이 비어 있거나 유효하지 않습니다",
        watermarkName: () => "워터마크 이름",
        watermarkNotFound: () => "워터마크를 찾을 수 없음",
        watermarkPersonDisplayed: (name: string) => `워터마크 '${name}' 표시됨.`,
        watermarkView: () => "워터마크 뷰",
        watermarkZoomIn: () => "확대",
        watermarkZoomOut: () => "축소"
    },
    "ru": {
        alternateFilePathUpdated: (oldFilePath: string, newFilePath: string): string => `Альтернативный путь был обновлён с ${oldFilePath} на ${newFilePath}.`,
        alternateLogoDirectoryNotFound: (alternateRootDirectory: string, error: string = "Не предоставлено") => `Альтернативный корневой каталог логотипов '${alternateRootDirectory}' не найден, ошибка: '${error}'.`,
        alternateLogoDirectoryNotProvided: () => `Альтернативный каталог логотипов не указан.`,
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]) => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}.`,
        brokenHeader: () => "Обнаружен поврежденный заголовок, вставляется новый, удалите предыдущий.",
        cacheAlreadyLoaded: (): string => "Кэш уже загружен, возвращается сохранённый экземпляр.",
        chooseSingleLineCommentOption: () => "Пожалуйста, выберите предпочитаемый префикс комментария из предложенных вариантов: ",
        closedDocument: () => "Документ закрыт, операция остановлена.",
        convertedContentCli: (content: string): string => `Преобразованный контент: ${content}`,
        convertedContentGui: (): string => "Преобразованный контент: ",
        corruptedFileMetaData: () => "Не удалось корректно собрать необходимые метаданные файла, прерывание.",
        cwdDoesNotExist: (cwd: string) => `Указанный рабочий каталог ${cwd} не существует.`,
        cwdUpdated: (oldCwd: string, newCwd: string) => `Текущий рабочий каталог обновлен с ${oldCwd} на ${newCwd}.`,
        darlingAge: () => "Возраст",
        darlingAlias: () => "Псевдоним",
        darlingCopied: (name: string) => `ASCII-арт для ${name} скопирован!`,
        darlingCopyAscii: () => "Скопировать ASCII",
        darlingDescription: () => "Описание",
        darlingHeight: () => "Рост",
        darlingImage: () => "Изображение",
        darlingJsonFileInvalid: () => "Файл JSON персонажа пуст или недействителен",
        darlingMoreInfo: () => "Доп. информация",
        darlingPersonDisplayed: (name: string) => `Персонаж '${name}' отображен.`,
        darlingQuote: () => "Цитата",
        darlingType: () => "Тип",
        darlingView: () => "просмотр персонажа",
        darlingZoomIn: () => "Увеличить",
        darlingZoomOut: () => "Уменьшить",
        documentLineScanExceeded: (maxScanLength: number) => `Просканировано первые ${maxScanLength} строки файла, заголовок не найден.`,
        emptyDocument: () => "Нет содержимого документа для работы.",
        errorDuringFunctionCall: (functionName: string) => `Произошла ошибка при вызове функции (${functionName}), проверьте логи.`,
        extensionActivated: (moduleName: string) => `🚀 Расширение "${moduleName}" теперь активно!`,
        fileExcludedActivationDisabled: () => "Активация отключена, файл находится в списке исключений.",
        fileLength: (filePath: string, fileLength: number): string => `Файл: '${filePath}', длина: ${fileLength} байт.`,
        fileLoaded: (absolutePath: string) => `Файл ${absolutePath} загружен!`,
        fileLoadError: (filePath: string, error: string = "НеПредоставлено"): string => `Не удалось загрузить файл: '${filePath}'. Ошибка: ${error}.`,
        fileNotFound: (filePath: string): string => `Файл не найден: ${filePath}`,
        fileParseError: (filePath: string, error: string) => `Содержимое файла (${filePath}) не удалось загрузить. Ошибка: ${error}.`,
        filepathPresenceCheck: (filePath: string): string => `Проверка наличия пути к файлу: ${filePath}`,
        filePathProcessing: (filepath: string): string => `Обработка пути к файлу: '${filepath}'.`,
        filePathUpdated: (oldFilePath: string, newFilePath: string) => `Путь обновлен с ${oldFilePath} на ${newFilePath}.`,
        fileRefreshed: () => "Обновление содержимого файла.",
        fileSaveFailed: () => "Не удалось сохранить файл, попробуйте снова.",
        fileUnloaded: (filePath: string) => `Файл ${filePath} выгружен из памяти.`,
        foundAlternateFilePathToLoad: (alternateFilePath: string) => `Альтернативный путь к файлу для загрузки: '${alternateFilePath}'.`,
        foundAlternateLogoRootDir: (rootDir: string) => `Текущий альтернативный корневой каталог логотипов: '${rootDir}'.`,
        foundCurrentWorkingDirectory: (cwd: string) => `Текущий рабочий каталог: '${cwd}'.`,
        foundFilePath: (filePath: string) => `Указанный путь к файлу существует: '${filePath}'.`,
        foundFilePathToLoad: (filePath: string) => `Путь к файлу для загрузки: '${filePath}'.`,
        foundFocusEditor: () => `Активен редактор.`,
        foundLanguageComment: () => `Файл языковых комментариев найден.`,
        foundLogoInstance: () => `Экземпляр логотипа предоставлен.`,
        foundLogoRootDir: (rootDir: string) => `Текущий корневой каталог логотипов: '${rootDir}'.`,
        foundNewLine: (newLineType: string) => `Новый тип строки: '${newLineType}'.`,
        foundWorkingDirectory: () => `Указанный рабочий каталог существует.`,
        fromMorseGetInput: (): string => "Введите текст для преобразования из",
        getHeaderDescription: () => "Пожалуйста, предоставьте описание: ",
        getHeaderPurpose: () => "Пожалуйста, укажите назначение файла: ",
        getHeaderTags: () => "Введите теги для этого файла через запятую: ",
        headerInjectQuestion: () => "Заголовок в этом документе не найден. Хотите добавить его?",
        headerInjectQuestionRefused: () => "Вы решили не добавлять заголовок в файл.",
        headerNotFound: () => "Заголовок в этом документе не найден.",
        headerOpenerAndCloserFound: () => "Начало и конец заголовка найдены, выполняется обновление даты после проверки.",
        headerOpenerFound: () => "Начало заголовка найдено.",
        headerWriteFailed: () => "Не удалось записать заголовок в файл, проверьте логи.",
        headerWriteSuccess: () => "Заголовок успешно записан.",
        helloWorldGreetingsCommand: (moduleName: string) => `Hello World из ${moduleName}!`,
        identifiedLanguage: (langName: string) => `Определенный язык: ${langName}.`,
        inFunction: (functionName: string, className: string = "Не указано") => `В функции: '${functionName}' из класса: '${className}'`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string) => `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        inputboxError: (promptText: string, err: string) => `Ошибка в поле ввода для ${promptText}: ${err}`,
        jsonContent: (jsonContentString: String) => `Содержимое JSON-файла комментариев: ${jsonContentString}`,
        languageNotFound: (LanguageId: string, fileExtension: string) => `Не удалось определить язык файла этого документа, languageID: ${LanguageId}, расширение файла: ${fileExtension}`,
        lastModifiedLineNotFound: () => "В заголовке отсутствует строка 'Последнее изменение' для обновления.",
        lastModifiedUpdated: () => "Дата 'Последнее изменение' успешно обновлена.",
        logoChosen: (logo: string[]) => `Выбранный логотип: ${JSON.stringify(logo)}`,
        logoCopied: (logoName: string) => `ASCII-арт для ${logoName} скопирован!`,
        logoCopyAscii: () => "Скопировать ASCII",
        logoDisplayed: (name: string) => `Логотип '${name}' отображен.`,
        logoMessage: (logoPath: string) => `Файл (${logoPath}) проигнорирован, так как это не нужный тип.`,
        logoName: () => "Название логотипа",
        logoNoRootDir: () => "Не предоставлен корневой каталог для сбора логотипов",
        logoNotFound: () => "Логотип не найден",
        logoRootDirUpdateError: (error: string) => `Ошибка при обновлении файлов логотипа: ${error}`,
        logoView: () => "просмотр логотипа",
        logoZoomIn: (): string => "Увеличить",
        logoZoomOut: (): string => "Уменьшить",
        messageNotFound: (key: string) => `Сообщение '${key}' не найдено.`,
        messageWritten: () => "Сообщение записано",
        missingFileError: () => "Словарь языка отсутствует, адаптация комментариев отключена.",
        missingLanguageComment: () => "Комментарий для языка не предоставлен, пропуск присвоения.",
        morseConverted: (input: string, final: string) => `Преобразовано: ${input} → ${final}`,
        morseDecoded: (input: string, final: string) => `Декодировано: ${input} → ${final}`,
        noActiveEditor: () => "Нет активного файла!",
        noCommentToShow: () => "Нет комментариев для отображения.",
        noFilesAvailableForLoading: (): string => "Нет файлов, доступных для загрузки.",
        noFocusedEditors: () => "Нет файлов в фокусе.",
        noLogoInstanceProvided: () => "Не предоставлен экземпляр рандомизатора логотипа.",
        noProvidedCommentOptions: () => "Нет предоставленных опций комментариев.",
        notFoundFilePath: (filePath: string, error: string = "Не предоставлено") => `Указанный путь к файлу не существует: '${filePath}', ошибка: '${error}'`,
        openFileToApplyHeader: () => "Пожалуйста, откройте файл, чтобы применить заголовок.",
        operationCanceled: (): string => "Операция отменена",
        quickPickError: (err: string) => `Ошибка в quickPick: ${err}`,
        quickPickNo: () => "Нет",
        quickPickYes: () => "Да",
        ramdomLogoGatheringLogoUndefined: () => "Содержимое логотипа неопределено.",
        randomLogoGatheringFailed: (error: string) => `Сбор случайного логотипа не удался, используется логотип по умолчанию, ошибка: "${error}"`,
        readTimeout: (timeout: number, filePath: string): string => `Время ожидания чтения истекло через ${timeout} мс для ${filePath}`,
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string) => `Hello World! Расширение файла: ${fileExtension}, имя: ${fileName}, путь: ${filePath}, язык: ${languageId}\n`,
        toMorseGetInput: (): string => "Введите текст для преобразования",
        unknown: () => "Неизвестно",
        unknownFileStructure: () => "Структура словаря языка неизвестна, адаптация комментариев отключена.",
        updateAbortedBecauseFileClosedSyncCancelled: () => "Обновление прервано, так как файл закрыт и не будет синхронизирован.",
        updateEditDateMissingBounds: () => "Не удалось обновить заголовок: внутренние маркеры не найдены.",
        updatingEditionDate: () => "Обновление даты редактирования.",
        watermarkAuthorName: () => "Имя автора",
        watermarkChosen: (watermark: string[]) => `Выбранный водяной знак: ${JSON.stringify(watermark)}`,
        watermarkCopied: (name: string) => `ASCII-арт для ${name} скопирован!`,
        watermarkCopyAscii: () => "Скопировать ASCII",
        watermarkJsonFileInvalid: () => "Файл JSON водяного знака пуст или недействителен",
        watermarkName: () => "Название водяного знака",
        watermarkNotFound: () => "Водяной знак не найден",
        watermarkPersonDisplayed: (name: string) => `Водяной знак '${name}' отображен.`,
        watermarkView: () => "просмотр водяного знака",
        watermarkZoomIn: () => "Увеличить",
        watermarkZoomOut: () => "Уменьшить"
    },
    "pt-br": {
        alternateFilePathUpdated: (oldFilePath: string, newFilePath: string): string => `O caminho alternativo foi atualizado de ${oldFilePath} para ${newFilePath}.`,
        alternateLogoDirectoryNotFound: (alternateRootDirectory: string, error: string = "Não fornecido") => `O diretório raiz alternativo do logotipo '${alternateRootDirectory}' não foi encontrado, erro: '${error}'.`,
        alternateLogoDirectoryNotProvided: () => `Nenhum diretório alternativo de logotipo foi fornecido.`,
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]) => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}.`,
        brokenHeader: () => "Cabeçalho corrompido detectado, inserindo novo, por favor remova o anterior.",
        cacheAlreadyLoaded: (): string => "O cache já está carregado, retornando a instância armazenada.",
        chooseSingleLineCommentOption: () => "Por favor, selecione seu prefixo de comentário preferido entre as opções abaixo:",
        closedDocument: () => "O documento está fechado, interrompendo operações.",
        convertedContentCli: (content: string): string => `Conteúdo convertido: ${content}`,
        convertedContentGui: (): string => "Conteúdo convertido: ",
        corruptedFileMetaData: () => "Os metadados do arquivo não foram coletados corretamente, abortando.",
        cwdDoesNotExist: (cwd: string) => `O diretório de trabalho fornecido ${cwd} não existe.`,
        cwdUpdated: (oldCwd: string, newCwd: string) => `O diretório de trabalho atual foi atualizado de ${oldCwd} para ${newCwd}.`,
        darlingAge: () => "Idade",
        darlingAlias: () => "Apelido",
        darlingCopied: (name: string) => `ASCII art copiado para ${name}!`,
        darlingCopyAscii: () => "Copiar ASCII",
        darlingDescription: () => "Descrição",
        darlingHeight: () => "Altura",
        darlingImage: () => "Imagem",
        darlingJsonFileInvalid: () => "O arquivo JSON do personagem está vazio ou inválido",
        darlingMoreInfo: () => "Mais informações",
        darlingPersonDisplayed: (name: string) => `Personagem '${name}' exibido.`,
        darlingQuote: () => "Citação",
        darlingType: () => "Tipo",
        darlingView: () => "visualização do personagem",
        darlingZoomIn: () => "Aumentar zoom",
        darlingZoomOut: () => "Diminuir zoom",
        documentLineScanExceeded: (maxScanLength: number) => `Verificadas as primeiras ${maxScanLength} linhas do arquivo, mas nenhum cabeçalho encontrado.`,
        emptyDocument: () => "Não há corpo do documento para trabalhar.",
        errorDuringFunctionCall: (functionName: string) => `Algo deu errado durante a chamada da função (${functionName}), verifique os logs.`,
        extensionActivated: (moduleName: string) => `🚀 "${moduleName}" agora está ativo!`,
        fileExcludedActivationDisabled: () => "Ativação desativada, o arquivo está na lista de exclusão.",
        fileLength: (filePath: string, fileLength: number): string => `Arquivo: '${filePath}', tamanho: ${fileLength} bytes.`,
        fileLoaded: (absolutePath: string) => `Arquivo ${absolutePath} carregado!`,
        fileLoadError: (filePath: string, error: string = "NãoFornecido"): string => `Falha ao carregar o arquivo: '${filePath}'. Erro: ${error}.`,
        fileNotFound: (filePath: string): string => `Arquivo não encontrado: ${filePath}`,
        fileParseError: (filePath: string, error: string) => `O conteúdo do arquivo (${filePath}) não pôde ser carregado com sucesso. Erro: ${error}.`,
        filepathPresenceCheck: (filePath: string): string => `Verificando a presença do caminho do arquivo: ${filePath}`,
        filePathProcessing: (filepath: string): string => `Processando o caminho do arquivo: '${filepath}'.`,
        filePathUpdated: (oldFilePath: string, newFilePath: string) => `O caminho foi atualizado de ${oldFilePath} para ${newFilePath}.`,
        fileRefreshed: () => "Atualizando o conteúdo do arquivo.",
        fileSaveFailed: () => "Falha ao salvar o arquivo, por favor tente novamente.",
        fileUnloaded: (filePath: string) => `Arquivo ${filePath} descarregado da memória.`,
        foundAlternateFilePathToLoad: (alternateFilePath: string) => `O caminho alternativo do arquivo a ser carregado está definido como '${alternateFilePath}'.`,
        foundAlternateLogoRootDir: (rootDir: string) => `O diretório raiz alternativo atual do logotipo é: '${rootDir}'.`,
        foundCurrentWorkingDirectory: (cwd: string) => `O diretório de trabalho atual está definido como '${cwd}'.`,
        foundFilePath: (filePath: string) => `O caminho do arquivo fornecido existe: '${filePath}'.`,
        foundFilePathToLoad: (filePath: string) => `O caminho do arquivo a ser carregado está definido como '${filePath}'.`,
        foundFocusEditor: () => `Há um editor em foco.`,
        foundLanguageComment: () => `O arquivo de comentários de idioma está presente.`,
        foundLogoInstance: () => `Uma instância de logotipo foi fornecida.`,
        foundLogoRootDir: (rootDir: string) => `O diretório raiz atual do logotipo é: '${rootDir}'.`,
        foundNewLine: (newLineType: string) => `O novo tipo de linha determinado é '${newLineType}'.`,
        foundWorkingDirectory: () => `O diretório de trabalho fornecido existe.`,
        fromMorseGetInput: (): string => "Por favor, insira o texto para converter de",
        getHeaderDescription: () => "Por favor, forneça uma descrição: ",
        getHeaderPurpose: () => "Por favor, forneça o propósito do arquivo:",
        getHeaderTags: () => "Digite as tags para este arquivo, separadas por vírgulas:",
        headerInjectQuestion: () => "Nenhum cabeçalho encontrado neste documento. Deseja adicionar um?",
        headerInjectQuestionRefused: () => "Você optou por não adicionar um cabeçalho ao arquivo.",
        headerNotFound: () => "Nenhum cabeçalho encontrado neste documento.",
        headerOpenerAndCloserFound: () => "Início e fim do cabeçalho encontrados, atualizando data após verificação.",
        headerOpenerFound: () => "Início do cabeçalho encontrado.",
        headerWriteFailed: () => "Falha ao escrever o cabeçalho no arquivo, verifique os logs.",
        headerWriteSuccess: () => "Cabeçalho escrito com sucesso.",
        helloWorldGreetingsCommand: (moduleName: string) => `Olá Mundo do ${moduleName}!`,
        identifiedLanguage: (langName: string) => `Idioma identificado: ${langName}.`,
        inFunction: (functionName: string, className: string = "Não especificado") => `Na função: '${functionName}' da classe: '${className}'`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string) => `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        inputboxError: (promptText: string, err: string) => `Erro na caixa de entrada para ${promptText}: ${err}`,
        jsonContent: (jsonContentString: String) => `Conteúdo do arquivo JSON de comentários: ${jsonContentString}`,
        languageNotFound: (LanguageId: string, fileExtension: string) => `Não foi possível identificar o idioma do arquivo deste documento, languageID: ${LanguageId}, extensão do arquivo: ${fileExtension}`,
        lastModifiedLineNotFound: () => "O cabeçalho não contém uma linha 'Última Modificação' para atualizar.",
        lastModifiedUpdated: () => "Data de 'Última Modificação' atualizada com sucesso.",
        logoChosen: (logo: string[]) => `Logotipo a ser exibido: ${JSON.stringify(logo)}`,
        logoCopied: (logoName: string) => `ASCII art copiado para ${logoName}!`,
        logoCopyAscii: () => "Copiar ASCII",
        logoDisplayed: (name: string) => `Logotipo '${name}' exibido.`,
        logoMessage: (logoPath: string) => `Arquivo (${logoPath}) ignorado, pois não é do tipo esperado.`,
        logoName: () => "Nome do logotipo",
        logoNoRootDir: () => "Nenhum diretório raiz fornecido para coleta de logotipos",
        logoNotFound: () => "Logotipo não encontrado",
        logoRootDirUpdateError: (error: string) => `Erro ao atualizar arquivos de logotipo: ${error}`,
        logoView: () => "visualização do logotipo",
        logoZoomIn: (): string => "Aumentar Zoom",
        logoZoomOut: (): string => "Diminuir Zoom",
        messageNotFound: (key: string) => `Mensagem '${key}' não encontrada.`,
        messageWritten: () => "Mensagem escrita",
        missingFileError: () => "O dicionário de idioma está faltando, adaptabilidade de comentário desativada.",
        missingLanguageComment: () => "Comentário de idioma não fornecido, atribuição ignorada.",
        morseConverted: (input: string, final: string) => `Convertido: ${input} para ${final}`,
        morseDecoded: (input: string, final: string) => `Decodificado: ${input} para ${final}`,
        noActiveEditor: () => "Nenhum arquivo ativo!",
        noCommentToShow: () => "Não há comentários para exibir.",
        noFilesAvailableForLoading: (): string => "Não há arquivos disponíveis para carregar.",
        noFocusedEditors: () => "Não há arquivos em foco.",
        noLogoInstanceProvided: () => "Nenhuma instância de randomizador de logotipo fornecida.",
        noProvidedCommentOptions: () => "Nenhuma opção de comentário fornecida.",
        notFoundFilePath: (filePath: string, error: string = "Não fornecido") => `O caminho do arquivo fornecido não existe: '${filePath}', erro: '${error}'`,
        openFileToApplyHeader: () => "Por favor, abra um arquivo para aplicar o cabeçalho.",
        operationCanceled: (): string => "Operação cancelada",
        quickPickError: (err: string) => `Erro no quickPick: ${err}`,
        quickPickNo: () => "Não",
        quickPickYes: () => "Sim",
        ramdomLogoGatheringLogoUndefined: () => "O conteúdo do logotipo está indefinido.",
        randomLogoGatheringFailed: (error: string) => `Falha na coleta aleatória de logotipos, usando logotipo padrão, erro: "${error}"`,
        readTimeout: (timeout: number, filePath: string): string => `Tempo de leitura esgotado após ${timeout}ms para ${filePath}`,
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string) => `Olá mundo! Extensão do arquivo: ${fileExtension}, nome: ${fileName}, caminho: ${filePath}, idioma: ${languageId}\n`,
        toMorseGetInput: (): string => "Por favor, insira o texto para converter",
        unknown: () => "Desconhecido",
        unknownFileStructure: () => "A estrutura do dicionário de idioma é desconhecida, adaptabilidade de comentário desativada.",
        updateAbortedBecauseFileClosedSyncCancelled: () => "Atualização abortada porque o arquivo está fechado e não será sincronizado.",
        updateEditDateMissingBounds: () => "Não foi possível atualizar o cabeçalho: marcadores internos não encontrados.",
        updatingEditionDate: () => "Atualizando a data de edição.",
        watermarkAuthorName: () => "Nome do autor",
        watermarkChosen: (watermark: string[]) => `Marca d'água a ser exibida: ${JSON.stringify(watermark)}`,
        watermarkCopied: (name: string) => `ASCII art copiado para ${name}!`,
        watermarkCopyAscii: () => "Copiar ASCII",
        watermarkJsonFileInvalid: () => "O arquivo JSON da marca d'água está vazio ou inválido",
        watermarkName: () => "Nome da marca d'água",
        watermarkNotFound: () => "Marca d'água não encontrada",
        watermarkPersonDisplayed: (name: string) => `Marca d'água '${name}' exibida.`,
        watermarkView: () => "visualização da marca d'água",
        watermarkZoomIn: () => "Aumentar zoom",
        watermarkZoomOut: () => "Diminuir zoom"
    },
    "tr": {
        alternateFilePathUpdated: (oldFilePath: string, newFilePath: string): string => `Alternatif yol ${oldFilePath} konumundan ${newFilePath} konumuna güncellendi.`,
        alternateLogoDirectoryNotFound: (alternateRootDirectory: string, error: string = "Sağlanmadı") => `Alternatif logo kök dizini '${alternateRootDirectory}' bulunamadı, hata: '${error}'.`,
        alternateLogoDirectoryNotProvided: () => `Alternatif logo dizini belirtilmedi.`,
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]) => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}.`,
        brokenHeader: () => "Bozuk başlık tespit edildi, yeni başlık ekleniyor, lütfen öncekini kaldırın.",
        cacheAlreadyLoaded: (): string => "Önbellek zaten yüklü, depolanan örnek geri döndürülüyor.",
        chooseSingleLineCommentOption: () => "Aşağıdaki seçeneklerden tercih ettiğiniz yorum ön ekini seçin:",
        closedDocument: () => "Belge kapalı, işlemler durduruluyor.",
        convertedContentCli: (content: string): string => `Dönüştürülen içerik: ${content}`,
        convertedContentGui: (): string => "Dönüştürülen içerik: ",
        corruptedFileMetaData: () => "Gerekli dosya meta verileri doğru şekilde alınamadı, işlem durduruldu.",
        cwdDoesNotExist: (cwd: string) => `Sağlanan çalışma dizini ${cwd} mevcut değil.`,
        cwdUpdated: (oldCwd: string, newCwd: string) => `Mevcut çalışma dizini ${oldCwd}’den ${newCwd}’ye güncellendi.`,
        darlingAge: () => "Yaş",
        darlingAlias: () => "Takma ad",
        darlingCopied: (name: string) => `${name} için ASCII sanatı kopyalandı!`,
        darlingCopyAscii: () => "ASCII'yi Kopyala",
        darlingDescription: () => "Açıklama",
        darlingHeight: () => "Boy",
        darlingImage: () => "Resim",
        darlingJsonFileInvalid: () => "Karakter JSON dosyası boş veya geçersiz",
        darlingMoreInfo: () => "Daha fazla bilgi",
        darlingPersonDisplayed: (name: string) => `'${name}' karakteri görüntülendi.`,
        darlingQuote: () => "Alıntı",
        darlingType: () => "Tür",
        darlingView: () => "karakterGörünümü",
        darlingZoomIn: () => "Yakınlaştır",
        darlingZoomOut: () => "Uzaklaştır",
        documentLineScanExceeded: (maxScanLength: number) => `Dosyanın ilk ${maxScanLength} satırı tarandı, başlık bulunamadı.`,
        emptyDocument: () => "Üzerinde çalışılacak belge yok.",
        errorDuringFunctionCall: (functionName: string) => `Fonksiyon (${functionName}) çağrılırken bir hata oluştu, logları kontrol edin.`,
        extensionActivated: (moduleName: string) => `🚀 "${moduleName}" artık aktif!`,
        fileExcludedActivationDisabled: () => "Aktivasyon devre dışı, dosya hariç tutma listesinde.",
        fileLength: (filePath: string, fileLength: number): string => `Dosya: '${filePath}', boyut: ${fileLength} byte.`,
        fileLoaded: (absolutePath: string) => `Dosya ${absolutePath} yüklendi!`,
        fileLoadError: (filePath: string, error: string = "Sağlanmadı"): string => `Dosya yüklenemedi: '${filePath}'. Hata: ${error}.`,
        fileNotFound: (filePath: string): string => `Dosya bulunamadı: ${filePath}`,
        fileParseError: (filePath: string, error: string) => `Dosya içeriği (${filePath}) başarıyla yüklenemedi. Hata: ${error}.`,
        filepathPresenceCheck: (filePath: string): string => `Dosya yolu kontrol ediliyor: ${filePath}`,
        filePathProcessing: (filepath: string): string => `Dosya yolu işleniyor: '${filepath}'.`,
        filePathUpdated: (oldFilePath: string, newFilePath: string) => `Yol ${oldFilePath}’den ${newFilePath}’e güncellendi.`,
        fileRefreshed: () => "Dosya içeriği yenileniyor.",
        fileSaveFailed: () => "Dosya kaydedilemedi, lütfen tekrar deneyin.",
        fileUnloaded: (filePath: string) => `Dosya ${filePath} hafızadan boşaltıldı.`,
        foundAlternateFilePathToLoad: (alternateFilePath: string) => `Yüklenecek alternatif dosya yolu '${alternateFilePath}' olarak ayarlandı.`,
        foundAlternateLogoRootDir: (rootDir: string) => `Geçerli alternatif logo kök dizini: '${rootDir}'.`,
        foundCurrentWorkingDirectory: (cwd: string) => `Geçerli çalışma dizini '${cwd}' olarak ayarlandı.`,
        foundFilePath: (filePath: string) => `Belirtilen dosya yolu mevcut: '${filePath}'.`,
        foundFilePathToLoad: (filePath: string) => `Yüklenecek dosya yolu '${filePath}' olarak ayarlandı.`,
        foundFocusEditor: () => `Odakta bir düzenleyici var.`,
        foundLanguageComment: () => `Dil yorum dosyası mevcut.`,
        foundLogoInstance: () => `Bir logo örneği sağlandı.`,
        foundLogoRootDir: (rootDir: string) => `Geçerli logo kök dizini: '${rootDir}'.`,
        foundNewLine: (newLineType: string) => `Yeni belirlenen satır türü: '${newLineType}'.`,
        foundWorkingDirectory: () => `Belirtilen çalışma dizini mevcut.`,
        fromMorseGetInput: (): string => "Lütfen dönüştürülecek metni buradan girin",
        getHeaderDescription: () => "Lütfen bir açıklama sağlayın: ",
        getHeaderPurpose: () => "Lütfen dosyanın amacını belirtin:",
        getHeaderTags: () => "Bu dosya için etiketleri virgülle ayırarak girin:",
        headerInjectQuestion: () => "Bu belgede başlık bulunamadı. Eklemek ister misiniz?",
        headerInjectQuestionRefused: () => "Dosyaya başlık eklememeyi seçtiniz.",
        headerNotFound: () => "Bu belgede başlık bulunamadı.",
        headerOpenerAndCloserFound: () => "Başlık açılışı ve kapanışı bulundu, denetim sonrası tarih güncellemesine geçiliyor.",
        headerOpenerFound: () => "Başlık açılışı bulundu.",
        headerWriteFailed: () => "Başlık dosyaya yazılamadı, günlükleri kontrol edin.",
        headerWriteSuccess: () => "Başlık başarıyla yazıldı.",
        helloWorldGreetingsCommand: (moduleName: string) => `${moduleName}’den Merhaba Dünya!`,
        identifiedLanguage: (langName: string) => `Belirlenen dil: ${langName}.`,
        inFunction: (functionName: string, className: string = "Belirtilmedi") => `'${className}' sınıfındaki '${functionName}' fonksiyonunda`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string) => `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        inputboxError: (promptText: string, err: string) => `${promptText} için inputBox hatası: ${err}`,
        jsonContent: (jsonContentString: String) => `Yorum JSON dosyasının içeriği: ${jsonContentString}`,
        languageNotFound: (LanguageId: string, fileExtension: string) => `Bu belgenin dosya dili tanımlanamadı, languageID: ${LanguageId}, dosya uzantısı: ${fileExtension}`,
        lastModifiedLineNotFound: () => "Başlıkta güncellenecek 'Son Değişiklik' satırı yok.",
        lastModifiedUpdated: () => "'Son Değişiklik' tarihi başarıyla güncellendi.",
        logoChosen: (logo: string[]) => `Gösterilecek logo: ${JSON.stringify(logo)}`,
        logoCopied: (logoName: string) => `${logoName} için ASCII sanatı kopyalandı!`,
        logoCopyAscii: () => "ASCII'yi Kopyala",
        logoDisplayed: (name: string) => `'${name}' logosu görüntülendi.`,
        logoMessage: (logoPath: string) => `Dosya (${logoPath}) göz ardı edildi, çünkü aranan tür değil.`,
        logoName: () => "Logo adı",
        logoNoRootDir: () => "Logo toplamak için kök dizin sağlanmadı",
        logoNotFound: () => "Logo bulunamadı",
        logoRootDirUpdateError: (error: string) => `Logo dosyaları güncellenirken bir hata oluştu: ${error}`,
        logoView: () => "logoGörünümü",
        logoZoomIn: (): string => "Yakınlaştır",
        logoZoomOut: (): string => "Uzaklaştır",
        messageNotFound: (key: string) => `'${key}' mesajı bulunamadı.`,
        messageWritten: () => "Mesaj yazıldı",
        missingFileError: () => "Dil sözlüğü eksik, yorum uyumluluğu devre dışı.",
        missingLanguageComment: () => "Dil yorumu sağlanmadı, atlama yapılıyor.",
        morseConverted: (input: string, final: string) => `Dönüştürüldü: ${input} -> ${final}`,
        morseDecoded: (input: string, final: string) => `Çözüldü: ${input} -> ${final}`,
        noActiveEditor: () => "Aktif dosya yok!",
        noCommentToShow: () => "Gösterilecek yorum yok.",
        noFilesAvailableForLoading: (): string => "Yüklenecek dosya bulunmamaktadır.",
        noFocusedEditors: () => "Odaklanmış dosya yok.",
        noLogoInstanceProvided: () => "Hiçbir logo rastgeleleştirici örneği sağlanmadı.",
        noProvidedCommentOptions: () => "Sağlanmış yorum seçeneği yok.",
        notFoundFilePath: (filePath: string, error: string = "Sağlanmadı") => `Belirtilen dosya yolu mevcut değil: '${filePath}', hata: '${error}'`,
        openFileToApplyHeader: () => "Başlığı uygulamak için bir dosya açın.",
        operationCanceled: (): string => "İşlem iptal edildi",
        quickPickError: (err: string) => `quickPick hatası: ${err}`,
        quickPickNo: () => "Hayır",
        quickPickYes: () => "Evet",
        ramdomLogoGatheringLogoUndefined: () => "Logo içeriği tanımsız.",
        randomLogoGatheringFailed: (error: string) => `Rastgele logo toplama başarısız, varsayılan logo kullanılıyor, hata: "${error}"`,
        readTimeout: (timeout: number, filePath: string): string => `${filePath} için okuma süresi ${timeout}ms sonra doldu`,
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string) => `Merhaba dünya! Bu dosyanın uzantısı: ${fileExtension}, adı: ${fileName}, yolu: ${filePath}, belirlenen dil: ${languageId}\n`,
        toMorseGetInput: (): string => "Lütfen dönüştürülecek metni girin",
        unknown: () => "Bilinmeyen",
        unknownFileStructure: () => "Dil sözlüğü yapısı bilinmiyor, yorum uyumluluğu devre dışı.",
        updateAbortedBecauseFileClosedSyncCancelled: () => "Dosya kapalı olduğu için güncelleme iptal edildi ve senkronize edilmeyecek.",
        updateEditDateMissingBounds: () => "Başlık güncellenemedi: iç başlık işaretçileri bulunamadı.",
        updatingEditionDate: () => "Sürüm tarihi güncelleniyor.",
        watermarkAuthorName: () => "Yazar adı",
        watermarkChosen: (watermark: string[]) => `Gösterilecek filigran: ${JSON.stringify(watermark)}`,
        watermarkCopied: (name: string) => `${name} için ASCII sanatı kopyalandı!`,
        watermarkCopyAscii: () => "ASCII'yi Kopyala",
        watermarkJsonFileInvalid: () => "Filigran JSON dosyası boş veya geçersiz",
        watermarkName: () => "Filigran adı",
        watermarkNotFound: () => "Filigran bulunamadı",
        watermarkPersonDisplayed: (name: string) => `'${name}' filigranı görüntülendi.`,
        watermarkView: () => "filigranGörünümü",
        watermarkZoomIn: () => "Yakınlaştır",
        watermarkZoomOut: () => "Uzaklaştır"
    },
    "pl": {
        alternateFilePathUpdated: (oldFilePath: string, newFilePath: string): string => `Alternatywna ścieżka została zaktualizowana z ${oldFilePath} na ${newFilePath}.`,
        alternateLogoDirectoryNotFound: (alternateRootDirectory: string, error: string = "Nie podano") => `Alternatywny katalog główny logo '${alternateRootDirectory}' nie został znaleziony, błąd: '${error}'.`,
        alternateLogoDirectoryNotProvided: () => `Nie podano alternatywnego katalogu logo.`,
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]) => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}.`,
        brokenHeader: () => "Wykryto uszkodzony nagłówek, wstrzykiwanie nowego, usuń poprzedni.",
        cacheAlreadyLoaded: (): string => "Pamięć podręczna jest już załadowana, zwracanie zapisanej instancji.",
        chooseSingleLineCommentOption: () => "Wybierz preferowany prefiks komentarza z poniższych opcji:",
        closedDocument: () => "Dokument jest zamknięty, zatrzymywanie operacji.",
        convertedContentCli: (content: string): string => `Przekonwertowana zawartość: ${content}`,
        convertedContentGui: (): string => "Przekonwertowana zawartość: ",
        corruptedFileMetaData: () => "Wymagane metadane pliku nie zostały poprawnie zebrane, przerywanie.",
        cwdDoesNotExist: (cwd: string) => `Podany katalog roboczy ${cwd} nie istnieje.`,
        cwdUpdated: (oldCwd: string, newCwd: string) => `Bieżący katalog roboczy zaktualizowano z ${oldCwd} na ${newCwd}.`,
        darlingAge: () => "Wiek",
        darlingAlias: () => "Alias",
        darlingCopied: (name: string) => `Sztuka ASCII skopiowana dla ${name}!`,
        darlingCopyAscii: () => "Kopiuj ASCII",
        darlingDescription: () => "Opis",
        darlingHeight: () => "Wzrost",
        darlingImage: () => "Obraz",
        darlingJsonFileInvalid: () => "Plik JSON postaci jest pusty lub nieprawidłowy",
        darlingMoreInfo: () => "Więcej informacji",
        darlingPersonDisplayed: (name: string) => `Postać '${name}' została wyświetlona.`,
        darlingQuote: () => "Cytat",
        darlingType: () => "Typ",
        darlingView: () => "widokPostaci",
        darlingZoomIn: () => "Powiększ",
        darlingZoomOut: () => "Pomniejsz",
        documentLineScanExceeded: (maxScanLength: number) => `Przeskanowano pierwsze ${maxScanLength} linie pliku, ale nie znaleziono nagłówka.`,
        emptyDocument: () => "Brak zawartości dokumentu do pracy.",
        errorDuringFunctionCall: (functionName: string) => `Wystąpił błąd podczas wywołania funkcji (${functionName}), sprawdź logi.`,
        extensionActivated: (moduleName: string) => `🚀 "${moduleName}" jest teraz aktywny!`,
        fileExcludedActivationDisabled: () => "Aktywacja wyłączona, plik znajduje się na liście wykluczeń.",
        fileLength: (filePath: string, fileLength: number): string => `Plik: '${filePath}', długość: ${fileLength} bajtów.`,
        fileLoaded: (absolutePath: string) => `Plik ${absolutePath} został załadowany!`,
        fileLoadError: (filePath: string, error: string = "Niepodano"): string => `Nie udało się załadować pliku: '${filePath}'. Błąd: ${error}.`,
        fileNotFound: (filePath: string): string => `Nie znaleziono pliku: ${filePath}`,
        fileParseError: (filePath: string, error: string) => `Zawartość pliku (${filePath}) nie mogła zostać załadowana poprawnie. Błąd: ${error}.`,
        filepathPresenceCheck: (filePath: string): string => `Sprawdzanie obecności ścieżki pliku: ${filePath}`,
        filePathProcessing: (filepath: string): string => `Przetwarzanie ścieżki pliku: '${filepath}'.`,
        filePathUpdated: (oldFilePath: string, newFilePath: string) => `Ścieżka została zaktualizowana z ${oldFilePath} na ${newFilePath}.`,
        fileRefreshed: () => "Odświeżanie zawartości pliku.",
        fileSaveFailed: () => "Nie udało się zapisać pliku, spróbuj ponownie.",
        fileUnloaded: (filePath: string) => `Plik ${filePath} został usunięty z pamięci.`,
        foundAlternateFilePathToLoad: (alternateFilePath: string) => `Alternatywna ścieżka pliku do załadowania to '${alternateFilePath}'.`,
        foundAlternateLogoRootDir: (rootDir: string) => `Bieżący alternatywny katalog główny logo to: '${rootDir}'.`,
        foundCurrentWorkingDirectory: (cwd: string) => `Bieżący katalog roboczy to '${cwd}'.`,
        foundFilePath: (filePath: string) => `Podana ścieżka pliku istnieje: '${filePath}'.`,
        foundFilePathToLoad: (filePath: string) => `Ścieżka pliku do załadowania to '${filePath}'.`,
        foundFocusEditor: () => `Edytor jest aktywny.`,
        foundLanguageComment: () => `Plik komentarzy językowych jest obecny.`,
        foundLogoInstance: () => `Dostarczono instancję logo.`,
        foundLogoRootDir: (rootDir: string) => `Bieżący katalog główny logo to: '${rootDir}'.`,
        foundNewLine: (newLineType: string) => `Nowy typ linii to '${newLineType}'.`,
        foundWorkingDirectory: () => `Podany katalog roboczy istnieje.`,
        fromMorseGetInput: (): string => "Proszę wprowadzić tekst do konwersji z",
        getHeaderDescription: () => "Podaj opis: ",
        getHeaderPurpose: () => "Podaj cel pliku:",
        getHeaderTags: () => "Wprowadź tagi dla tego pliku, oddzielone przecinkami:",
        headerInjectQuestion: () => "Nie znaleziono nagłówka w tym dokumencie. Czy chcesz dodać jeden?",
        headerInjectQuestionRefused: () => "Zdecydowano nie dodawać nagłówka do pliku.",
        headerNotFound: () => "Nie znaleziono nagłówka w tym dokumencie.",
        headerOpenerAndCloserFound: () => "Znaleziono otwieracz i zamykacz nagłówka, kontynuowanie aktualizacji daty po kontroli poprawności.",
        headerOpenerFound: () => "Znaleziono otwieracz nagłówka.",
        headerWriteFailed: () => "Nie udało się zapisać nagłówka do pliku, sprawdź logi.",
        headerWriteSuccess: () => "Nagłówek zapisany pomyślnie.",
        helloWorldGreetingsCommand: (moduleName: string) => `Witaj Świecie z ${moduleName}!`,
        identifiedLanguage: (langName: string) => `Zidentyfikowany język: ${langName}.`,
        inFunction: (functionName: string, className: string = "Nie określono") => `W funkcji: '${functionName}' z klasy: '${className}'`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string) => `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        inputboxError: (promptText: string, err: string) => `Błąd w inputBox dla ${promptText}: ${err}`,
        jsonContent: (jsonContentString: String) => `Zawartość pliku JSON komentarza: ${jsonContentString}`,
        languageNotFound: (LanguageId: string, fileExtension: string) => `Nie udało się zidentyfikować języka pliku tego dokumentu, languageID: ${LanguageId}, rozszerzenie pliku: ${fileExtension}`,
        lastModifiedLineNotFound: () => "Nagłówek nie zawiera wiersza 'Ostatnia modyfikacja' do aktualizacji.",
        lastModifiedUpdated: () => "Data 'Ostatnia modyfikacja' została pomyślnie zaktualizowana.",
        logoChosen: (logo: string[]) => `Logo do wyświetlenia: ${JSON.stringify(logo)}`,
        logoCopied: (logoName: string) => `Sztuka ASCII skopiowana dla ${logoName}!`,
        logoCopyAscii: () => "Kopiuj ASCII",
        logoDisplayed: (name: string) => `Logo '${name}' zostało wyświetlone.`,
        logoMessage: (logoPath: string) => `Plik (${logoPath}) pominięty, ponieważ nie jest szukanym typem.`,
        logoName: () => "Nazwa logo",
        logoNoRootDir: () => "Nie podano katalogu głównego do zbierania logotypów",
        logoNotFound: () => "Logo nie znaleziono",
        logoRootDirUpdateError: (error: string) => `Wystąpił błąd podczas aktualizacji plików logo: ${error}`,
        logoView: () => "widokLogo",
        logoZoomIn: (): string => "Powiększ",
        logoZoomOut: (): string => "Pomniejsz",
        messageNotFound: (key: string) => `Nie znaleziono komunikatu '${key}'.`,
        messageWritten: () => "Wiadomość zapisana",
        missingFileError: () => "Słownik językowy jest brakujący, dostosowanie komentarzy jest wyłączone.",
        missingLanguageComment: () => "Komentarz języka nie został dostarczony, pomijanie przypisania.",
        morseConverted: (input: string, final: string) => `Przekonwertowano: ${input} na ${final}`,
        morseDecoded: (input: string, final: string) => `Rozkodowano: ${input} na ${final}`,
        noActiveEditor: () => "Brak aktywnego pliku!",
        noCommentToShow: () => "Brak komentarzy do wyświetlenia.",
        noFilesAvailableForLoading: (): string => "Brak plików do załadowania.",
        noFocusedEditors: () => "Brak plików w fokusie.",
        noLogoInstanceProvided: () => "Nie podano instancji losowego loga.",
        noProvidedCommentOptions: () => "Nie dostarczono żadnych opcji komentarza.",
        notFoundFilePath: (filePath: string, error: string = "Nie podano") => `Podana ścieżka pliku nie istnieje: '${filePath}', błąd: '${error}'`,
        openFileToApplyHeader: () => "Otwórz plik, aby zastosować nagłówek.",
        operationCanceled: (): string => "Operacja anulowana",
        quickPickError: (err: string) => `Błąd w quickPick: ${err}`,
        quickPickNo: () => "Nie",
        quickPickYes: () => "Tak",
        ramdomLogoGatheringLogoUndefined: () => "Zawartość loga jest niezdefiniowana.",
        randomLogoGatheringFailed: (error: string) => `Losowe zbieranie loga nie powiodło się, użycie domyślnego loga, błąd: "${error}"`,
        readTimeout: (timeout: number, filePath: string): string => `Limit czasu odczytu po ${timeout}ms dla ${filePath}`,
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string) => `Witaj świecie! Rozszerzenie tego pliku: ${fileExtension}, nazwa: ${fileName}, ścieżka: ${filePath}, określony język: ${languageId}\n`,
        toMorseGetInput: (): string => "Proszę wprowadzić tekst do konwersji",
        unknown: () => "Nieznany",
        unknownFileStructure: () => "Struktura słownika językowego jest nieznana, dostosowanie komentarzy jest wyłączone.",
        updateAbortedBecauseFileClosedSyncCancelled: () => "Aktualizacja przerwana, ponieważ plik jest zamknięty i nie zostanie zsynchronizowany.",
        updateEditDateMissingBounds: () => "Nie można zaktualizować nagłówka: nie znaleziono wewnętrznych znaczników nagłówka.",
        updatingEditionDate: () => "Aktualizacja daty edycji.",
        watermarkAuthorName: () => "Autor",
        watermarkChosen: (watermark: string[]) => `Filigran do wyświetlenia: ${JSON.stringify(watermark)}`,
        watermarkCopied: (name: string) => `Sztuka ASCII skopiowana dla ${name}!`,
        watermarkCopyAscii: () => "Kopiuj ASCII",
        watermarkJsonFileInvalid: () => "Plik JSON filigranu jest pusty lub nieprawidłowy",
        watermarkName: () => "Nazwa filigranu",
        watermarkNotFound: () => "Filigran nie został znaleziony",
        watermarkPersonDisplayed: (name: string) => `Filigran '${name}' został wyświetlony.`,
        watermarkView: () => "widokWatermark",
        watermarkZoomIn: () => "Powiększ",
        watermarkZoomOut: () => "Pomniejsz"
    },
    "cs": {
        alternateFilePathUpdated: (oldFilePath: string, newFilePath: string): string => `Alternativní cesta byla aktualizována z ${oldFilePath} na ${newFilePath}.`,
        alternateLogoDirectoryNotFound: (alternateRootDirectory: string, error: string = "Neuvedeno") => `Alternativní kořenový adresář loga '${alternateRootDirectory}' nebyl nalezen, chyba: '${error}'.`,
        alternateLogoDirectoryNotProvided: () => `Nebyl zadán alternativní adresář s logy.`,
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]) => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}.`,
        brokenHeader: () => "Byla detekována poškozená hlavička, vkládá se nová, odstraňte předchozí.",
        cacheAlreadyLoaded: (): string => "Cache je již načtena, vracím uloženou instanci.",
        chooseSingleLineCommentOption: () => "Vyberte preferovaný prefix komentáře z níže uvedených možností:",
        closedDocument: () => "Dokument je uzavřen, operace zastaveny.",
        convertedContentCli: (content: string): string => `Převedený obsah: ${content}`,
        convertedContentGui: (): string => "Převedený obsah: ",
        corruptedFileMetaData: () => "Požadovaná metadata souboru nebyla správně shromážděna, přerušení.",
        cwdDoesNotExist: (cwd: string) => `Zadaný pracovní adresář ${cwd} neexistuje.`,
        cwdUpdated: (oldCwd: string, newCwd: string) => `Aktuální pracovní adresář byl aktualizován z ${oldCwd} na ${newCwd}.`,
        darlingAge: () => "Věk",
        darlingAlias: () => "Přezdívka",
        darlingCopied: (name: string) => `ASCII umění zkopírováno pro ${name}!`,
        darlingCopyAscii: () => "Kopírovat ASCII",
        darlingDescription: () => "Popis",
        darlingHeight: () => "Výška",
        darlingImage: () => "Obrázek",
        darlingJsonFileInvalid: () => "Soubor JSON postavy je prázdný nebo neplatný",
        darlingMoreInfo: () => "Více informací",
        darlingPersonDisplayed: (name: string) => `Postava '${name}' zobrazena.`,
        darlingQuote: () => "Citát",
        darlingType: () => "Typ",
        darlingView: () => "zobrazeníPostavy",
        darlingZoomIn: () => "Přiblížit",
        darlingZoomOut: () => "Oddálit",
        documentLineScanExceeded: (maxScanLength: number) => `Prohledáno prvních ${maxScanLength} řádků souboru, ale hlavička nebyla nalezena.`,
        emptyDocument: () => "Neexistuje žádný obsah dokumentu k práci.",
        errorDuringFunctionCall: (functionName: string) => `Něco se pokazilo během volání funkce (${functionName}), zkontrolujte logy.`,
        extensionActivated: (moduleName: string) => `🚀 "${moduleName}" je nyní aktivní!`,
        fileExcludedActivationDisabled: () => "Aktivace zakázána, soubor je na seznamu vyloučení.",
        fileLength: (filePath: string, fileLength: number): string => `Soubor: '${filePath}', délka: ${fileLength} bajtů.`,
        fileLoaded: (absolutePath: string) => `Soubor ${absolutePath} byl načten!`,
        fileLoadError: (filePath: string, error: string = "Neuvedeno"): string => `Nepodařilo se načíst soubor: '${filePath}'. Chyba: ${error}.`,
        fileNotFound: (filePath: string): string => `Soubor nenalezen: ${filePath}`,
        fileParseError: (filePath: string, error: string) => `Obsah souboru (${filePath}) nelze úspěšně načíst. Chyba: ${error}.`,
        filepathPresenceCheck: (filePath: string): string => `Kontrola přítomnosti cesty k souboru: ${filePath}`,
        filePathProcessing: (filepath: string): string => `Zpracovávám cestu k souboru: '${filepath}'.`,
        filePathUpdated: (oldFilePath: string, newFilePath: string) => `Cesta byla aktualizována z ${oldFilePath} na ${newFilePath}.`,
        fileRefreshed: () => "Obnovování obsahu souboru.",
        fileSaveFailed: () => "Nepodařilo se uložit soubor, zkuste to znovu.",
        fileUnloaded: (filePath: string) => `Soubor ${filePath} byl odstraněn z paměti.`,
        foundAlternateFilePathToLoad: (alternateFilePath: string) => `Alternativní cesta k souboru k načtení je nastavena na '${alternateFilePath}'.`,
        foundAlternateLogoRootDir: (rootDir: string) => `Aktuální alternativní kořenový adresář loga je: '${rootDir}'.`,
        foundCurrentWorkingDirectory: (cwd: string) => `Aktuální pracovní adresář je nastaven na '${cwd}'.`,
        foundFilePath: (filePath: string) => `Zadaná cesta k souboru existuje: '${filePath}'.`,
        foundFilePathToLoad: (filePath: string) => `Cesta k souboru k načtení je nastavena na '${filePath}'.`,
        foundFocusEditor: () => `Editor je aktivní.`,
        foundLanguageComment: () => `Soubor s jazykovými komentáři je přítomen.`,
        foundLogoInstance: () => `Byla poskytnuta instance loga.`,
        foundLogoRootDir: (rootDir: string) => `Aktuální kořenový adresář loga je: '${rootDir}'.`,
        foundNewLine: (newLineType: string) => `Nový určený typ řádku je '${newLineType}'.`,
        foundWorkingDirectory: () => `Zadaný pracovní adresář existuje.`,
        fromMorseGetInput: (): string => "Zadejte prosím text k převodu z",
        getHeaderDescription: () => "Zadejte popis: ",
        getHeaderPurpose: () => "Zadejte účel souboru:",
        getHeaderTags: () => "Zadejte tagy pro tento soubor, oddělené čárkou:",
        headerInjectQuestion: () => "V tomto dokumentu nebyla nalezena žádná hlavička. Chcete ji přidat?",
        headerInjectQuestionRefused: () => "Rozhodli jste se nepřidávat hlavičku do souboru.",
        headerNotFound: () => "V tomto dokumentu nebyla nalezena žádná hlavička.",
        headerOpenerAndCloserFound: () => "Otevírač a zavírač hlavičky nalezeny, pokračuje aktualizace data po kontrole správnosti.",
        headerOpenerFound: () => "Otevírač hlavičky nalezen.",
        headerWriteFailed: () => "Nepodařilo se zapsat hlavičku do souboru, zkontrolujte protokoly.",
        headerWriteSuccess: () => "Hlavička úspěšně zapsána.",
        helloWorldGreetingsCommand: (moduleName: string) => `Hello World z ${moduleName}!`,
        identifiedLanguage: (langName: string) => `Identifikovaný jazyk: ${langName}.`,
        inFunction: (functionName: string, className: string = "Nespecifikováno") => `Ve funkci: '${functionName}' ze třídy: '${className}'`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string) => `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        inputboxError: (promptText: string, err: string) => `Chyba v inputBox pro ${promptText}: ${err}`,
        jsonContent: (jsonContentString: String) => `Obsah JSON souboru komentářů: ${jsonContentString}`,
        languageNotFound: (LanguageId: string, fileExtension: string) => `Jazyk souboru tohoto dokumentu nelze identifikovat, languageID: ${LanguageId}, přípona souboru: ${fileExtension}`,
        lastModifiedLineNotFound: () => "Hlavička neobsahuje řádek 'Poslední úprava' k aktualizaci.",
        lastModifiedUpdated: () => "Datum 'Poslední úprava' bylo úspěšně aktualizováno.",
        logoChosen: (logo: string[]) => `Logo k zobrazení: ${JSON.stringify(logo)}`,
        logoCopied: (logoName: string) => `ASCII umění zkopírováno pro ${logoName}!`,
        logoCopyAscii: () => "Kopírovat ASCII",
        logoDisplayed: (name: string) => `Logo '${name}' zobrazeno.`,
        logoMessage: (logoPath: string) => `Soubor (${logoPath}) byl ignorován, protože není požadovaného typu.`,
        logoName: () => "Název loga",
        logoNoRootDir: () => "Nebyl poskytnut žádný kořenový adresář pro sběr log",
        logoNotFound: () => "Logo nenalezeno",
        logoRootDirUpdateError: (error: string) => `Došlo k chybě při aktualizaci souborů loga, chyba: ${error}`,
        logoView: () => "zobrazeníLoga",
        logoZoomIn: (): string => "Přiblížit",
        logoZoomOut: (): string => "Oddálit",
        messageNotFound: (key: string) => `Zpráva '${key}' nenalezena.`,
        messageWritten: () => "Zpráva zapsána",
        missingFileError: () => "Slovník jazyků chybí, přizpůsobení komentářů je deaktivováno.",
        missingLanguageComment: () => "Komentář jazyka nebyl poskytnut, přiřazení přeskočeno.",
        morseConverted: (input: string, final: string) => `Převedeno: ${input} na ${final}`,
        morseDecoded: (input: string, final: string) => `Dekódováno: ${input} na ${final}`,
        noActiveEditor: () => "Žádný aktivní soubor!",
        noCommentToShow: () => "Žádný komentář k zobrazení.",
        noFilesAvailableForLoading: (): string => "Nejsou k dispozici žádné soubory k načtení.",
        noFocusedEditors: () => "Žádné soubory nejsou ve fokus.",
        noLogoInstanceProvided: () => "Nebyla poskytnuta instance náhodného loga.",
        noProvidedCommentOptions: () => "Nebyly poskytnuty žádné možnosti komentáře.",
        notFoundFilePath: (filePath: string, error: string = "Neuvedeno") => `Zadaná cesta k souboru neexistuje: '${filePath}', chyba: '${error}'`,
        openFileToApplyHeader: () => "Otevřete soubor, na který chcete aplikovat hlavičku.",
        operationCanceled: (): string => "Operace byla zrušena",
        quickPickError: (err: string) => `Chyba v quickPick: ${err}`,
        quickPickNo: () => "Ne",
        quickPickYes: () => "Ano",
        ramdomLogoGatheringLogoUndefined: () => "Obsah loga není definován.",
        randomLogoGatheringFailed: (error: string) => `Shromažďování náhodného loga selhalo, použití výchozího loga, chyba: "${error}"`,
        readTimeout: (timeout: number, filePath: string): string => `Čas pro čtení vypršel po ${timeout}ms pro ${filePath}`,
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string) => `Hello world! Přípona tohoto souboru: ${fileExtension}, název: ${fileName}, cesta: ${filePath}, určený jazyk: ${languageId}\n`,
        toMorseGetInput: (): string => "Zadejte prosím text k převodu",
        unknown: () => "Neznámý",
        unknownFileStructure: () => "Struktura slovníku jazyků je neznámá, přizpůsobení komentářů je deaktivováno.",
        updateAbortedBecauseFileClosedSyncCancelled: () => "Aktualizace přerušena, protože soubor je uzavřen a nebude synchronizován.",
        updateEditDateMissingBounds: () => "Nelze aktualizovat hlavičku: interní markery hlavičky nebyly nalezeny.",
        updatingEditionDate: () => "Aktualizace data edice.",
        watermarkAuthorName: () => "Jméno autora",
        watermarkChosen: (watermark: string[]) => `Vodoznak k zobrazení: ${JSON.stringify(watermark)}`,
        watermarkCopied: (name: string) => `ASCII umění zkopírováno pro ${name}!`,
        watermarkCopyAscii: () => "Kopírovat ASCII",
        watermarkJsonFileInvalid: () => "Soubor JSON vodoznaku je prázdný nebo neplatný",
        watermarkName: () => "Název vodoznaku",
        watermarkNotFound: () => "Vodoznak nenalezen",
        watermarkPersonDisplayed: (name: string) => `Vodoznak '${name}' zobrazen.`,
        watermarkView: () => "zobrazeníWatermark",
        watermarkZoomIn: () => "Přiblížit",
        watermarkZoomOut: () => "Oddálit"
    },
    "hu": {
        alternateFilePathUpdated: (oldFilePath: string, newFilePath: string): string => `Az alternatív elérési út frissítve lett: ${oldFilePath} → ${newFilePath}.`,
        alternateLogoDirectoryNotFound: (alternateRootDirectory: string, error: string = "Nincs megadva") => `Az alternatív logó gyökérkönyvtár '${alternateRootDirectory}' nem található, hiba: '${error}'.`,
        alternateLogoDirectoryNotProvided: () => `Nem lett megadva alternatív logókönyvtár.`,
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]) => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}.`,
        brokenHeader: () => "Sérült fejléc észlelve, új beszúrása folyamatban, kérjük távolítsa el az előzőt.",
        cacheAlreadyLoaded: (): string => "A gyorsítótár már betöltve van, a tárolt példány visszaadva.",
        chooseSingleLineCommentOption: () => "Kérjük, válassza ki a kívánt komment prefixet az alábbi lehetőségek közül:",
        closedDocument: () => "A dokumentum zárva, a műveletek leállítva.",
        convertedContentCli: (content: string): string => `Átalakított tartalom: ${content}`,
        convertedContentGui: (): string => "Átalakított tartalom: ",
        corruptedFileMetaData: () => "A szükséges fájl metaadatok nem lettek megfelelően összegyűjtve, megszakítás.",
        cwdDoesNotExist: (cwd: string) => `A megadott munkakönyvtár ${cwd} nem létezik.`,
        cwdUpdated: (oldCwd: string, newCwd: string) => `A munkakönyvtár frissítve lett: ${oldCwd} -> ${newCwd}.`,
        darlingAge: () => "Kor",
        darlingAlias: () => "Becenév",
        darlingCopied: (name: string) => `ASCII művészet másolva ${name} számára!`,
        darlingCopyAscii: () => "Másolás ASCII",
        darlingDescription: () => "Leírás",
        darlingHeight: () => "Magasság",
        darlingImage: () => "Kép",
        darlingJsonFileInvalid: () => "A karakter JSON fájl üres vagy érvénytelen",
        darlingMoreInfo: () => "További info",
        darlingPersonDisplayed: (name: string) => `Karakter '${name}' megjelenítve.`,
        darlingQuote: () => "Idézet",
        darlingType: () => "Típus",
        darlingView: () => "karakterNézet",
        darlingZoomIn: () => "Nagyítás",
        darlingZoomOut: () => "Kicsinyítés",
        documentLineScanExceeded: (maxScanLength: number) => `Az első ${maxScanLength} sor beolvasva, de nem található fejléc.`,
        emptyDocument: () => "Nincs dokumentumtartalom, amin dolgozni lehetne.",
        errorDuringFunctionCall: (functionName: string) => `Hiba történt a ${functionName} függvény hívásakor, ellenőrizze a naplókat.`,
        extensionActivated: (moduleName: string) => `🚀 A(z) "${moduleName}" modul most aktív!`,
        fileExcludedActivationDisabled: () => "Az aktiválás letiltva, a fájl a kizárási listán van.",
        fileLength: (filePath: string, fileLength: number): string => `Fájl: '${filePath}', méret: ${fileLength} bájt.`,
        fileLoaded: (absolutePath: string) => `A fájl ${absolutePath} betöltve!`,
        fileLoadError: (filePath: string, error: string = "Nem megadott"): string => `A fájl betöltése sikertelen: '${filePath}'. Hiba: ${error}.`,
        fileNotFound: (filePath: string): string => `Fájl nem található: ${filePath}`,
        fileParseError: (filePath: string, error: string) => `A fájl tartalma (${filePath}) nem tölthető be sikeresen. Hiba: ${error}.`,
        filepathPresenceCheck: (filePath: string): string => `Fájl elérhetőségének ellenőrzése: ${filePath}`,
        filePathProcessing: (filepath: string): string => `Fájl útvonal feldolgozása: '${filepath}'.`,
        filePathUpdated: (oldFilePath: string, newFilePath: string) => `Az útvonal frissítve lett: ${oldFilePath} -> ${newFilePath}.`,
        fileRefreshed: () => "Fájl tartalmának frissítése.",
        fileSaveFailed: () => "A fájl mentése sikertelen, próbálja újra.",
        fileUnloaded: (filePath: string) => `A fájl ${filePath} eltávolítva a memóriából.`,
        foundAlternateFilePathToLoad: (alternateFilePath: string) => `Az alternatív betöltendő fájlútvonal '${alternateFilePath}'.`,
        foundAlternateLogoRootDir: (rootDir: string) => `A jelenlegi alternatív logó gyökérkönyvtár: '${rootDir}'.`,
        foundCurrentWorkingDirectory: (cwd: string) => `A jelenlegi munkakönyvtár: '${cwd}'.`,
        foundFilePath: (filePath: string) => `A megadott fájlútvonal létezik: '${filePath}'.`,
        foundFilePathToLoad: (filePath: string) => `A betöltendő fájlútvonal '${filePath}'.`,
        foundFocusEditor: () => `Egy szerkesztő van fókuszban.`,
        foundLanguageComment: () => `A nyelvi megjegyzésfájl megtalálható.`,
        foundLogoInstance: () => `Egy logó példány meg lett adva.`,
        foundLogoRootDir: (rootDir: string) => `A jelenlegi logó gyökérkönyvtár: '${rootDir}'.`,
        foundNewLine: (newLineType: string) => `Az új sor típusa: '${newLineType}'.`,
        foundWorkingDirectory: () => `A megadott munkakönyvtár létezik.`,
        fromMorseGetInput: (): string => "Kérjük, adja meg a konvertálandó szöveget innen",
        getHeaderDescription: () => "Adjon meg egy leírást: ",
        getHeaderPurpose: () => "Adja meg a fájl célját:",
        getHeaderTags: () => "Adja meg a fájl címkéit, vesszővel elválasztva:",
        headerInjectQuestion: () => "Nem található fejléc ebben a dokumentumban. Szeretne hozzáadni egyet?",
        headerInjectQuestionRefused: () => "Úgy döntött, hogy nem ad hozzá fejlécet a fájlhoz.",
        headerNotFound: () => "Nem található fejléc ebben a dokumentumban.",
        headerOpenerAndCloserFound: () => "Fejléc nyitó és záró megtalálva, a dátum frissítése következik ellenőrzés után.",
        headerOpenerFound: () => "Fejléc nyitó megtalálva.",
        headerWriteFailed: () => "Nem sikerült írni a fejlécet a fájlba, ellenőrizze a naplókat.",
        headerWriteSuccess: () => "Fejléc sikeresen írva.",
        helloWorldGreetingsCommand: (moduleName: string) => `Hello World a ${moduleName}-ból!`,
        identifiedLanguage: (langName: string) => `Azonosított nyelv: ${langName}.`,
        inFunction: (functionName: string, className: string = "Nincs megadva") => `A(z) '${className}' osztály '${functionName}' függvényében`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string) => `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        inputboxError: (promptText: string, err: string) => `Hiba az inputBox-nál a(z) ${promptText} esetén: ${err}`,
        jsonContent: (jsonContentString: String) => `A komment JSON fájl tartalma: ${jsonContentString}`,
        languageNotFound: (LanguageId: string, fileExtension: string) => `A dokumentum nyelve nem azonosítható, languageID: ${LanguageId}, fájlkiterjesztés: ${fileExtension}`,
        lastModifiedLineNotFound: () => "A fejléc nem tartalmaz 'Utolsó módosítás' sort a frissítéshez.",
        lastModifiedUpdated: () => "Az 'Utolsó módosítás' dátum sikeresen frissítve.",
        logoChosen: (logo: string[]) => `Megjelenítendő logó: ${JSON.stringify(logo)}`,
        logoCopied: (logoName: string) => `ASCII művészet másolva ${logoName} számára!`,
        logoCopyAscii: () => "Másolás ASCII",
        logoDisplayed: (name: string) => `Logó '${name}' megjelenítve.`,
        logoMessage: (logoPath: string) => `Fájl (${logoPath}) figyelmen kívül hagyva, mert nem a keresett típus.`,
        logoName: () => "Logó neve",
        logoNoRootDir: () => "Nincs megadva gyökérkönyvtár a logók gyűjtéséhez",
        logoNotFound: () => "Logó nem található",
        logoRootDirUpdateError: (error: string) => `Hiba történt a logófájlok frissítése közben, hiba: ${error}`,
        logoView: () => "logoNézet",
        logoZoomIn: (): string => "Nagyítás",
        logoZoomOut: (): string => "Kicsinyítés",
        messageNotFound: (key: string) => `'${key}' üzenet nem található.`,
        messageWritten: () => "Üzenet írva",
        missingFileError: () => "A nyelvi szótár hiányzik, a komment alkalmazkodás le van tiltva.",
        missingLanguageComment: () => "A nyelvi komment nem lett megadva, a hozzárendelés kihagyva.",
        morseConverted: (input: string, final: string) => `Átalakítva: ${input} -> ${final}`,
        morseDecoded: (input: string, final: string) => `Dekódolva: ${input} -> ${final}`,
        noActiveEditor: () => "Nincs aktív fájl!",
        noCommentToShow: () => "Nincs megjeleníthető komment.",
        noFilesAvailableForLoading: (): string => "Nincs betölthető fájl.",
        noFocusedEditors: () => "Nincsenek fókuszban lévő fájlok.",
        noLogoInstanceProvided: () => "Nem lett logó randomizáló példány megadva.",
        noProvidedCommentOptions: () => "Nincsenek megadott komment opciók.",
        notFoundFilePath: (filePath: string, error: string = "Nincs megadva") => `A megadott fájlútvonal nem létezik: '${filePath}', hiba: '${error}'`,
        openFileToApplyHeader: () => "Nyisson meg egy fájlt a fejléc alkalmazásához.",
        operationCanceled: (): string => "Művelet megszakítva",
        quickPickError: (err: string) => `Hiba a quickPick-nál: ${err}`,
        quickPickNo: () => "Nem",
        quickPickYes: () => "Igen",
        ramdomLogoGatheringLogoUndefined: () => "A logó tartalma nem definiált.",
        randomLogoGatheringFailed: (error: string) => `A véletlenszerű logógyűjtés sikertelen, alapértelmezett logó használata, hiba: "${error}"`,
        readTimeout: (timeout: number, filePath: string): string => `Olvasási időkorlát lejárt ${timeout}ms után a(z) ${filePath} fájlhoz`,
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string) => `Hello world! A fájl kiterjesztése: ${fileExtension}, neve: ${fileName}, útvonala: ${filePath}, nyelv: ${languageId}\n`,
        toMorseGetInput: (): string => "Kérjük, adja meg az átalakítandó szöveget",
        unknown: () => "Ismeretlen",
        unknownFileStructure: () => "A nyelvi szótár szerkezete ismeretlen, a komment alkalmazkodás le van tiltva.",
        updateAbortedBecauseFileClosedSyncCancelled: () => "A frissítés megszakítva, mert a fájl zárva van és nem lesz szinkronizálva.",
        updateEditDateMissingBounds: () => "Nem sikerült frissíteni a fejlécet: a belső jelölők nem találhatók.",
        updatingEditionDate: () => "Kiadás dátumának frissítése.",
        watermarkAuthorName: () => "Szerző neve",
        watermarkChosen: (watermark: string[]) => `Megjelenítendő vízjel: ${JSON.stringify(watermark)}`,
        watermarkCopied: (name: string) => `ASCII művészet másolva ${name} számára!`,
        watermarkCopyAscii: () => "Másolás ASCII",
        watermarkJsonFileInvalid: () => "A vízjel JSON fájl üres vagy érvénytelen",
        watermarkName: () => "Vízjel neve",
        watermarkNotFound: () => "Vízjel nem található",
        watermarkPersonDisplayed: (name: string) => `Vízjel '${name}' megjelenítve.`,
        watermarkView: () => "vízjelNézet",
        watermarkZoomIn: () => "Nagyítás",
        watermarkZoomOut: () => "Kicsinyítés"
    },
    "zh-cn": {
        alternateFilePathUpdated: (oldFilePath: string, newFilePath: string): string => `备用路径已从 ${oldFilePath} 更新为 ${newFilePath}。`,
        alternateLogoDirectoryNotFound: (alternateRootDirectory: string, error: string = "未提供") => `未找到备用徽标根目录 '${alternateRootDirectory}'，错误: '${error}'。`,
        alternateLogoDirectoryNotProvided: () => `未提供备用徽标目录。`,
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]) => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}。`,
        brokenHeader: () => "检测到破损的头部，正在注入新的，请删除旧的。",
        cacheAlreadyLoaded: (): string => "缓存已加载，返回存储的实例。",
        chooseSingleLineCommentOption: () => "请选择以下选项中的首选注释前缀：",
        closedDocument: () => "文档已关闭，停止操作。",
        convertedContentCli: (content: string): string => `转换后的内容: ${content}`,
        convertedContentGui: (): string => "转换后的内容: ",
        corruptedFileMetaData: () => "文件元数据未正确收集，中止操作。",
        cwdDoesNotExist: (cwd: string) => `提供的工作目录 ${cwd} 不存在。`,
        cwdUpdated: (oldCwd: string, newCwd: string) => `当前工作目录已从 ${oldCwd} 更新为 ${newCwd}。`,
        darlingAge: () => "年龄",
        darlingAlias: () => "别名",
        darlingCopied: (name: string) => `${name} 的 ASCII 艺术已复制！`,
        darlingCopyAscii: () => "复制 ASCII",
        darlingDescription: () => "描述",
        darlingHeight: () => "身高",
        darlingImage: () => "图像",
        darlingJsonFileInvalid: () => "Darling JSON 文件为空或无效",
        darlingMoreInfo: () => "更多信息",
        darlingPersonDisplayed: (name: string) => `角色 '${name}' 已显示。`,
        darlingQuote: () => "引用",
        darlingType: () => "类型",
        darlingView: () => "角色视图",
        darlingZoomIn: () => "放大",
        darlingZoomOut: () => "缩小",
        documentLineScanExceeded: (maxScanLength: number) => `扫描文件前 ${maxScanLength} 行，但未找到头部。`,
        emptyDocument: () => "文档为空，无法操作。",
        errorDuringFunctionCall: (functionName: string) => `调用函数 (${functionName}) 时出错，请查看日志。`,
        extensionActivated: (moduleName: string) => `🚀 扩展 "${moduleName}" 已激活！`,
        fileExcludedActivationDisabled: () => "激活已禁用，文件在排除列表中。",
        fileLength: (filePath: string, fileLength: number): string => `文件: '${filePath}'，大小: ${fileLength} 字节。`,
        fileLoaded: (absolutePath: string) => `文件 ${absolutePath} 已加载！`,
        fileLoadError: (filePath: string, error: string = "未提供"): string => `无法加载文件: '${filePath}'。错误: ${error}。`,
        fileNotFound: (filePath: string): string => `未找到文件: ${filePath}`,
        fileParseError: (filePath: string, error: string) => `文件内容 (${filePath}) 加载失败。错误：${error}。`,
        filepathPresenceCheck: (filePath: string): string => `检查文件路径存在性: ${filePath}`,
        filePathProcessing: (filepath: string): string => `正在处理文件路径: '${filepath}'。`,
        filePathUpdated: (oldFilePath: string, newFilePath: string) => `路径已从 ${oldFilePath} 更新为 ${newFilePath}。`,
        fileRefreshed: () => "刷新文件内容。",
        fileSaveFailed: () => "保存文件失败，请重试。",
        fileUnloaded: (filePath: string) => `文件 ${filePath} 已从内存卸载。`,
        foundAlternateFilePathToLoad: (alternateFilePath: string) => `要加载的备用文件路径设置为 '${alternateFilePath}'。`,
        foundAlternateLogoRootDir: (rootDir: string) => `当前备用徽标根目录为: '${rootDir}'。`,
        foundCurrentWorkingDirectory: (cwd: string) => `当前工作目录设置为 '${cwd}'。`,
        foundFilePath: (filePath: string) => `提供的文件路径存在: '${filePath}'。`,
        foundFilePathToLoad: (filePath: string) => `要加载的文件路径设置为 '${filePath}'。`,
        foundFocusEditor: () => `有一个处于焦点的编辑器。`,
        foundLanguageComment: () => `语言注释文件存在。`,
        foundLogoInstance: () => `已提供徽标实例。`,
        foundLogoRootDir: (rootDir: string) => `当前徽标根目录为: '${rootDir}'。`,
        foundNewLine: (newLineType: string) => `新检测到的换行符类型为 '${newLineType}'。`,
        foundWorkingDirectory: () => `提供的工作目录存在。`,
        fromMorseGetInput: (): string => "请输入要从中转换的文本",
        getHeaderDescription: () => "请输入描述：",
        getHeaderPurpose: () => "请输入文件用途：",
        getHeaderTags: () => "请输入文件标签，用逗号分隔：",
        headerInjectQuestion: () => "未找到头部。是否添加一个？",
        headerInjectQuestionRefused: () => "您选择不向文件添加头部。",
        headerNotFound: () => "未找到头部。",
        headerOpenerAndCloserFound: () => "找到头部开始和结束标记，进行日期更新前的检查。",
        headerOpenerFound: () => "找到头部开始标记。",
        headerWriteFailed: () => "写入头部失败，请检查日志。",
        headerWriteSuccess: () => "头部写入成功。",
        helloWorldGreetingsCommand: (moduleName: string) => `来自 ${moduleName} 的 Hello World！`,
        identifiedLanguage: (langName: string) => `识别的语言：${langName}。`,
        inFunction: (functionName: string, className: string = "未指定") => `在函数 '${functionName}' 中（类: '${className}'）`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string) => `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        inputboxError: (promptText: string, err: string) => `输入框错误：${promptText}，错误：${err}`,
        jsonContent: (jsonContentString: String) => `评论 JSON 文件内容：${jsonContentString}`,
        languageNotFound: (LanguageId: string, fileExtension: string) => `无法识别文件语言，languageID: ${LanguageId}，扩展名：${fileExtension}`,
        lastModifiedLineNotFound: () => "头部中未找到“最后修改”行以更新。",
        lastModifiedUpdated: () => "“最后修改”日期已成功更新。",
        logoChosen: (logo: string[]) => `要显示的徽标：${JSON.stringify(logo)}`,
        logoCopied: (logoName: string) => `${logoName} 的 ASCII 艺术已复制！`,
        logoCopyAscii: () => "复制 ASCII",
        logoDisplayed: (name: string) => `徽标 '${name}' 已显示。`,
        logoMessage: (logoPath: string) => `文件 (${logoPath}) 被忽略，因为它不是我们需要的类型。`,
        logoName: () => "徽标名称",
        logoNoRootDir: () => "未提供用于收集徽标的根目录",
        logoNotFound: () => "未找到徽标",
        logoRootDirUpdateError: (error: string) => `更新徽标文件时出错，错误：${error}`,
        logoView: () => "徽标视图",
        logoZoomIn: () => "放大",
        logoZoomOut: () => "缩小",
        messageNotFound: (key: string) => `未找到消息 '${key}'。`,
        messageWritten: () => "消息已写入",
        missingFileError: () => "缺少语言字典，因此评论适配被禁用。",
        missingLanguageComment: () => "未提供语言注释，跳过分配。",
        morseConverted: (input: string, final: string) => `已转换：${input} -> ${final}`,
        morseDecoded: (input: string, final: string) => `已解码：${input} -> ${final}`,
        noActiveEditor: () => "没有活动文件！",
        noCommentToShow: () => "没有可显示的评论。",
        noFilesAvailableForLoading: (): string => "没有可加载的文件。",
        noFocusedEditors: () => "没有焦点文件。",
        noLogoInstanceProvided: () => "未提供徽标随机实例。",
        noProvidedCommentOptions: () => "未提供注释选项。",
        notFoundFilePath: (filePath: string, error: string = "未提供") => `提供的文件路径不存在: '${filePath}'，错误: '${error}'`,
        openFileToApplyHeader: () => "请打开一个文件以应用头部。",
        operationCanceled: (): string => "操作已取消",
        quickPickError: (err: string) => `快速选择错误：${err}`,
        quickPickNo: () => "否",
        quickPickYes: () => "是",
        ramdomLogoGatheringLogoUndefined: () => "徽标内容未定义。",
        randomLogoGatheringFailed: (error: string) => `随机徽标收集失败，使用默认徽标，错误：${error}`,
        readTimeout: (timeout: number, filePath: string): string => `读取超时: ${timeout} 毫秒，文件: ${filePath}`,
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string) => `Hello world！扩展名：${fileExtension}，文件名：${fileName}，路径：${filePath}，语言：${languageId}\n`,
        toMorseGetInput: (): string => "请输入要转换的文本",
        unknown: () => "未知",
        unknownFileStructure: () => "语言字典结构未知，因此评论适配被禁用。",
        updateAbortedBecauseFileClosedSyncCancelled: () => "更新中止，因为文件已关闭且不会同步。",
        updateEditDateMissingBounds: () => "无法更新头部：未找到内部标记。",
        updatingEditionDate: () => "更新版本日期。",
        watermarkAuthorName: () => "作者名称",
        watermarkChosen: (watermark: string[]) => `要显示的水印：${JSON.stringify(watermark)}`,
        watermarkCopied: (name: string) => `${name} 的 ASCII 艺术已复制！`,
        watermarkCopyAscii: () => "复制 ASCII",
        watermarkJsonFileInvalid: () => "水印 JSON 文件为空或无效",
        watermarkName: () => "水印名称",
        watermarkNotFound: () => "未找到水印",
        watermarkPersonDisplayed: (name: string) => `水印 '${name}' 已显示。`,
        watermarkView: () => "水印视图",
        watermarkZoomIn: () => "放大",
        watermarkZoomOut: () => "缩小"
    },
    "zh-tw": {
        alternateFilePathUpdated: (oldFilePath: string, newFilePath: string): string => `替代路徑已從 ${oldFilePath} 更新為 ${newFilePath}。`,
        alternateLogoDirectoryNotFound: (alternateRootDirectory: string, error: string = "未提供") => `找不到替代的標誌根目錄 '${alternateRootDirectory}'，錯誤: '${error}'。`,
        alternateLogoDirectoryNotProvided: () => `未提供替代的標誌目錄。`,
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]) => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}。`,
        brokenHeader: () => "檢測到破損的頭部，正在注入新的，請刪除舊的。",
        cacheAlreadyLoaded: (): string => "快取已載入，返回儲存的實例。",
        chooseSingleLineCommentOption: () => "請從下列選項中選擇首選註解前綴：",
        closedDocument: () => "文件已關閉，停止操作。",
        convertedContentCli: (content: string): string => `轉換後的內容: ${content}`,
        convertedContentGui: (): string => "轉換後的內容: ",
        corruptedFileMetaData: () => "檔案元資料未正確收集，中止操作。",
        cwdDoesNotExist: (cwd: string) => `提供的工作目錄 ${cwd} 不存在。`,
        cwdUpdated: (oldCwd: string, newCwd: string) => `當前工作目錄已從 ${oldCwd} 更新為 ${newCwd}。`,
        darlingAge: () => "年齡",
        darlingAlias: () => "別名",
        darlingCopied: (name: string) => `${name} 的 ASCII 藝術已複製！`,
        darlingCopyAscii: () => "複製 ASCII",
        darlingDescription: () => "描述",
        darlingHeight: () => "身高",
        darlingImage: () => "圖片",
        darlingJsonFileInvalid: () => "Darling JSON 檔案為空或無效",
        darlingMoreInfo: () => "更多資訊",
        darlingPersonDisplayed: (name: string) => `角色 '${name}' 已顯示。`,
        darlingQuote: () => "引用",
        darlingType: () => "類型",
        darlingView: () => "角色檢視",
        darlingZoomIn: () => "放大",
        darlingZoomOut: () => "縮小",
        documentLineScanExceeded: (maxScanLength: number) => `掃描檔案前 ${maxScanLength} 行，但未找到頭部。`,
        emptyDocument: () => "文件為空，無法操作。",
        errorDuringFunctionCall: (functionName: string) => `呼叫函數 (${functionName}) 時發生錯誤，請查看日誌。`,
        extensionActivated: (moduleName: string) => `🚀 擴展 "${moduleName}" 已啟動！`,
        fileExcludedActivationDisabled: () => "啟用已禁用，檔案在排除清單中。",
        fileLength: (filePath: string, fileLength: number): string => `檔案: '${filePath}'，大小: ${fileLength} 位元組。`,
        fileLoaded: (absolutePath: string) => `檔案 ${absolutePath} 已加載！`,
        fileLoadError: (filePath: string, error: string = "未提供"): string => `無法載入檔案: '${filePath}'。錯誤: ${error}。`,
        fileNotFound: (filePath: string): string => `找不到檔案: ${filePath}`,
        fileParseError: (filePath: string, error: string) => `檔案內容 (${filePath}) 加載失敗。錯誤：${error}。`,
        filepathPresenceCheck: (filePath: string): string => `檢查檔案路徑存在性: ${filePath}`,
        filePathProcessing: (filepath: string): string => `處理檔案路徑: '${filepath}'。`,
        filePathUpdated: (oldFilePath: string, newFilePath: string) => `路徑已從 ${oldFilePath} 更新為 ${newFilePath}。`,
        fileRefreshed: () => "刷新檔案內容。",
        fileSaveFailed: () => "保存檔案失敗，請重試。",
        fileUnloaded: (filePath: string) => `檔案 ${filePath} 已從記憶體卸載。`,
        foundAlternateFilePathToLoad: (alternateFilePath: string) => `要載入的替代檔案路徑設為 '${alternateFilePath}'。`,
        foundAlternateLogoRootDir: (rootDir: string) => `目前的替代標誌根目錄為: '${rootDir}'。`,
        foundCurrentWorkingDirectory: (cwd: string) => `目前的工作目錄設為 '${cwd}'。`,
        foundFilePath: (filePath: string) => `提供的檔案路徑存在: '${filePath}'。`,
        foundFilePathToLoad: (filePath: string) => `要載入的檔案路徑設為 '${filePath}'。`,
        foundFocusEditor: () => `有一個編輯器目前在焦點中。`,
        foundLanguageComment: () => `語言註解檔案存在。`,
        foundLogoInstance: () => `已提供標誌實例。`,
        foundLogoRootDir: (rootDir: string) => `目前的標誌根目錄為: '${rootDir}'。`,
        foundNewLine: (newLineType: string) => `新檢測到的換行符類型為 '${newLineType}'。`,
        foundWorkingDirectory: () => `提供的工作目錄存在。`,
        fromMorseGetInput: (): string => "請輸入要從中轉換的文字",
        getHeaderDescription: () => "請提供描述：",
        getHeaderPurpose: () => "請提供檔案用途：",
        getHeaderTags: () => "請輸入檔案標籤，用逗號分隔：",
        headerInjectQuestion: () => "未找到頭部。是否添加一個？",
        headerInjectQuestionRefused: () => "您選擇不向檔案添加頭部。",
        headerNotFound: () => "未找到頭部。",
        headerOpenerAndCloserFound: () => "找到頭部開始和結束標記，進行日期更新前的檢查。",
        headerOpenerFound: () => "找到頭部開始標記。",
        headerWriteFailed: () => "寫入頭部失敗，請檢查日誌。",
        headerWriteSuccess: () => "頭部寫入成功。",
        helloWorldGreetingsCommand: (moduleName: string) => `來自 ${moduleName} 的 Hello World！`,
        identifiedLanguage: (langName: string) => `識別的語言：${langName}。`,
        inFunction: (functionName: string, className: string = "未指定") => `在函式 '${functionName}' 中（類別: '${className}'）`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string) => `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        inputboxError: (promptText: string, err: string) => `輸入框錯誤：${promptText}，錯誤：${err}`,
        jsonContent: (jsonContentString: String) => `註解 JSON 檔案內容：${jsonContentString}`,
        languageNotFound: (LanguageId: string, fileExtension: string) => `無法識別檔案語言，languageID: ${LanguageId}，副檔名：${fileExtension}`,
        lastModifiedLineNotFound: () => "頭部中未找到“最後修改”行以更新。",
        lastModifiedUpdated: () => "“最後修改”日期已成功更新。",
        logoChosen: (logo: string[]) => `要顯示的徽標：${JSON.stringify(logo)}`,
        logoCopied: (logoName: string) => `${logoName} 的 ASCII 藝術已複製！`,
        logoCopyAscii: () => "複製 ASCII",
        logoDisplayed: (name: string) => `徽標 '${name}' 已顯示。`,
        logoMessage: (logoPath: string) => `檔案 (${logoPath}) 被忽略，因為它不是所需類型。`,
        logoName: () => "徽標名稱",
        logoNoRootDir: () => "未提供用於收集徽標的根目錄",
        logoNotFound: () => "未找到徽標",
        logoRootDirUpdateError: (error: string) => `更新徽標檔案時出錯，錯誤：${error}`,
        logoView: () => "徽標檢視",
        logoZoomIn: () => "放大",
        logoZoomOut: () => "縮小",
        messageNotFound: (key: string) => `未找到消息 '${key}'。`,
        messageWritten: () => "消息已寫入",
        missingFileError: () => "缺少語言字典，因此評論適配被禁用。",
        missingLanguageComment: () => "未提供語言註解，跳過分配。",
        morseConverted: (input: string, final: string) => `已轉換：${input} -> ${final}`,
        morseDecoded: (input: string, final: string) => `已解碼：${input} -> ${final}`,
        noActiveEditor: () => "沒有活動檔案！",
        noCommentToShow: () => "沒有可顯示的評論。",
        noFilesAvailableForLoading: (): string => "沒有可載入的檔案。",
        noFocusedEditors: () => "沒有焦點檔案。",
        noLogoInstanceProvided: () => "未提供徽標隨機實例。",
        noProvidedCommentOptions: () => "未提供註解選項。",
        notFoundFilePath: (filePath: string, error: string = "未提供") => `提供的檔案路徑不存在: '${filePath}'，錯誤: '${error}'`,
        openFileToApplyHeader: () => "請打開一個檔案以應用頭部。",
        operationCanceled: (): string => "操作已取消",
        quickPickError: (err: string) => `快速選擇錯誤：${err}`,
        quickPickNo: () => "否",
        quickPickYes: () => "是",
        ramdomLogoGatheringLogoUndefined: () => "徽標內容未定義。",
        randomLogoGatheringFailed: (error: string) => `隨機徽標收集失敗，使用預設徽標，錯誤：${error}`,
        readTimeout: (timeout: number, filePath: string): string => `讀取逾時: ${timeout} 毫秒，檔案: ${filePath}`,
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string) => `Hello world！副檔名：${fileExtension}，檔名：${fileName}，路徑：${filePath}，語言：${languageId}\n`,
        toMorseGetInput: (): string => "請輸入要轉換的文字",
        unknown: () => "未知",
        unknownFileStructure: () => "語言字典結構未知，因此評論適配被禁用。",
        updateAbortedBecauseFileClosedSyncCancelled: () => "更新中止，因為檔案已關閉且不會同步。",
        updateEditDateMissingBounds: () => "無法更新頭部：未找到內部標記。",
        updatingEditionDate: () => "更新版本日期。",
        watermarkAuthorName: () => "作者名稱",
        watermarkChosen: (watermark: string[]) => `要顯示的水印：${JSON.stringify(watermark)}`,
        watermarkCopied: (name: string) => `${name} 的 ASCII 藝術已複製！`,
        watermarkCopyAscii: () => "複製 ASCII",
        watermarkJsonFileInvalid: () => "水印 JSON 檔案為空或無效",
        watermarkName: () => "水印名稱",
        watermarkNotFound: () => "未找到水印",
        watermarkPersonDisplayed: (name: string) => `水印 '${name}' 已顯示。`,
        watermarkView: () => "水印檢視",
        watermarkZoomIn: () => "放大",
        watermarkZoomOut: () => "縮小"
    },
};
