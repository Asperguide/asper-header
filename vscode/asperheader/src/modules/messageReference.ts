/**
 * @file messageReference.ts
 * @brief Comprehensive multilingual message repository with advanced localization support
 * @author Henry Letellier
 * @version 1.0.8
 * @date 2025-10-03
 * @copyright (c) 2025 Asperguide - All rights reserved
 * 
 * @details This module serves as the authoritative multilingual message repository for the entire
 * AsperHeader extension ecosystem. It implements a sophisticated internationalization
 * framework that provides consistent, culturally-appropriate messaging across all user
 * interfaces, error conditions, and interactive elements while supporting dynamic
 * parameter interpolation and context-aware message generation.
 * 
 * @section Architecture Localization Architecture
 * The module implements a multi-layered localization system with the following components:
 * 
 * @subsection MultiLanguageSupport Multi-Language Support
 * - Complete translations for 15+ languages including English, French, Italian, Spanish, German, Japanese, Korean, Chinese (Simplified & Traditional), Russian, Portuguese, Turkish, Polish, Czech, and Hungarian
 * - Standardized message key consistency across all language variants
 * - Professional native speaker translations with technical domain expertise
 * 
 * @subsection FunctionBasedMessages Function-Based Message System  
 * - Dynamic parameter interpolation with full TypeScript type safety
 * - Named parameter substitution with `{paramName}` syntax support
 * - Automatic type conversion and locale-aware formatting
 * - Security-conscious parameter escaping for HTML contexts
 * 
 * @subsection CulturalAdaptation Cultural Adaptation Framework
 * - Language-specific formatting rules and cultural considerations
 * - Context-sensitive plural forms for different linguistic structures
 * - Locale-appropriate number, currency, and date formatting
 * - Right-to-left (RTL) language preparation for future expansion
 * 
 * @subsection ExtensibilityFramework Extensible Plugin Architecture
 * - Modular design enabling seamless addition of new languages
 * - Standardized message key interface for consistent expansion
 * - Automated validation tools for translation completeness
 * - Hot-reload capability for development and testing scenarios
 * 
 * @section LanguageMatrix Supported Language Matrix
 * @subsection PrimaryLanguages Primary Languages (100% Coverage)
 * - **English (en)**: Primary reference language - complete message coverage with American English conventions
 * - **French (fr)**: Professional translation with French cultural adaptations and technical terminology
 * - **Italian (it)**: Complete localization with Italian conventions and technical domain expertise
 * - **Spanish (es)**: Full Spanish translation with Latin American and European Spanish considerations
 * - **German (de)**: Comprehensive German localization with technical precision and formal register
 * 
 * @subsection AsianLanguages Asian Languages (Full Support)
 * - **Japanese (ja)**: Native Japanese translation with proper honorific usage and technical terminology
 * - **Korean (ko)**: Complete Korean localization with appropriate formality levels
 * - **Chinese Simplified (zh-cn)**: Mainland Chinese translation with simplified characters
 * - **Chinese Traditional (zh-tw)**: Traditional Chinese for Taiwan and Hong Kong regions
 * 
 * @subsection EuropeanLanguages Additional European Languages
 * - **Russian (ru)**: Full Cyrillic script support with Russian technical conventions
 * - **Portuguese (pt-br)**: Brazilian Portuguese with regional adaptations
 * - **Turkish (tr)**: Complete Turkish localization with agglutinative language considerations
 * - **Polish (pl)**: Polish translation with complex grammar and case system support
 * - **Czech (cs)**: Czech localization with Slavic language characteristics
 * - **Hungarian (hu)**: Hungarian translation with unique Finno-Ugric linguistic features
 * 
 * @section MessageClassification Message Classification and Organization
 * Messages are systematically organized into functional categories for maintainability:
 * 
 * @subsection UserInterfaceMessages User Interface Messages
 * - Dialog prompts and confirmation dialogs (`quickPickYes`, `quickPickNo`)
 * - Button labels and interactive element text (`copyAscii`, `zoomIn`, `zoomOut`)
 * - Input field prompts and validation messages (`getHeaderDescription`, `getHeaderTags`)
 * - Menu items and command descriptions
 * 
 * @subsection SystemOperationMessages System Operation Messages
 * - File I/O operations (`fileLoaded`, `fileParseError`, `fileSaveFailed`)
 * - Configuration management and settings validation
 * - Directory and workspace management (`cwdUpdated`, `cwdDoesNotExist`)
 * - Process lifecycle and state management
 * 
 * @subsection HeaderManagementMessages Header Management Messages
 * - Template generation and metadata handling (`headerOpenerFound`, `headerWriteSuccess`)
 * - Content creation and injection workflows (`headerInjectQuestion`)
 * - Date and timestamp management (`lastModifiedUpdated`)
 * - Header validation and integrity checks (`brokenHeader`)
 * 
 * @subsection ErrorReportingMessages Error Reporting and Diagnostics
 * - Comprehensive error messages with actionable guidance
 * - Input validation errors (`inputboxError`, `quickPickError`)
 * - File operation failures with diagnostic information
 * - System state errors and recovery suggestions
 * 
 * @subsection FeatureContentMessages Specialized Feature Messages
 * - Watermark display and management (`watermarkPersonDisplayed`, `watermarkCopied`)
 * - Character showcase functionality (`darlingPersonDisplayed`, `darlingCopied`)
 * - Logo randomization and display (`logoDisplayed`, `logoChosen`)
 * - ASCII art handling and clipboard operations
 * 
 * @subsection ExtensionLifecycleMessages Extension Lifecycle Messages
 * - Activation and initialization (`extensionActivated`)
 * - Deactivation and cleanup procedures
 * - Status updates and operational notifications
 * - Version and compatibility information
 * 
 * @subsection DevelopmentSupportMessages Development Support Messages
 * - Debug output and diagnostic information (`arrayNodeContent`)
 * - Development-oriented logging and tracing
 * - Performance metrics and optimization data
 * - Testing and validation support messages
 * 
 * @section TechnicalImplementation Technical Implementation Details
 * 
 * @subsection FunctionBasedDesign Function-Based Architecture
 * Each message is implemented as a function to enable:
 * - Dynamic parameter injection with compile-time type checking
 * - Runtime parameter validation and sanitization
 * - Contextual message generation based on application state
 * - Deferred execution for performance optimization
 * 
 * @subsection TypeSafetySystem TypeScript Type Safety System
 * - Strongly-typed parameter interfaces ensure consistency across languages
 * - Generic type parameters for flexible message function signatures
 * - Compile-time validation of parameter count and types
 * - Runtime type assertion for development safety
 * 
 * @subsection PerformanceOptimization Performance Optimization Strategies
 * - Lazy evaluation prevents unnecessary message generation
 * - Efficient parameter handling with minimal object allocation
 * - Message caching for frequently accessed strings
 * - Tree-shaking support for production bundle optimization
 * 
 * @subsection MemoryManagement Memory Management
 * - Optimal memory usage through selective message loading
 * - Garbage collection friendly implementation patterns
 * - Minimal closure overhead in message functions
 * - Language pack loading on demand for memory efficiency
 * 
 * @subsection ErrorResilienceFramework Error Resilience Framework
 * - Graceful fallback to English for missing translations
 * - Runtime detection of incomplete language packs
 * - Error logging for missing message keys during development
 * - Automatic recovery from corrupted message data
 * 
 * @section ParameterInterpolation Parameter Interpolation System
 * 
 * @subsection NamedParameters Named Parameter Substitution
 * - Template syntax: `{paramName}` for clear parameter identification
 * - Case-sensitive parameter matching with validation
 * - Nested object property access support: `{object.property}`
 * - Default value specification: `{param|defaultValue}`
 * 
 * @subsection PositionalArguments Positional Parameter System
 * - Sequential parameter replacement for simple message templates
 * - Zero-indexed positional parameters: `{0}`, `{1}`, etc.
 * - Mixed named and positional parameter support
 * - Overflow protection for parameter count mismatches
 * 
 * @subsection TypeConversionSystem Type Conversion and Formatting
 * - Automatic type coercion for string, number, and boolean values
 * - Date and time formatting with locale-aware patterns
 * - Currency formatting with regional currency symbols
 * - Percentage and decimal formatting with locale rules
 * 
 * @subsection SecurityEscaping Security-Conscious Parameter Escaping
 * - HTML entity escaping for web view contexts
 * - URL encoding for parameter values in URLs
 * - JSON escape sequences for data serialization
 * - SQL injection prevention for database contexts
 * 
 * @subsection PluralizationRules Context-Sensitive Pluralization
 * - Language-specific plural form rules (singular, plural, zero, few, many)
 * - Cardinal and ordinal number pluralization support
 * - Gender-sensitive pluralization for applicable languages
 * - Custom pluralization rules for domain-specific terms
 * 
 * @subsection LocaleFormatting Locale-Appropriate Formatting
 * - Number formatting with locale-specific separators and grouping
 * - Currency display with proper symbol placement and precision
 * - Date and time formatting following regional conventions
 * - Unit conversion and display for measurements
 * 
 * Quality Assurance Process:
 * - **Native Speaker Review**: All translations reviewed by native speakers
 * - **Technical Accuracy**: Technical terminology validated by subject matter experts
 * - **Cultural Sensitivity**: Messages adapted for cultural appropriateness
 * - **Consistency Checking**: Automated validation of message key completeness
 * - **Context Validation**: Messages tested in actual usage contexts
 * 
 * Integration Framework:
 * This module provides the foundation for all user-facing text throughout:
 * - **Core Extension**: Primary extension interfaces and workflows
 * - **Configuration System**: Settings descriptions and validation messages
 * - **Interactive Features**: Webview content and user interaction prompts
 * - **Error Handling**: Comprehensive error reporting and diagnostic messages
 * - **Development Tools**: Debug output and development-oriented information
 * 
 * @example Message structure and usage:
 * ```typescript
 * const messages = {
 *   en: {
 *     fileLoaded: (filename: string) => `Successfully loaded ${filename}`,
 *     operationComplete: (count: number, duration: string) => 
 *       `Processed ${count} files in ${duration}`
 *   },
 *   fr: {
 *     fileLoaded: (filename: string) => `Fichier ${filename} charg√© avec succ√®s`,
 *     operationComplete: (count: number, duration: string) => 
 *       `${count} fichiers trait√©s en ${duration}`
 *   }
 * };
 * ```
 * 
 * @example Advanced localization features:
 * ```typescript
 * // Context-aware pluralization
 * itemCount: (count: number) => count === 1 ? "1 item" : `${count} items`,
 * 
 * // Cultural adaptations
 * dateFormat: (date: Date) => date.toLocaleDateString('en-US'),
 * 
 * // Technical terminology
 * configurationError: (setting: string, value: any) => 
 *   `Invalid configuration for ${setting}: ${value}`
 * ```
 */

/**
 * @brief Complete message dictionary for all supported languages with type-safe function interfaces
 * @export Exported for use by the MessageProvider system and extension components
 * 
 * @details Central repository of all localized messages used throughout the AsperHeader extension.
 * Each language is represented as a nested object where message keys map to functions
 * that generate the appropriate localized string. The function-based architecture enables
 * sophisticated localization features while maintaining type safety and performance.
 * 
 * @section FunctionBasedMessaging Function-Based Message Architecture
 * Function-based messages provide several key advantages:
 * - **Dynamic Parameter Interpolation**: Contextual information injection at runtime
 * - **Type-Safe Parameter Passing**: Full TypeScript type checking and IntelliSense support
 * - **Consistent Message Formatting**: Uniform parameter handling across all languages
 * - **Runtime Message Generation**: Complex conditional and contextual message creation
 * - **Performance Optimization**: Lazy evaluation and parameter validation
 * 
 * @section LanguageSupport Comprehensive Language Support
 * @subsection PrimaryLanguages Primary Language Support (100% Coverage)
 * - **en**: English (primary) - Complete reference implementation with American English conventions
 * - **fr**: French - Professional translation with French linguistic and cultural adaptations
 * - **it**: Italian - Complete Italian localization with proper grammatical structures
 * - **es**: Spanish - Full Spanish translation covering Latin American and European variants
 * - **de**: German - Comprehensive German localization with technical precision
 * 
 * @subsection GlobalLanguages Extended Global Language Support
 * - **ja**: Japanese - Native Japanese with proper honorifics and technical terminology
 * - **ko**: Korean - Complete Korean with appropriate formality levels
 * - **zh-cn**: Chinese Simplified - Mainland Chinese with simplified character set
 * - **zh-tw**: Chinese Traditional - Traditional Chinese for Taiwan/Hong Kong regions
 * - **ru**: Russian - Full Cyrillic support with Russian technical conventions
 * - **pt-br**: Brazilian Portuguese - Regional Brazilian adaptations
 * - **tr**: Turkish - Turkish localization with agglutinative language considerations
 * - **pl**: Polish - Polish with complex grammar and case system support
 * - **cs**: Czech - Czech localization with Slavic linguistic characteristics
 * - **hu**: Hungarian - Hungarian with unique Finno-Ugric language features
 * 
 * @section UsagePatterns Usage Patterns and Examples
 * @code{.typescript}
 * // Basic parameter interpolation
 * messages.en.fileLoaded("/path/to/file")          // "File /path/to/file loaded!"
 * messages.fr.fileLoaded("/chemin/vers/fichier")   // "Fichier /chemin/vers/fichier charg√© !"
 * 
 * // Complex multi-parameter messages
 * messages.en.sayHelloWorldResponse(".ts", "main.ts", "/src/main.ts", "typescript")
 * // "Hello world! This file's extension is: .ts, it's name is: main.ts..."
 * 
 * // Error handling with contextual information
 * messages.en.fileParseError("/invalid.json", "SyntaxError: Unexpected token")
 * // "The file content (/invalid.json) could not be loaded successfully. Error: SyntaxError..."
 * @endcode
 * 
 * @section MessageCategories Functional Message Categories
 * Messages are systematically organized into the following categories:
 * 
 * @subsection IOOperations Input/Output Operations
 * - File loading, saving, and parsing operations (`fileLoaded`, `fileParseError`, `fileSaveFailed`)
 * - Directory and workspace management (`cwdUpdated`, `filePathUpdated`)
 * - Configuration file handling and validation
 * 
 * @subsection UserInterface User Interface Interactions
 * - Dialog prompts and confirmations (`quickPickYes`, `quickPickNo`, `headerInjectQuestion`)
 * - Input field labels and validation messages (`getHeaderDescription`, `getHeaderTags`)
 * - Button labels and interactive element text (`copyAscii`, `zoomIn`, `zoomOut`)
 * 
 * @subsection HeaderManagement Header Management Operations
 * - Header creation, updating, and validation (`headerOpenerFound`, `headerWriteSuccess`)
 * - Template injection and refresh workflows (`headerInjectQuestion`, `lastModifiedUpdated`)
 * - Metadata extraction and timestamp management (`updatingEditionDate`)
 * 
 * @subsection FeatureDisplays Specialized Feature Operations
 * - Watermark display and clipboard operations (`watermarkPersonDisplayed`, `watermarkCopied`)
 * - Character showcase functionality (`darlingPersonDisplayed`, `darlingCopied`)
 * - Logo randomization and display management (`logoDisplayed`, `logoChosen`)
 * - ASCII art processing and user interactions
 * 
 * @subsection ErrorHandling Error Handling and Diagnostics
 * - File operation errors with actionable guidance (`fileSaveFailed`, `fileParseError`)
 * - Input validation failures (`inputboxError`, `quickPickError`)
 * - System state errors and recovery procedures (`closedDocument`, `emptyDocument`)
 * - Language and configuration detection failures (`languageNotFound`, `missingFileError`)
 * 
 * @subsection ExtensionLifecycle Extension Lifecycle Management
 * - Activation and initialization notifications (`extensionActivated`, `helloWorldGreetingsCommand`)
 * - Status updates and operational feedback (`messageWritten`, `extensionActivated`)
 * - Resource management and cleanup procedures
 * 
 * @subsection DevelopmentUtilities Development and Debugging Support
 * - Debug output and diagnostic information (`arrayNodeContent`, `inputArgs`)
 * - Performance monitoring and optimization data
 * - Development-time logging and error tracking (`errorDuringFunctionCall`)
 * 
 * @section TypeSafetyContract Type Safety Contract
 * @note All message functions must maintain consistent parameter signatures across languages
 * @note Parameter types should be explicitly defined in TypeScript for compile-time validation
 * @note Runtime parameter validation should be implemented for production safety
 * 
 * @section FallbackMechanism Fallback and Error Handling
 * @note Missing translations automatically fall back to English through the MessageProvider system
 * @note Undefined message keys return a standardized error message with the missing key identifier
 * @note Language pack validation occurs during extension initialization for early error detection
 * 
 * @since 1.0.0
 * @version 1.0.8
 * @see MessageProvider For the primary interface to access these messages
 * @see Logger For integration with the extension's logging system
 */
export const messages: Record<string, Record<string, (...args: any[]) => string>> = {
    "en": {
        alternateFilePathUpdated: (oldFilePath: string, newFilePath: string): string => `The alternate path has been updated from ${oldFilePath} to ${newFilePath}.`,
        alternateLogoDirectoryNotFound: (alternateRootDirectory: string, error: string = "Not Provided"): string => `The alternate logo root directory '${alternateRootDirectory}' was not found, error: '${error}'.`,
        alternateLogoDirectoryNotProvided: (): string => `No alternate logo directory provided.`,
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]): string => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}.`,
        brokenHeader: (): string => "Broken header detected, injecting new one, please remove the previous one.",
        cacheAlreadyLoaded: (): string => "The cache is already loaded, returning stored instance.",
        chooseSingleLineCommentOption: (): string => "Please select your preferred comment prefix from the options below:",
        closedDocument: (): string => "The document is closed, stopping operations.",
        convertedContentCli: (content: string): string => `Converted content: ${content}`,
        convertedContentGui: (): string => "Converted content: ",
        corruptedFileMetaData: (): string => "The required file meta data appears to not have been gathered correctly, aborting.",
        cwdDoesNotExist: (cwd: string): string => `The provided current working directory ${cwd} does not exist.`,
        cwdUpdated: (oldCwd: string, newCwd: string): string => `The current working directory referential has been updated from ${oldCwd} to ${newCwd}.`,
        darlingAge: (): string => "Age",
        darlingAlias: (): string => "Alias",
        darlingCopied: (name: string): string => `ASCII art copied for ${name}!`,
        darlingCopyAscii: (): string => "Copy ASCII",
        darlingDescription: (): string => "Description",
        darlingHeight: (): string => "Height",
        darlingImage: (): string => "Image",
        darlingJsonFileInvalid: (): string => "Darling JSON file is empty or invalid",
        darlingMoreInfo: (): string => "More info",
        darlingPersonDisplayed: (name: string): string => `Character '${name}' displayed.`,
        darlingQuote: (): string => "Quote",
        darlingType: (): string => "Type",
        darlingView: (): string => "darlingView",
        darlingZoomIn: (): string => "Zoom In",
        darlingZoomOut: (): string => "Zoom Out",
        documentLineScanExceeded: (maxScanLength: number): string => `Scanned the first ${maxScanLength} line(s) of the file but no header was found.`,
        emptyDocument: (): string => "There is no document body to work with.",
        errorDuringFunctionCall: (functionName: string): string => `Something went wrong during the function (${functionName}) call, check logs for more info.`,
        extensionActivated: (moduleName: string): string => `üöÄ "${moduleName}" is now active!`,
        fileExcludedActivationDisabled: (): string => "Activation disabled, the file is in the activation exclusion list.",
        fileLength: (filePath: string, fileLength: number): string => `File: '${filePath}', length: ${fileLength} bytes.`,
        fileLoaded: (absolutePath: string): string => `File ${absolutePath} loaded!`,
        fileLoadError: (filePath: string, error: string = "Notprovided"): string => `Failed to load file: '${filePath}'. Error: ${error}.`,
        fileNotFound: (filePath: string): string => `File not found: ${filePath}`,
        fileParseError: (filePath: string, error: string): string => `The file content (${filePath}) could not be loaded successfully. Error: ${error}.`,
        filepathPresenceCheck: (filePath: string): string => `Checking filepath presence: ${filePath}`,
        filePathProcessing: (filepath: string): string => `Processing file path: '${filepath}'.`,
        filePathUpdated: (oldFilePath: string, newFilePath: string): string => `The path has been updated from ${oldFilePath} to ${newFilePath}.`,
        fileRefreshed: (): string => "Refreshing file content.",
        fileSaveFailed: (): string => "Failed to save the file, please try saving it again.",
        fileUnloaded: (filePath: string): string => `File ${filePath} unloaded from memory`,
        foundAlternateFilePathToLoad: (alternateFilePath: string) => `The alternate file path to load is set to '${alternateFilePath}'.`,
        foundAlternateLogoRootDir: (rootDir: string): string => `The current alternate logo root directory is: '${rootDir}'.`,
        foundCurrentWorkingDirectory: (cwd: string): string => `The current working directory has been set to '${cwd}'.`,
        foundFilePath: (filePath: string): string => `The provided file path exists: '${filePath}'.`,
        foundFilePathToLoad: (filePath: string) => `The file path to load is set to '${filePath}'.`,
        foundFocusEditor: (): string => "There is an editor in focus",
        foundLanguageComment: (): string => "Language comment file is present",
        foundLogoInstance: (): string => "There is a logo instance that has been provided.",
        foundLogoRootDir: (rootDir: string): string => `The current logo root directory is: '${rootDir}'.`,
        foundNewLine: (newLineType: string): string => `The new determined line is '${newLineType}'`,
        foundWorkingDirectory: (): string => "The provided current workign directory exists",
        fromMorseGetInput: (): string => "Please enter the text to convert from",
        getHeaderDescription: (): string => "Please provide a description: ",
        getHeaderPurpose: (): string => "Please provide the purpose of the file:",
        getHeaderTags: (): string => "Please enter the tags for this file, separated by commas:",
        headerInjectQuestion: (): string => "No header was found in this document. Would you like to add one?",
        headerInjectQuestionRefused: (): string => "You decided not to add the a header to the file.",
        headerNotFound: (): string => "No header was found in this document.",
        headerOpenerAndCloserFound: (): string => "Header opener and closer found, proceeding to date update after sanity check.",
        headerOpenerFound: (): string => "Header opener found.",
        headerWriteFailed: (): string => "Failed to write the header to the file, check the logs.",
        headerWriteSuccess: (): string => "Header written successfully.",
        helloWorldGreetingsCommand: (moduleName: string): string => `Hello World from ${moduleName}!`,
        identifiedLanguage: (langName: string): string => `Identified language: ${langName}.`,
        inFunction: (functionName: string, className: string = "Not specified") => `In function: '${functionName}' from class: '${className}'`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string): string => `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        inputboxError: (promptText: string, err: string): string => `Error in inputBox for ${promptText}: ${err}`,
        jsonContent: (jsonContentString: String) => `The content of the comment json file: ${jsonContentString}`,
        languageNotFound: (LanguageId: string, fileExtension: string): string => `The file language of this document could not be identified, languageID: ${LanguageId}, fileExtention: ${fileExtension}`,
        lastModifiedLineNotFound: (): string => "The header does not contain a 'Last Modified' line to update.",
        lastModifiedUpdated: (): string => "Last Modified' date has been updated successfully.",
        logoChosen: (logo: string[]): string => `Logo to display: ${JSON.stringify(logo)}`,
        logoCopied: (logoName: string): string => `ASCII art copied for ${logoName}!`,
        logoCopyAscii: (): string => "Copy ASCII",
        logoDisplayed: (name: string): string => `Logo '${name}' displayed.`,
        logoMessage: (logoPath: string): string => `File (${logoPath}) ignored because it is not the type we are looking for.`,
        logoName: (): string => "Logo name",
        logoNoRootDir: (): string => "No root directory was provided for gathering the logos",
        logoNotFound: (): string => "Logo not found",
        logoRootDirUpdateError: (error: string = "Not provided"): string => `An error occurred during the update of the logo files, error: ${error}`,
        logoView: (): string => "logoView",
        logoZoomIn: (): string => "Zoom In",
        logoZoomOut: (): string => "Zoom Out",
        messageNotFound: (key: string): string => `Message '${key}' not found.`,
        messageWritten: (): string => "Message written",
        missingFileError: (): string => "The language dictionary is missing, comment adaptability is thus disabled.",
        missingLanguageComment: (): string => "Language comment not provided, skipping assignement.",
        morseConverted: (input: string, final: string): string => `Converted: ${input} to ${final}`,
        morseDecoded: (input: string, final: string): string => `Converted: ${input} to ${final}`,
        noActiveEditor: (): string => "No active file!",
        noCommentToShow: (): string => "There is no comment to show.",
        noFilesAvailableForLoading: (): string => "There are no file that can be loaded.",
        noFocusedEditors: (): string => "There are no files in focus.",
        noLogoInstanceProvided: (): string => "No provided logo randomiser instance.",
        noProvidedCommentOptions: (): string => "There are no options that were provided.",
        notFoundFilePath: (filePath: string, error: string = "Not provided"): string => `The provided file path does not exist: '${filePath}', error: '${error}'`,
        openFileToApplyHeader: (): string => "Please open a file on which to apply the header.",
        operationCanceled: (): string => "Operation cancelled",
        quickPickError: (err: string = "Not provided"): string => `Error in quickPick: ${err}`,
        quickPickNo: (): string => "No",
        quickPickYes: (): string => "Yes",
        ramdomLogoGatheringLogoUndefined: (): string => "The logo content is undefined.",
        randomLogoGatheringFailed: (error: string = "Not provided"): string => `The random logo gathering failed, using default logo, error: "${error}"`,
        readTimeout: (timeout: number, filePath: string): string => `Read timeout after: ${timeout}ms for ${filePath}`,
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string): string => `Hello world! This file's extension is: ${fileExtension}, it's name is: ${fileName}, it's path is: ${filePath}, determined language: ${languageId}\n`,
        toMorseGetInput: (): string => "Please enter the text to convert",
        unknown: (): string => "Unknown",
        unknownFileStructure: (): string => "The language dictionary structure is unknown, comment adaptability is thus disabled.",
        updateAbortedBecauseFileClosedSyncCancelled: (): string => "Update aborted because the file is closed and will thus not be synced.",
        updateEditDateMissingBounds: (): string => "Could not update the header: internal header markers were not found.",
        updatingEditionDate: (): string => "Updating the edition date.",
        watermarkAuthorName: (): string => "Author name",
        watermarkChosen: (watermark: string[]): string => `Watermark to display: ${JSON.stringify(watermark)}`,
        watermarkCopied: (name: string): string => `ASCII art copied for ${name}!`,
        watermarkCopyAscii: (): string => "Copy ASCII",
        watermarkJsonFileInvalid: (): string => "Watermark JSON file is empty or invalid",
        watermarkName: (): string => "Watermark name",
        watermarkNotFound: (): string => "Watermark not found",
        watermarkPersonDisplayed: (name: string): string => `Watermark '${name}' displayed.`,
        watermarkView: (): string => "watermarkView",
        watermarkZoomIn: (): string => "Zoom In",
        watermarkZoomOut: (): string => "Zoom Out"
    },
    "fr": {
        alternateFilePathUpdated: (oldFilePath: string, newFilePath: string): string => `Le chemin alternatif a √©t√© mis √† jour de ${oldFilePath} vers ${newFilePath}.`,
        alternateLogoDirectoryNotFound: (alternateRootDirectory: string, error: string = "Non fourni") => `Le r√©pertoire racine du logo alternatif '${alternateRootDirectory}' est introuvable, erreur : '${error}'.`,
        alternateLogoDirectoryNotProvided: () => `Aucun r√©pertoire de logo alternatif n‚Äôa √©t√© fourni.`,
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]): string => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}.`,
        brokenHeader: (): string => "En-t√™te corrompu d√©tect√©, injection d‚Äôun nouveau, veuillez supprimer l‚Äôancien.",
        cacheAlreadyLoaded: (): string => "Le cache est d√©j√† charg√©, retour de l'instance stock√©e.",
        chooseSingleLineCommentOption: (): string => "Veuillez s√©lectionner votre pr√©fixe de commentaire pr√©f√©r√© parmi les options ci-dessous :",
        closedDocument: (): string => "Le document est ferm√©, arr√™t des op√©rations.",
        convertedContentCli: (content: string): string => `Contenu converti : ${content}`,
        convertedContentGui: (): string => "Contenu converti : ",
        corruptedFileMetaData: (): string => "Les m√©tadonn√©es n√©cessaires du fichier n‚Äôont pas √©t√© correctement collect√©es, abandon.",
        cwdDoesNotExist: (cwd: string): string => `Le r√©pertoire de travail fourni ${cwd} n‚Äôexiste pas.`,
        cwdUpdated: (oldCwd: string, newCwd: string): string => `Le r√©pertoire de travail a √©t√© mis √† jour de ${oldCwd} vers ${newCwd}.`,
        darlingAge: (): string => "√Çge",
        darlingAlias: (): string => "Alias",
        darlingCopied: (name: string): string => `Art ASCII copi√© pour ${name} !`,
        darlingCopyAscii: (): string => "Copier l'ASCII",
        darlingDescription: (): string => "Description",
        darlingHeight: (): string => "Taille",
        darlingImage: (): string => "Image",
        darlingJsonFileInvalid: (): string => "Le fichier JSON Darling est vide ou invalide",
        darlingMoreInfo: (): string => "Plus d'infos",
        darlingPersonDisplayed: (name: string): string => `Personnage '${name}' affich√©.`,
        darlingQuote: (): string => "Citation",
        darlingType: (): string => "Type",
        darlingView: (): string => "vueDarling",
        darlingZoomIn: (): string => "Zoomer",
        darlingZoomOut: (): string => "D√©zoomer",
        documentLineScanExceeded: (maxScanLength: number): string => `Analyse des ${maxScanLength} premi√®res lignes du fichier, aucun en-t√™te trouv√©.`,
        emptyDocument: (): string => "Il n‚Äôy a aucun document √† traiter.",
        errorDuringFunctionCall: (functionName: string): string => `Une erreur est survenue lors de l‚Äôappel de la fonction (${functionName}), consultez les journaux.`,
        extensionActivated: (moduleName: string): string => `üöÄ L'extension ¬´ ${moduleName} ¬ª est maintenant active !`,
        fileExcludedActivationDisabled: (): string => "Activation d√©sactiv√©e, le fichier est dans la liste d'exclusion.",
        fileLength: (filePath: string, fileLength: number): string => `Fichier : '${filePath}', longueur : ${fileLength} octets.`,
        fileLoaded: (absolutePath: string): string => `Fichier ${absolutePath} charg√© !`,
        fileLoadError: (filePath: string, error: string = "NonFourni"): string => `√âchec du chargement du fichier : '${filePath}'. Erreur : ${error}.`,
        fileNotFound: (filePath: string): string => `Fichier introuvable : ${filePath}`,
        fileParseError: (filePath: string, error: string): string => `Le contenu du fichier (${filePath}) n‚Äôa pas pu √™tre charg√© correctement. Erreur : ${error}.`,
        filepathPresenceCheck: (filePath: string): string => `V√©rification de la pr√©sence du chemin de fichier : ${filePath}`,
        filePathProcessing: (filepath: string): string => `Traitement du chemin de fichier : '${filepath}'.`,
        filePathUpdated: (oldFilePath: string, newFilePath: string): string => `Le chemin a √©t√© mis √† jour de ${oldFilePath} vers ${newFilePath}.`,
        fileRefreshed: (): string => "Actualisation du contenu du fichier.",
        fileSaveFailed: (): string => "√âchec de la sauvegarde du fichier, veuillez r√©essayer.",
        fileUnloaded: (filePath: string): string => `Fichier ${filePath} d√©charg√© de la m√©moire.`,
        foundAlternateFilePathToLoad: (alternateFilePath: string) => `Le chemin de fichier alternatif √† charger est d√©fini sur '${alternateFilePath}'.`,
        foundAlternateLogoRootDir: (rootDir: string) => `Le r√©pertoire racine alternatif du logo actuel est : '${rootDir}'.`,
        foundCurrentWorkingDirectory: (cwd: string) => `Le r√©pertoire de travail actuel est d√©fini sur '${cwd}'.`,
        foundFilePath: (filePath: string) => `Le chemin de fichier fourni existe : '${filePath}'.`,
        foundFilePathToLoad: (filePath: string) => `Le chemin de fichier √† charger est d√©fini sur '${filePath}'.`,
        foundFocusEditor: () => `Un √©diteur est actuellement actif.`,
        foundLanguageComment: () => `Le fichier de commentaire de langue est pr√©sent.`,
        foundLogoInstance: () => `Une instance de logo a √©t√© fournie.`,
        foundLogoRootDir: (rootDir: string) => `Le r√©pertoire racine du logo actuel est : '${rootDir}'.`,
        foundNewLine: (newLineType: string) => `Le nouveau type de ligne d√©termin√© est '${newLineType}'.`,
        foundWorkingDirectory: () => `Le r√©pertoire de travail fourni existe.`,
        fromMorseGetInput: (): string => "Veuillez entrer le texte √† convertir depuis",
        getHeaderDescription: (): string => "Veuillez fournir une description : ",
        getHeaderPurpose: (): string => "Veuillez fournir l‚Äôobjectif du fichier :",
        getHeaderTags: (): string => "Veuillez saisir les tags de ce fichier, s√©par√©s par des virgules :",
        headerInjectQuestion: (): string => "Aucun en-t√™te trouv√© dans ce document. Souhaitez-vous en ajouter un ?",
        headerInjectQuestionRefused: (): string => "Vous avez d√©cid√© de ne pas ajouter d'en-t√™te au fichier.",
        headerNotFound: (): string => "Aucun en-t√™te trouv√© dans ce document.",
        headerOpenerAndCloserFound: (): string => "D√©but et fin d‚Äôen-t√™te trouv√©s, mise √† jour de la date apr√®s v√©rification.",
        headerOpenerFound: (): string => "D√©but d‚Äôen-t√™te trouv√©.",
        headerWriteFailed: (): string => "√âchec de l‚Äô√©criture de l‚Äôen-t√™te dans le fichier, consultez les journaux.",
        headerWriteSuccess: (): string => "En-t√™te √©crit avec succ√®s.",
        helloWorldGreetingsCommand: (moduleName: string): string => `Hello World de ${moduleName} !`,
        identifiedLanguage: (langName: string): string => `Langage identifi√© : ${langName}.`,
        inFunction: (functionName: string, className: string = "Non sp√©cifi√©") => `Dans la fonction : '${functionName}' de la classe : '${className}'`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string): string => `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        inputboxError: (promptText: string, err: string): string => `Erreur dans la bo√Æte de saisie pour ${promptText} : ${err}`,
        jsonContent: (jsonContentString: String) => `Contenu du fichier JSON de commentaires : ${jsonContentString}`,
        languageNotFound: (LanguageId: string, fileExtension: string): string => `La langue du fichier de ce document n'a pas pu √™tre identifi√©e, languageID : ${LanguageId}, extension du fichier : ${fileExtension}`,
        lastModifiedLineNotFound: (): string => "L‚Äôen-t√™te ne contient pas de ligne ¬´ Derni√®re modification ¬ª √† mettre √† jour.",
        lastModifiedUpdated: (): string => "La date de ¬´ Derni√®re modification ¬ª a √©t√© mise √† jour avec succ√®s.",
        logoChosen: (logo: string[]): string => `Logo √† afficher : ${JSON.stringify(logo)}`,
        logoCopied: (logoName: string): string => `Art ASCII copi√© pour ${logoName} !`,
        logoCopyAscii: (): string => "Copier l'ASCII",
        logoDisplayed: (name: string): string => `Logo '${name}' affich√©.`,
        logoMessage: (logoPath: string): string => `Fichier (${logoPath}) ignor√© car ce n'est pas le type recherch√©.`,
        logoName: (): string => "Nom du logo",
        logoNoRootDir: (): string => "Aucun r√©pertoire racine fourni pour collecter les logos",
        logoNotFound: (): string => "Logo introuvable",
        logoRootDirUpdateError: (error: string): string => `Erreur lors de la mise √† jour des fichiers de logo, erreur : ${error}`,
        logoView: (): string => "vueLogo",
        logoZoomIn: (): string => "Zoomer",
        logoZoomOut: (): string => "D√©zoomer",
        messageNotFound: (key: string): string => `Message '${key}' introuvable.`,
        messageWritten: (): string => "Message √©crit",
        missingFileError: (): string => "Le dictionnaire des langages est manquant, l‚Äôadaptabilit√© des commentaires est d√©sactiv√©e.",
        missingLanguageComment: (): string => "Commentaire de langage non fourni, assignation ignor√©e.",
        morseConverted: (input: string, final: string): string => `Converti : ${input} en ${final}`,
        morseDecoded: (input: string, final: string): string => `Converti : ${input} en ${final}`,
        noActiveEditor: (): string => "Aucun fichier actif !",
        noCommentToShow: (): string => "Il n‚Äôy a aucun commentaire √† afficher.",
        noFilesAvailableForLoading: (): string => "Aucun fichier disponible pour le chargement.",
        noFocusedEditors: (): string => "Aucun fichier n‚Äôest en focus.",
        noLogoInstanceProvided: (): string => "Aucune instance de randomiseur de logo fournie.",
        noProvidedCommentOptions: (): string => "Aucune option de commentaire n‚Äôa √©t√© fournie.",
        notFoundFilePath: (filePath: string, error: string = "Non fourni") => `Le chemin de fichier fourni n'existe pas : '${filePath}', erreur : '${error}'`,
        openFileToApplyHeader: (): string => "Veuillez ouvrir un fichier sur lequel appliquer l‚Äôen-t√™te.",
        operationCanceled: (): string => "Op√©ration annul√©e",
        quickPickError: (err: string): string => `Erreur dans quickPick : ${err}`,
        quickPickNo: (): string => "Non",
        quickPickYes: (): string => "Oui",
        ramdomLogoGatheringLogoUndefined: (): string => "Le contenu du logo est ind√©fini.",
        randomLogoGatheringFailed: (error: string): string => `La collecte al√©atoire de logo a √©chou√©, utilisation du logo par d√©faut, erreur : "${error}"`,
        readTimeout: (timeout: number, filePath: string): string => `D√©lai de lecture d√©pass√© apr√®s : ${timeout}ms pour ${filePath}`,
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string): string => `Hello world ! Extension : ${fileExtension}, nom : ${fileName}, chemin : ${filePath}, langage : ${languageId}\n`,
        toMorseGetInput: (): string => "Veuillez entrer le texte √† convertir",
        unknown: (): string => "Inconnu",
        unknownFileStructure: (): string => "La structure du dictionnaire des langages est inconnue, l‚Äôadaptabilit√© des commentaires est d√©sactiv√©e.",
        updateAbortedBecauseFileClosedSyncCancelled: (): string => "Mise √† jour annul√©e car le fichier est ferm√© et ne sera pas synchronis√©.",
        updateEditDateMissingBounds: (): string => "Impossible de mettre √† jour l‚Äôen-t√™te : les marqueurs internes n‚Äôont pas √©t√© trouv√©s.",
        updatingEditionDate: (): string => "Mise √† jour de la date de modification.",
        watermarkAuthorName: (): string => "Auteur",
        watermarkChosen: (watermark: string[]): string => `Watermark √† afficher : ${JSON.stringify(watermark)}`,
        watermarkCopied: (name: string): string => `Art ASCII copi√© pour ${name} !`,
        watermarkCopyAscii: (): string => "Copier l'ASCII",
        watermarkJsonFileInvalid: (): string => "Le fichier JSON de watermark est vide ou invalide",
        watermarkName: (): string => "Nom du watermark",
        watermarkNotFound: (): string => "Watermark introuvable",
        watermarkPersonDisplayed: (name: string): string => `Watermark '${name}' affich√©.`,
        watermarkView: (): string => "vueWatermark",
        watermarkZoomIn: (): string => "Zoomer",
        watermarkZoomOut: (): string => "D√©zoomer"
    },
    "it": {
        alternateFilePathUpdated: (oldFilePath: string, newFilePath: string): string => `Il percorso alternativo √® stato aggiornato da ${oldFilePath} a ${newFilePath}.`,
        alternateLogoDirectoryNotFound: (alternateRootDirectory: string, error: string = "Non fornito") => `La directory principale del logo alternativo '${alternateRootDirectory}' non √® stata trovata, errore: '${error}'.`,
        alternateLogoDirectoryNotProvided: () => `Nessuna directory alternativa del logo fornita.`,
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]): string => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}.`,
        brokenHeader: (): string => "Intestazione danneggiata rilevata, iniezione di una nuova, si prega di rimuovere la precedente.",
        cacheAlreadyLoaded: (): string => "La cache √® gi√† stata caricata, restituzione dell'istanza memorizzata.",
        chooseSingleLineCommentOption: (): string => "Seleziona il prefisso di commento preferito dalle opzioni qui sotto:",
        closedDocument: (): string => "Il documento √® chiuso, operazioni interrotte.",
        convertedContentCli: (content: string): string => `Contenuto convertito: ${content}`,
        convertedContentGui: (): string => "Contenuto convertito: ",
        corruptedFileMetaData: (): string => "I metadati richiesti del file non sono stati raccolti correttamente, interruzione.",
        cwdDoesNotExist: (cwd: string): string => `La directory di lavoro fornita ${cwd} non esiste.`,
        cwdUpdated: (oldCwd: string, newCwd: string): string => `La directory di lavoro √® stata aggiornata da ${oldCwd} a ${newCwd}.`,
        darlingAge: (): string => "Et√†",
        darlingAlias: (): string => "Alias",
        darlingCopied: (name: string): string => `Arte ASCII copiata per ${name}!`,
        darlingCopyAscii: (): string => "Copia ASCII",
        darlingDescription: (): string => "Descrizione",
        darlingHeight: (): string => "Altezza",
        darlingImage: (): string => "Immagine",
        darlingJsonFileInvalid: (): string => "Il file JSON Darling √® vuoto o non valido",
        darlingMoreInfo: (): string => "Maggiori info",
        darlingPersonDisplayed: (name: string): string => `Personaggio '${name}' visualizzato.`,
        darlingQuote: (): string => "Citazione",
        darlingType: (): string => "Tipo",
        darlingView: (): string => "vistaDarling",
        darlingZoomIn: (): string => "Ingrandisci",
        darlingZoomOut: (): string => "Rimpicciolisci",
        documentLineScanExceeded: (maxScanLength: number): string => `Analizzate le prime ${maxScanLength} righe del file, nessuna intestazione trovata.`,
        emptyDocument: (): string => "Non c‚Äô√® alcun documento su cui lavorare.",
        errorDuringFunctionCall: (functionName: string): string => `Qualcosa √® andato storto durante la chiamata della funzione (${functionName}), controlla i log per maggiori informazioni.`,
        extensionActivated: (moduleName: string): string => `üöÄ La tua estensione ¬´ ${moduleName} ¬ª √® ora attiva!`,
        fileExcludedActivationDisabled: (): string => "Attivazione disabilitata, il file √® nella lista di esclusione.",
        fileLength: (filePath: string, fileLength: number): string => `File: '${filePath}', lunghezza: ${fileLength} byte.`,
        fileLoaded: (absolutePath: string): string => `File ${absolutePath} caricato!`,
        fileLoadError: (filePath: string, error: string = "NonFornito"): string => `Impossibile caricare il file: '${filePath}'. Errore: ${error}.`,
        fileNotFound: (filePath: string): string => `File non trovato: ${filePath}`,
        fileParseError: (filePath: string, error: string): string => `Il contenuto del file (${filePath}) non √® stato caricato correttamente. Errore: ${error}.`,
        filepathPresenceCheck: (filePath: string): string => `Verifica della presenza del percorso del file: ${filePath}`,
        filePathProcessing: (filepath: string): string => `Elaborazione del percorso del file: '${filepath}'.`,
        filePathUpdated: (oldFilePath: string, newFilePath: string): string => `Il percorso √® stato aggiornato da ${oldFilePath} a ${newFilePath}.`,
        fileRefreshed: (): string => "Aggiornamento del contenuto del file.",
        fileSaveFailed: (): string => "Salvataggio del file fallito, riprova a salvarlo.",
        fileUnloaded: (filePath: string): string => `File ${filePath} scaricato dalla memoria.`,
        foundAlternateFilePathToLoad: (alternateFilePath: string) => `Il percorso del file alternativo da caricare √® impostato su '${alternateFilePath}'.`,
        foundAlternateLogoRootDir: (rootDir: string) => `La directory principale alternativa del logo corrente √®: '${rootDir}'.`,
        foundCurrentWorkingDirectory: (cwd: string) => `La directory di lavoro corrente √® impostata su '${cwd}'.`,
        foundFilePath: (filePath: string) => `Il percorso del file fornito esiste: '${filePath}'.`,
        foundFilePathToLoad: (filePath: string) => `Il percorso del file da caricare √® impostato su '${filePath}'.`,
        foundFocusEditor: () => `C'√® un editor attivo.`,
        foundLanguageComment: () => `Il file di commento della lingua √® presente.`,
        foundLogoInstance: () => `√à stata fornita un'istanza di logo.`,
        foundLogoRootDir: (rootDir: string) => `La directory principale del logo corrente √®: '${rootDir}'.`,
        foundNewLine: (newLineType: string) => `Il nuovo tipo di riga determinato √® '${newLineType}'.`,
        foundWorkingDirectory: () => `La directory di lavoro fornita esiste.`,
        fromMorseGetInput: (): string => "Inserisci il testo da convertire da",
        getHeaderDescription: (): string => "Fornisci una descrizione: ",
        getHeaderPurpose: (): string => "Fornisci lo scopo del file:",
        getHeaderTags: (): string => "Inserisci i tag per questo file, separati da virgole:",
        headerInjectQuestion: (): string => "Nessuna intestazione trovata in questo documento. Vuoi aggiungerne una?",
        headerInjectQuestionRefused: (): string => "Hai deciso di non aggiungere un'intestazione al file.",
        headerNotFound: (): string => "Nessuna intestazione trovata in questo documento.",
        headerOpenerAndCloserFound: (): string => "Inizio e fine intestazione trovati, aggiornamento della data dopo il controllo.",
        headerOpenerFound: (): string => "Inizio intestazione trovato.",
        headerWriteFailed: (): string => "Impossibile scrivere l‚Äôintestazione nel file, controlla i log.",
        headerWriteSuccess: (): string => "Intestazione scritta con successo.",
        helloWorldGreetingsCommand: (moduleName: string): string => `Hello World da ${moduleName}!`,
        identifiedLanguage: (langName: string): string => `Linguaggio identificato: ${langName}.`,
        inFunction: (functionName: string, className: string = "Non specificato") => `Nella funzione: '${functionName}' della classe: '${className}'`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string): string => `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        inputboxError: (promptText: string, err: string): string => `Errore nella inputBox per ${promptText}: ${err}`,
        jsonContent: (jsonContentString: String) => `Contenuto del file JSON dei commenti: ${jsonContentString}`,
        languageNotFound: (LanguageId: string, fileExtension: string): string => `Non √® stato possibile identificare la lingua del file di questo documento, languageID: ${LanguageId}, estensione del file: ${fileExtension}`,
        lastModifiedLineNotFound: (): string => "L‚Äôintestazione non contiene una riga 'Ultima modifica' da aggiornare.",
        lastModifiedUpdated: (): string => "La data di 'Ultima modifica' √® stata aggiornata con successo.",
        logoChosen: (logo: string[]): string => `Logo da visualizzare: ${JSON.stringify(logo)}`,
        logoCopied: (logoName: string): string => `Arte ASCII copiata per ${logoName}!`,
        logoCopyAscii: (): string => "Copia ASCII",
        logoDisplayed: (name: string): string => `Logo '${name}' visualizzato.`,
        logoMessage: (logoPath: string): string => `File (${logoPath}) ignorato perch√© non √® del tipo cercato.`,
        logoName: (): string => "Nome logo",
        logoNoRootDir: (): string => "Nessuna directory radice fornita per raccogliere i loghi",
        logoNotFound: (): string => "Logo non trovato",
        logoRootDirUpdateError: (error: string): string => `Errore durante l'aggiornamento dei file logo, errore: ${error}`,
        logoView: (): string => "vistaLogo",
        logoZoomIn: (): string => "Ingrandisci",
        logoZoomOut: (): string => "Rimpicciolisci",
        messageNotFound: (key: string): string => `Messaggio '${key}' non trovato.`,
        messageWritten: (): string => "Messaggio scritto",
        missingFileError: (): string => "Il dizionario dei linguaggi √® mancante, adattabilit√† dei commenti disabilitata.",
        missingLanguageComment: (): string => "Commento del linguaggio non fornito, assegnazione ignorata.",
        morseConverted: (input: string, final: string): string => `Convertito: ${input} in ${final}`,
        morseDecoded: (input: string, final: string): string => `Convertito: ${input} in ${final}`,
        noActiveEditor: (): string => "Nessun file attivo!",
        noCommentToShow: (): string => "Non ci sono commenti da mostrare.",
        noFilesAvailableForLoading: (): string => "Non ci sono file disponibili per il caricamento.",
        noFocusedEditors: (): string => "Non ci sono file in focus.",
        noLogoInstanceProvided: (): string => "Nessuna istanza di randomizzatore logo fornita.",
        noProvidedCommentOptions: (): string => "Non sono state fornite opzioni di commento.",
        notFoundFilePath: (filePath: string, error: string = "Non fornito") => `Il percorso del file fornito non esiste: '${filePath}', errore: '${error}'`,
        openFileToApplyHeader: (): string => "Apri un file su cui applicare l‚Äôintestazione.",
        operationCanceled: (): string => "Operazione annullata",
        quickPickError: (err: string): string => `Errore in quickPick: ${err}`,
        quickPickNo: (): string => "No",
        quickPickYes: (): string => "S√¨",
        ramdomLogoGatheringLogoUndefined: (): string => "Il contenuto del logo √® indefinito.",
        randomLogoGatheringFailed: (error: string): string => `La raccolta casuale del logo √® fallita, uso del logo predefinito, errore: "${error}"`,
        readTimeout: (timeout: number, filePath: string): string => `Timeout di lettura dopo: ${timeout}ms per ${filePath}`,
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string): string => `Hello world! Estensione: ${fileExtension}, nome: ${fileName}, percorso: ${filePath}, linguaggio: ${languageId}\n`,
        toMorseGetInput: (): string => "Inserisci il testo da convertire",
        unknown: (): string => "Sconosciuto",
        unknownFileStructure: (): string => "La struttura del dizionario dei linguaggi √® sconosciuta, adattabilit√† dei commenti disabilitata.",
        updateAbortedBecauseFileClosedSyncCancelled: (): string => "Aggiornamento annullato perch√© il file √® chiuso e non sar√† sincronizzato.",
        updateEditDateMissingBounds: (): string => "Impossibile aggiornare l‚Äôintestazione: marcatori interni non trovati.",
        updatingEditionDate: (): string => "Aggiornamento della data di modifica.",
        watermarkAuthorName: (): string => "Nome autore: ",
        watermarkChosen: (watermark: string[]): string => `Watermark da visualizzare: ${JSON.stringify(watermark)}`,
        watermarkCopied: (name: string): string => `Arte ASCII copiata per ${name}!`,
        watermarkCopyAscii: (): string => "Copia ASCII",
        watermarkJsonFileInvalid: (): string => "Il file JSON watermark √® vuoto o non valido",
        watermarkName: (): string => "Nome watermark",
        watermarkNotFound: (): string => "Watermark non trovato",
        watermarkPersonDisplayed: (name: string): string => `Watermark '${name}' visualizzato.`,
        watermarkView: (): string => "vistaWatermark",
        watermarkZoomIn: (): string => "Ingrandisci",
        watermarkZoomOut: (): string => "Rimpicciolisci"
    },
    "es": {
        alternateFilePathUpdated: (oldFilePath: string, newFilePath: string): string => `La ruta alternativa se ha actualizado de ${oldFilePath} a ${newFilePath}.`,
        alternateLogoDirectoryNotFound: (alternateRootDirectory: string, error: string = "No proporcionado") => `No se encontr√≥ el directorio ra√≠z del logotipo alternativo '${alternateRootDirectory}', error: '${error}'.`,
        alternateLogoDirectoryNotProvided: () => `No se ha proporcionado un directorio de logotipos alternativo.`,
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]): string => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}.`,
        brokenHeader: (): string => "Encabezado roto detectado, inyectando uno nuevo, por favor elimina el anterior.",
        cacheAlreadyLoaded: (): string => "La cach√© ya est√° cargada, devolviendo la instancia almacenada.",
        chooseSingleLineCommentOption: (): string => "Seleccione su prefijo de comentario preferido de las opciones a continuaci√≥n:",
        closedDocument: (): string => "El documento est√° cerrado, deteniendo operaciones.",
        convertedContentCli: (content: string): string => `Contenido convertido: ${content}`,
        convertedContentGui: (): string => "Contenido convertido: ",
        corruptedFileMetaData: (): string => "Los metadatos del archivo no se recopilaron correctamente, abortando.",
        cwdDoesNotExist: (cwd: string): string => `El directorio de trabajo proporcionado ${cwd} no existe.`,
        cwdUpdated: (oldCwd: string, newCwd: string): string => `El directorio de trabajo se actualiz√≥ de ${oldCwd} a ${newCwd}.`,
        darlingAge: (): string => "Edad",
        darlingAlias: (): string => "Alias",
        darlingCopied: (name: string): string => `Arte ASCII copiado para ${name}!`,
        darlingCopyAscii: (): string => "Copiar ASCII",
        darlingDescription: (): string => "Descripci√≥n",
        darlingHeight: (): string => "Altura",
        darlingImage: (): string => "Imagen",
        darlingJsonFileInvalid: (): string => "El archivo JSON de Darling est√° vac√≠o o es inv√°lido",
        darlingMoreInfo: (): string => "M√°s informaci√≥n",
        darlingPersonDisplayed: (name: string): string => `Personaje '${name}' mostrado.`,
        darlingQuote: (): string => "Cita",
        darlingType: (): string => "Tipo",
        darlingView: (): string => "vistaDarling",
        darlingZoomIn: (): string => "Acercar",
        darlingZoomOut: (): string => "Alejar",
        documentLineScanExceeded: (maxScanLength: number): string => `Se escanearon las primeras ${maxScanLength} l√≠neas del archivo pero no se encontr√≥ encabezado.`,
        emptyDocument: (): string => "No hay contenido en el documento.",
        errorDuringFunctionCall: (functionName: string): string => `Algo sali√≥ mal durante la llamada de la funci√≥n (${functionName}), revise los registros.`,
        extensionActivated: (moduleName: string): string => `üöÄ La extensi√≥n "${moduleName}" ahora est√° activa!`,
        fileExcludedActivationDisabled: (): string => "Activaci√≥n deshabilitada, el archivo est√° en la lista de exclusi√≥n.",
        fileLength: (filePath: string, fileLength: number): string => `Archivo: '${filePath}', longitud: ${fileLength} bytes.`,
        fileLoaded: (absolutePath: string): string => `Archivo ${absolutePath} cargado!`,
        fileLoadError: (filePath: string, error: string = "NoProporcionado"): string => `Error al cargar el archivo: '${filePath}'. Error: ${error}.`,
        fileNotFound: (filePath: string): string => `Archivo no encontrado: ${filePath}`,
        fileParseError: (filePath: string, error: string): string => `El contenido del archivo (${filePath}) no se pudo cargar correctamente. Error: ${error}.`,
        filepathPresenceCheck: (filePath: string): string => `Verificando la presencia de la ruta del archivo: ${filePath}`,
        filePathProcessing: (filepath: string): string => `Procesando la ruta del archivo: '${filepath}'.`,
        filePathUpdated: (oldFilePath: string, newFilePath: string): string => `La ruta se actualiz√≥ de ${oldFilePath} a ${newFilePath}.`,
        fileRefreshed: (): string => "Actualizando contenido del archivo.",
        fileSaveFailed: (): string => "No se pudo guardar el archivo, intente guardarlo nuevamente.",
        fileUnloaded: (filePath: string): string => `Archivo ${filePath} descargado de la memoria.`,
        foundAlternateFilePathToLoad: (alternateFilePath: string) => `La ruta de archivo alternativa para cargar est√° configurada en '${alternateFilePath}'.`,
        foundAlternateLogoRootDir: (rootDir: string) => `El directorio ra√≠z alternativo del logotipo actual es: '${rootDir}'.`,
        foundCurrentWorkingDirectory: (cwd: string) => `El directorio de trabajo actual est√° configurado en '${cwd}'.`,
        foundFilePath: (filePath: string) => `La ruta de archivo proporcionada existe: '${filePath}'.`,
        foundFilePathToLoad: (filePath: string) => `La ruta de archivo para cargar est√° configurada en '${filePath}'.`,
        foundFocusEditor: () => `Hay un editor enfocado.`,
        foundLanguageComment: () => `El archivo de comentarios de idioma est√° presente.`,
        foundLogoInstance: () => `Se ha proporcionado una instancia de logotipo.`,
        foundLogoRootDir: (rootDir: string) => `El directorio ra√≠z del logotipo actual es: '${rootDir}'.`,
        foundNewLine: (newLineType: string) => `El nuevo tipo de l√≠nea determinado es '${newLineType}'.`,
        foundWorkingDirectory: () => `El directorio de trabajo proporcionado existe.`,
        fromMorseGetInput: (): string => "Por favor, introduzca el texto a convertir desde",
        getHeaderDescription: (): string => "Por favor, proporciona una descripci√≥n: ",
        getHeaderPurpose: (): string => "Proporcione el prop√≥sito del archivo:",
        getHeaderTags: (): string => "Ingrese las etiquetas para este archivo, separadas por comas:",
        headerInjectQuestion: (): string => "No se encontr√≥ encabezado en este documento. ¬øDesea agregar uno?",
        headerInjectQuestionRefused: (): string => "Decidi√≥ no agregar un encabezado al archivo.",
        headerNotFound: (): string => "No se encontr√≥ encabezado en este documento.",
        headerOpenerAndCloserFound: (): string => "Inicio y fin del encabezado encontrados, actualizando la fecha tras la verificaci√≥n.",
        headerOpenerFound: (): string => "Se encontr√≥ el inicio del encabezado.",
        headerWriteFailed: (): string => "Error al escribir el encabezado en el archivo, revise los registros.",
        headerWriteSuccess: (): string => "Encabezado escrito con √©xito.",
        helloWorldGreetingsCommand: (moduleName: string): string => `¬°Hola Mundo desde ${moduleName}!`,
        identifiedLanguage: (langName: string): string => `Idioma identificado: ${langName}.`,
        inFunction: (functionName: string, className: string = "No especificado") => `En la funci√≥n: '${functionName}' de la clase: '${className}'`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string): string => `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        inputboxError: (promptText: string, err: string): string => `Error en la inputBox para ${promptText}: ${err}`,
        jsonContent: (jsonContentString: String) => `Contenido del archivo JSON de comentarios: ${jsonContentString}`,
        languageNotFound: (LanguageId: string, fileExtension: string): string => `No se pudo identificar el idioma del archivo de este documento, languageID: ${LanguageId}, extensi√≥n del archivo: ${fileExtension}`,
        lastModifiedLineNotFound: (): string => "El encabezado no contiene una l√≠nea '√öltima modificaci√≥n' para actualizar.",
        lastModifiedUpdated: (): string => "La fecha de '√öltima modificaci√≥n' se actualiz√≥ correctamente.",
        logoChosen: (logo: string[]): string => `Logo a mostrar: ${JSON.stringify(logo)}`,
        logoCopied: (logoName: string): string => `Arte ASCII copiado para ${logoName}!`,
        logoCopyAscii: (): string => "Copiar ASCII",
        logoDisplayed: (name: string): string => `Logo '${name}' mostrado.`,
        logoMessage: (logoPath: string): string => `Archivo (${logoPath}) ignorado porque no es el tipo buscado.`,
        logoName: (): string => "Nombre del logo",
        logoNoRootDir: (): string => "No se proporcion√≥ directorio ra√≠z para recopilar los logos",
        logoNotFound: (): string => "Logo no encontrado",
        logoRootDirUpdateError: (error: string): string => `Ocurri√≥ un error durante la actualizaci√≥n de los archivos de logo, error: ${error}`,
        logoView: (): string => "vistaLogo",
        logoZoomIn: (): string => "Acercar",
        logoZoomOut: (): string => "Alejar",
        messageNotFound: (key: string): string => `Mensaje '${key}' no encontrado.`,
        messageWritten: (): string => "Mensaje escrito",
        missingFileError: (): string => "Falta el diccionario de idiomas, la adaptabilidad de comentarios est√° deshabilitada.",
        missingLanguageComment: (): string => "Comentario de idioma no proporcionado, omitiendo asignaci√≥n.",
        morseConverted: (input: string, final: string): string => `Convertido: ${input} a ${final}`,
        morseDecoded: (input: string, final: string): string => `Convertido: ${input} a ${final}`,
        noActiveEditor: (): string => "¬°No hay archivo activo!",
        noCommentToShow: (): string => "No hay comentarios para mostrar.",
        noFilesAvailableForLoading: (): string => "No hay archivos disponibles para cargar.",
        noFocusedEditors: (): string => "No hay archivos enfocados.",
        noLogoInstanceProvided: (): string => "No se proporcion√≥ instancia de randomizador de logo.",
        noProvidedCommentOptions: (): string => "No se proporcionaron opciones de comentario.",
        notFoundFilePath: (filePath: string, error: string = "No proporcionado") => `La ruta de archivo proporcionada no existe: '${filePath}', error: '${error}'`,
        openFileToApplyHeader: (): string => "Por favor, abre un archivo para aplicar el encabezado.",
        operationCanceled: (): string => "Operaci√≥n cancelada",
        quickPickError: (err: string): string => `Error en quickPick: ${err}`,
        quickPickNo: (): string => "No",
        quickPickYes: (): string => "S√≠",
        ramdomLogoGatheringLogoUndefined: (): string => "El contenido del logo es indefinido.",
        randomLogoGatheringFailed: (error: string): string => `La recopilaci√≥n aleatoria de logos fall√≥, usando el logo predeterminado, error: "${error}"`,
        readTimeout: (timeout: number, filePath: string): string => `Tiempo de lectura agotado despu√©s de: ${timeout}ms para ${filePath}`,
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string): string => `¬°Hola mundo! La extensi√≥n de este archivo es: ${fileExtension}, su nombre es: ${fileName}, su ruta es: ${filePath}, lenguaje determinado: ${languageId}\n`,
        toMorseGetInput: (): string => "Por favor, introduzca el texto a convertir",
        unknown: (): string => "Desconocido",
        unknownFileStructure: (): string => "La estructura del diccionario de idiomas es desconocida, la adaptabilidad de comentarios est√° deshabilitada.",
        updateAbortedBecauseFileClosedSyncCancelled: (): string => "Actualizaci√≥n abortada porque el archivo est√° cerrado y no se sincronizar√°.",
        updateEditDateMissingBounds: (): string => "No se pudo actualizar el encabezado: no se encontraron los marcadores internos.",
        updatingEditionDate: (): string => "Actualizando la fecha de edici√≥n.",
        watermarkAuthorName: (): string => "Nombre del autor",
        watermarkChosen: (watermark: string[]): string => `Marca de agua a mostrar: ${JSON.stringify(watermark)}`,
        watermarkCopied: (name: string): string => `Arte ASCII copiado para ${name}!`,
        watermarkCopyAscii: (): string => "Copiar ASCII",
        watermarkJsonFileInvalid: (): string => "El archivo JSON de la marca de agua est√° vac√≠o o es inv√°lido",
        watermarkName: (): string => "Nombre de la marca de agua",
        watermarkNotFound: (): string => "Marca de agua no encontrada",
        watermarkPersonDisplayed: (name: string): string => `Marca de agua '${name}' mostrada.`,
        watermarkView: (): string => "vistaMarcaAgua",
        watermarkZoomIn: (): string => "Acercar",
        watermarkZoomOut: (): string => "Alejar"
    },
    "de": {
        alternateFilePathUpdated: (oldFilePath: string, newFilePath: string): string => `Der alternative Pfad wurde von ${oldFilePath} auf ${newFilePath} aktualisiert.`,
        alternateLogoDirectoryNotFound: (alternateRootDirectory: string, error: string = "Nicht angegeben") => `Das alternative Logo-Stammverzeichnis '${alternateRootDirectory}' wurde nicht gefunden, Fehler: '${error}'.`,
        alternateLogoDirectoryNotProvided: () => `Kein alternatives Logo-Verzeichnis angegeben.`,
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]) => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}.`,
        brokenHeader: () => "Besch√§digter Header erkannt, f√ºge neuen Header ein, bitte vorherigen entfernen.",
        cacheAlreadyLoaded: (): string => "Der Cache ist bereits geladen, gespeicherte Instanz wird zur√ºckgegeben.",
        chooseSingleLineCommentOption: () => "Bitte bevorzugten Kommentarpr√§fix aus den Optionen unten ausw√§hlen:",
        closedDocument: () => "Das Dokument ist geschlossen, Operationen gestoppt.",
        convertedContentCli: (content: string): string => `Konvertierter Inhalt: ${content}`,
        convertedContentGui: (): string => "Konvertierter Inhalt: ",
        corruptedFileMetaData: () => "Datei-Metadaten wurden nicht korrekt gesammelt, Abbruch.",
        cwdDoesNotExist: (cwd: string) => `Das angegebene Arbeitsverzeichnis ${cwd} existiert nicht.`,
        cwdUpdated: (oldCwd: string, newCwd: string) => `Das aktuelle Arbeitsverzeichnis wurde von ${oldCwd} auf ${newCwd} aktualisiert.`,
        darlingAge: () => "Alter",
        darlingAlias: () => "Alias",
        darlingCopied: (name: string) => `ASCII-Kunst f√ºr ${name} kopiert!`,
        darlingCopyAscii: () => "ASCII kopieren",
        darlingDescription: () => "Beschreibung",
        darlingHeight: () => "Gr√∂√üe",
        darlingImage: () => "Bild",
        darlingJsonFileInvalid: () => "Darling JSON-Datei ist leer oder ung√ºltig",
        darlingMoreInfo: () => "Weitere Infos",
        darlingPersonDisplayed: (name: string) => `Charakter '${name}' angezeigt.`,
        darlingQuote: () => "Zitat",
        darlingType: () => "Typ",
        darlingView: () => "Charakter-Ansicht",
        darlingZoomIn: () => "Vergr√∂√üern",
        darlingZoomOut: () => "Verkleinern",
        documentLineScanExceeded: (maxScanLength: number) => `Erste ${maxScanLength} Zeilen der Datei gescannt, kein Header gefunden.`,
        emptyDocument: () => "Kein Dokument vorhanden.",
        errorDuringFunctionCall: (functionName: string) => `Fehler beim Aufruf der Funktion (${functionName}), pr√ºfen Sie die Logs.`,
        extensionActivated: (moduleName: string) => `üöÄ Erweiterung "${moduleName}" ist jetzt aktiv!`,
        fileExcludedActivationDisabled: () => "Aktivierung deaktiviert, Datei ist auf der Ausschlussliste.",
        fileLength: (filePath: string, fileLength: number): string => `Datei: '${filePath}', L√§nge: ${fileLength} Bytes.`,
        fileLoaded: (absolutePath: string) => `Datei ${absolutePath} geladen!`,
        fileLoadError: (filePath: string, error: string = "NichtBereitgestellt"): string => `Fehler beim Laden der Datei: '${filePath}'. Fehler: ${error}.`,
        fileNotFound: (filePath: string): string => `Datei nicht gefunden: ${filePath}`,
        fileParseError: (filePath: string, error: string) => `Dateiinhalt (${filePath}) konnte nicht erfolgreich geladen werden. Fehler: ${error}.`,
        filepathPresenceCheck: (filePath: string): string => `√úberpr√ºfung des Dateipfads: ${filePath}`,
        filePathProcessing: (filepath: string): string => `Verarbeitung des Dateipfads: '${filepath}'.`,
        filePathUpdated: (oldFilePath: string, newFilePath: string) => `Pfad wurde von ${oldFilePath} auf ${newFilePath} aktualisiert.`,
        fileRefreshed: () => "Dateiinhalt wird aktualisiert.",
        fileSaveFailed: () => "Datei konnte nicht gespeichert werden, bitte erneut versuchen.",
        fileUnloaded: (filePath: string) => `Datei ${filePath} aus dem Speicher entfernt.`,
        foundAlternateFilePathToLoad: (alternateFilePath: string) => `Der alternative zu ladende Dateipfad ist auf '${alternateFilePath}' gesetzt.`,
        foundAlternateLogoRootDir: (rootDir: string) => `Das aktuelle alternative Logo-Stammverzeichnis ist: '${rootDir}'.`,
        foundCurrentWorkingDirectory: (cwd: string) => `Das aktuelle Arbeitsverzeichnis ist auf '${cwd}' gesetzt.`,
        foundFilePath: (filePath: string) => `Der angegebene Dateipfad existiert: '${filePath}'.`,
        foundFilePathToLoad: (filePath: string) => `Der zu ladende Dateipfad ist auf '${filePath}' gesetzt.`,
        foundFocusEditor: () => `Ein Editor ist im Fokus.`,
        foundLanguageComment: () => `Die Sprachkommentar-Datei ist vorhanden.`,
        foundLogoInstance: () => `Eine Logo-Instanz wurde bereitgestellt.`,
        foundLogoRootDir: (rootDir: string) => `Das aktuelle Logo-Stammverzeichnis ist: '${rootDir}'.`,
        foundNewLine: (newLineType: string) => `Die neu bestimmte Zeile ist '${newLineType}'.`,
        foundWorkingDirectory: () => `Das angegebene Arbeitsverzeichnis existiert.`,
        fromMorseGetInput: (): string => "Bitte geben Sie den Text ein, der konvertiert werden soll",
        getHeaderDescription: () => "Bitte Beschreibung angeben:",
        getHeaderPurpose: () => "Bitte Zweck der Datei angeben:",
        getHeaderTags: () => "Bitte Tags f√ºr diese Datei eingeben, durch Kommas getrennt:",
        headerInjectQuestion: () => "Kein Header gefunden. M√∂chten Sie einen hinzuf√ºgen?",
        headerInjectQuestionRefused: () => "Sie haben entschieden, keinen Header hinzuzuf√ºgen.",
        headerNotFound: () => "Kein Header in diesem Dokument gefunden.",
        headerOpenerAndCloserFound: () => "Header-Start und -Ende gefunden, aktualisiere das Datum nach √úberpr√ºfung.",
        headerOpenerFound: () => "Header-Start gefunden.",
        headerWriteFailed: () => "Header konnte nicht in die Datei geschrieben werden, pr√ºfen Sie die Logs.",
        headerWriteSuccess: () => "Header erfolgreich geschrieben.",
        helloWorldGreetingsCommand: (moduleName: string) => `Hello World von ${moduleName}!`,
        identifiedLanguage: (langName: string) => `Identifizierte Sprache: ${langName}.`,
        inFunction: (functionName: string, className: string = "Nicht angegeben") => `In Funktion: '${functionName}' aus Klasse: '${className}'`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string) => `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        inputboxError: (promptText: string, err: string) => `Fehler im Eingabefeld f√ºr ${promptText}: ${err}`,
        jsonContent: (jsonContentString: String) => `Inhalt der Kommentar-JSON-Datei: ${jsonContentString}`,
        languageNotFound: (LanguageId: string, fileExtension: string) => `Dateisprache konnte nicht erkannt werden, languageID: ${LanguageId}, Dateierweiterung: ${fileExtension}`,
        lastModifiedLineNotFound: () => "Header enth√§lt keine 'Zuletzt ge√§ndert'-Zeile zum Aktualisieren.",
        lastModifiedUpdated: () => "'Zuletzt ge√§ndert'-Datum erfolgreich aktualisiert.",
        logoChosen: (logo: string[]) => `Anzuzeigendes Logo: ${JSON.stringify(logo)}`,
        logoCopied: (logoName: string) => `ASCII-Kunst f√ºr ${logoName} kopiert!`,
        logoCopyAscii: () => "ASCII kopieren",
        logoDisplayed: (name: string) => `Logo '${name}' angezeigt.`,
        logoMessage: (logoPath: string) => `Datei (${logoPath}) ignoriert, da sie nicht vom gesuchten Typ ist.`,
        logoName: () => "Logoname",
        logoNoRootDir: () => "Kein Stammverzeichnis zur Sammlung von Logos angegeben",
        logoNotFound: () => "Logo nicht gefunden",
        logoRootDirUpdateError: (error: string) => `Fehler beim Aktualisieren der Logodateien, Fehler: ${error}`,
        logoView: () => "Logo-Ansicht",
        logoZoomIn: () => "Vergr√∂√üern",
        logoZoomOut: () => "Verkleinern",
        messageNotFound: (key: string) => `Nachricht '${key}' nicht gefunden.`,
        messageWritten: () => "Nachricht geschrieben",
        missingFileError: () => "Sprachw√∂rterbuch fehlt, Kommentar-Anpassung deaktiviert.",
        missingLanguageComment: () => "Sprachkommentar nicht bereitgestellt, Zuweisung √ºbersprungen.",
        morseConverted: (input: string, final: string) => `Konvertiert: ${input} -> ${final}`,
        morseDecoded: (input: string, final: string) => `Dekodiert: ${input} -> ${final}`,
        noActiveEditor: () => "Keine aktive Datei!",
        noCommentToShow: () => "Kein Kommentar zum Anzeigen.",
        noFilesAvailableForLoading: (): string => "Es sind keine Dateien zum Laden verf√ºgbar.",
        noFocusedEditors: () => "Keine fokussierten Dateien.",
        noLogoInstanceProvided: () => "Keine Logo-Randomizer-Instanz bereitgestellt.",
        noProvidedCommentOptions: () => "Keine Kommentaroptionen bereitgestellt.",
        notFoundFilePath: (filePath: string, error: string = "Nicht angegeben") => `Der angegebene Dateipfad existiert nicht: '${filePath}', Fehler: '${error}'`,
        openFileToApplyHeader: () => "Bitte √∂ffnen Sie eine Datei, um den Header anzuwenden.",
        operationCanceled: (): string => "Vorgang abgebrochen",
        quickPickError: (err: string) => `Fehler in QuickPick: ${err}`,
        quickPickNo: () => "Nein",
        quickPickYes: () => "Ja",
        ramdomLogoGatheringLogoUndefined: () => "Logo-Inhalt ist undefiniert.",
        randomLogoGatheringFailed: (error: string) => `Zuf√§lliges Logo konnte nicht geladen werden, Standardlogo wird verwendet, Fehler: "${error}"`,
        readTimeout: (timeout: number, filePath: string): string => `Lesezeit√ºberschreitung nach: ${timeout}ms f√ºr ${filePath}`,
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string) => `Hello World! Dateiendung: ${fileExtension}, Name: ${fileName}, Pfad: ${filePath}, Sprache: ${languageId}\n`,
        toMorseGetInput: (): string => "Bitte geben Sie den zu konvertierenden Text ein",
        unknown: () => "Unbekannt",
        unknownFileStructure: () => "Sprachw√∂rterbuchstruktur unbekannt, Kommentar-Anpassung deaktiviert.",
        updateAbortedBecauseFileClosedSyncCancelled: () => "Update abgebrochen, da die Datei geschlossen ist und nicht synchronisiert wird.",
        updateEditDateMissingBounds: () => "Header konnte nicht aktualisiert werden: interne Marker nicht gefunden.",
        updatingEditionDate: () => "Aktualisiere das Erstellungsdatum.",
        watermarkAuthorName: () => "Autor",
        watermarkChosen: (watermark: string[]) => `Anzuzeigendes Wasserzeichen: ${JSON.stringify(watermark)}`,
        watermarkCopied: (name: string) => `ASCII-Kunst f√ºr ${name} kopiert!`,
        watermarkCopyAscii: () => "ASCII kopieren",
        watermarkJsonFileInvalid: () => "Wasserzeichen JSON-Datei ist leer oder ung√ºltig",
        watermarkName: () => "Wasserzeichenname",
        watermarkNotFound: () => "Wasserzeichen nicht gefunden",
        watermarkPersonDisplayed: (name: string) => `Wasserzeichen '${name}' angezeigt.`,
        watermarkView: () => "Wasserzeichen-Ansicht",
        watermarkZoomIn: () => "Vergr√∂√üern",
        watermarkZoomOut: () => "Verkleinern"
    },
    "ja": {
        alternateFilePathUpdated: (oldFilePath: string, newFilePath: string): string => `‰ª£Êõø„Éë„Çπ„Åå ${oldFilePath} „Åã„Çâ ${newFilePath} „Å´Êõ¥Êñ∞„Åï„Çå„Åæ„Åó„Åü„ÄÇ`,
        alternateLogoDirectoryNotFound: (alternateRootDirectory: string, error: string = "Êú™Êèê‰æõ") => `‰ª£Êõø„É≠„Ç¥„ÅÆ„É´„Éº„Éà„Éá„Ç£„É¨„ÇØ„Éà„É™ '${alternateRootDirectory}' „ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÅ„Ç®„É©„Éº: '${error}'„ÄÇ`,
        alternateLogoDirectoryNotProvided: () => `‰ª£Êõø„É≠„Ç¥„Éá„Ç£„É¨„ÇØ„Éà„É™„ÅåÊåáÂÆö„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ`,
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]) => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}„ÄÇ`,
        brokenHeader: () => "Â£ä„Çå„Åü„Éò„ÉÉ„ÉÄ„Éº„ÅåÊ§úÂá∫„Åï„Çå„Åæ„Åó„Åü„ÄÇÊñ∞„Åó„ÅÑ„Éò„ÉÉ„ÉÄ„Éº„ÇíÊåøÂÖ•„Åó„Åæ„Åô„ÄÇÂâç„ÅÆ„ÇÇ„ÅÆ„ÇíÂâäÈô§„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ",
        cacheAlreadyLoaded: (): string => "„Ç≠„É£„ÉÉ„Ç∑„É•„ÅØ„Åô„Åß„Å´Ë™≠„ÅøËæº„Åæ„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ‰øùÂ≠ò„Åï„Çå„Åü„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíËøî„Åó„Åæ„Åô„ÄÇ",
        chooseSingleLineCommentOption: () => "‰ª•‰∏ã„ÅÆ„Ç™„Éó„Ç∑„Éß„É≥„Åã„Çâ„Ç≥„É°„É≥„Éà„ÅÆ„Éó„É¨„Éï„Ç£„ÉÉ„ÇØ„Çπ„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ: ",
        closedDocument: () => "„Éâ„Ç≠„É•„É°„É≥„Éà„ÅØÈñâ„Åò„Çâ„Çå„Åæ„Åó„Åü„ÄÇÊìç‰Ωú„ÇíÂÅúÊ≠¢„Åó„Åæ„Åô„ÄÇ",
        convertedContentCli: (content: string): string => `Â§âÊèõ„Åï„Çå„ÅüÂÜÖÂÆπ: ${content}`,
        convertedContentGui: (): string => "Â§âÊèõ„Åï„Çå„ÅüÂÜÖÂÆπ: ",
        corruptedFileMetaData: () => "ÂøÖË¶Å„Å™„Éï„Ç°„Ç§„É´„É°„Çø„Éá„Éº„Çø„ÅåÊ≠£„Åó„ÅèÂèéÈõÜ„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ‰∏≠Ê≠¢„Åó„Åæ„Åô„ÄÇ",
        cwdDoesNotExist: (cwd: string) => `ÊåáÂÆö„Åï„Çå„Åü‰ΩúÊ•≠„Éá„Ç£„É¨„ÇØ„Éà„É™ ${cwd} „ÅØÂ≠òÂú®„Åó„Åæ„Åõ„Çì„ÄÇ`,
        cwdUpdated: (oldCwd: string, newCwd: string) => `ÁèæÂú®„ÅÆ‰ΩúÊ•≠„Éá„Ç£„É¨„ÇØ„Éà„É™„Çí ${oldCwd} „Åã„Çâ ${newCwd} „Å´Êõ¥Êñ∞„Åó„Åæ„Åó„Åü„ÄÇ`,
        darlingAge: () => "Âπ¥ÈΩ¢",
        darlingAlias: () => "Âà•Âêç",
        darlingCopied: (name: string) => `${name} „ÅÆ ASCII „Ç¢„Éº„Éà„Çí„Ç≥„Éî„Éº„Åó„Åæ„Åó„ÅüÔºÅ`,
        darlingCopyAscii: () => "ASCII „Çí„Ç≥„Éî„Éº",
        darlingDescription: () => "Ë™¨Êòé",
        darlingHeight: () => "Ë∫´Èï∑",
        darlingImage: () => "ÁîªÂÉè",
        darlingJsonFileInvalid: () => "Darling JSON „Éï„Ç°„Ç§„É´„ÅåÁ©∫„Åæ„Åü„ÅØÁÑ°Âäπ„Åß„Åô",
        darlingMoreInfo: () => "Ë©≥Á¥∞ÊÉÖÂ†±",
        darlingPersonDisplayed: (name: string) => `„Ç≠„É£„É©„ÇØ„Çø„Éº '${name}' „ÇíË°®Á§∫„Åó„Åæ„Åó„Åü„ÄÇ`,
        darlingQuote: () => "ÂºïÁî®",
        darlingType: () => "„Çø„Ç§„Éó",
        darlingView: () => "„Ç≠„É£„É©„ÇØ„Çø„Éº„Éì„É•„Éº",
        darlingZoomIn: () => "„Ç∫„Éº„É†„Ç§„É≥",
        darlingZoomOut: () => "„Ç∫„Éº„É†„Ç¢„Ç¶„Éà",
        documentLineScanExceeded: (maxScanLength: number) => `„Éï„Ç°„Ç§„É´„ÅÆÊúÄÂàù„ÅÆ ${maxScanLength} Ë°å„Çí„Çπ„Ç≠„É£„É≥„Åó„Åæ„Åó„Åü„Åå„ÄÅ„Éò„ÉÉ„ÉÄ„Éº„ÅØË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ`,
        emptyDocument: () => "„Éâ„Ç≠„É•„É°„É≥„Éà„ÅÆÊú¨Êñá„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ",
        errorDuringFunctionCall: (functionName: string) => `Èñ¢Êï∞ (${functionName}) „ÅÆÂëº„Å≥Âá∫„Åó‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ„É≠„Ç∞„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ`,
        extensionActivated: (moduleName: string) => `üöÄ "${moduleName}" Êã°ÂºµÊ©üËÉΩ„Åå„Ç¢„ÇØ„ÉÜ„Ç£„Éñ„Å´„Å™„Çä„Åæ„Åó„ÅüÔºÅ`,
        fileExcludedActivationDisabled: () => "„Ç¢„ÇØ„ÉÜ„Ç£„Éô„Éº„Ç∑„Éß„É≥„ÅØÁÑ°Âäπ„Åß„Åô„ÄÇ„Éï„Ç°„Ç§„É´„ÅØÈô§Â§ñ„É™„Çπ„Éà„Å´„ÅÇ„Çä„Åæ„Åô„ÄÇ",
        fileLength: (filePath: string, fileLength: number): string => `„Éï„Ç°„Ç§„É´: '${filePath}'„ÄÅÈï∑„Åï: ${fileLength} „Éê„Ç§„Éà„ÄÇ`,
        fileLoaded: (absolutePath: string) => `„Éï„Ç°„Ç§„É´ ${absolutePath} „ÇíË™≠„ÅøËæº„Åø„Åæ„Åó„ÅüÔºÅ`,
        fileLoadError: (filePath: string, error: string = "Êú™ÊåáÂÆö"): string => `„Éï„Ç°„Ç§„É´ '${filePath}' „ÅÆË™≠„ÅøËæº„Åø„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ„Ç®„É©„Éº: ${error}„ÄÇ`,
        fileNotFound: (filePath: string): string => `„Éï„Ç°„Ç§„É´„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì: ${filePath}`,
        fileParseError: (filePath: string, error: string) => `„Éï„Ç°„Ç§„É´„ÅÆÂÜÖÂÆπ (${filePath}) „ÇíÊ≠£Â∏∏„Å´Ë™≠„ÅøËæº„ÇÅ„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ„Ç®„É©„Éº: ${error}„ÄÇ`,
        filepathPresenceCheck: (filePath: string): string => `„Éï„Ç°„Ç§„É´„Éë„Çπ„ÅÆÂ≠òÂú®„ÇíÁ¢∫Ë™ç‰∏≠: ${filePath}`,
        filePathProcessing: (filepath: string): string => `„Éï„Ç°„Ç§„É´„Éë„Çπ„ÇíÂá¶ÁêÜ‰∏≠: '${filepath}'„ÄÇ`,
        filePathUpdated: (oldFilePath: string, newFilePath: string) => `„Éë„Çπ„Çí ${oldFilePath} „Åã„Çâ ${newFilePath} „Å´Êõ¥Êñ∞„Åó„Åæ„Åó„Åü„ÄÇ`,
        fileRefreshed: () => "„Éï„Ç°„Ç§„É´ÂÜÖÂÆπ„ÇíÊõ¥Êñ∞„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ",
        fileSaveFailed: () => "„Éï„Ç°„Ç§„É´„ÅÆ‰øùÂ≠ò„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ„ÇÇ„ÅÜ‰∏ÄÂ∫¶‰øùÂ≠ò„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ",
        fileUnloaded: (filePath: string) => `„Éï„Ç°„Ç§„É´ ${filePath} „Çí„É°„É¢„É™„Åã„Çâ„Ç¢„É≥„É≠„Éº„Éâ„Åó„Åæ„Åó„Åü„ÄÇ`,
        foundAlternateFilePathToLoad: (alternateFilePath: string) => `Ë™≠„ÅøËæº„ÇÄ‰ª£Êõø„Éï„Ç°„Ç§„É´„Éë„Çπ„ÅØ '${alternateFilePath}' „Å´Ë®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ`,
        foundAlternateLogoRootDir: (rootDir: string) => `ÁèæÂú®„ÅÆ‰ª£Êõø„É≠„Ç¥„ÅÆ„É´„Éº„Éà„Éá„Ç£„É¨„ÇØ„Éà„É™„ÅØ '${rootDir}' „Åß„Åô„ÄÇ`,
        foundCurrentWorkingDirectory: (cwd: string) => `ÁèæÂú®„ÅÆ‰ΩúÊ•≠„Éá„Ç£„É¨„ÇØ„Éà„É™„ÅØ '${cwd}' „Å´Ë®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ`,
        foundFilePath: (filePath: string) => `ÊåáÂÆö„Åï„Çå„Åü„Éï„Ç°„Ç§„É´„Éë„Çπ„ÅØÂ≠òÂú®„Åó„Åæ„Åô: '${filePath}'„ÄÇ`,
        foundFilePathToLoad: (filePath: string) => `Ë™≠„ÅøËæº„ÇÄ„Éï„Ç°„Ç§„É´„Éë„Çπ„ÅØ '${filePath}' „Å´Ë®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ`,
        foundFocusEditor: () => `„Éï„Ç©„Éº„Ç´„Çπ„Åï„Çå„Å¶„ÅÑ„Çã„Ç®„Éá„Ç£„Çø„Éº„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ`,
        foundLanguageComment: () => `Ë®ÄË™û„Ç≥„É°„É≥„Éà„Éï„Ç°„Ç§„É´„ÅåÂ≠òÂú®„Åó„Åæ„Åô„ÄÇ`,
        foundLogoInstance: () => `„É≠„Ç¥„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÅåÊèê‰æõ„Åï„Çå„Åæ„Åó„Åü„ÄÇ`,
        foundLogoRootDir: (rootDir: string) => `ÁèæÂú®„ÅÆ„É≠„Ç¥„ÅÆ„É´„Éº„Éà„Éá„Ç£„É¨„ÇØ„Éà„É™„ÅØ '${rootDir}' „Åß„Åô„ÄÇ`,
        foundNewLine: (newLineType: string) => `Êñ∞„Åó„ÅèÊ§úÂá∫„Åï„Çå„ÅüÊîπË°å„Çø„Ç§„Éó„ÅØ '${newLineType}' „Åß„Åô„ÄÇ`,
        foundWorkingDirectory: () => `ÊåáÂÆö„Åï„Çå„Åü‰ΩúÊ•≠„Éá„Ç£„É¨„ÇØ„Éà„É™„ÅØÂ≠òÂú®„Åó„Åæ„Åô„ÄÇ`,
        fromMorseGetInput: (): string => "Â§âÊèõÂÖÉ„ÅÆ„ÉÜ„Ç≠„Çπ„Éà„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ",
        getHeaderDescription: () => "Ë™¨Êòé„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ: ",
        getHeaderPurpose: () => "„Éï„Ç°„Ç§„É´„ÅÆÁõÆÁöÑ„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ: ",
        getHeaderTags: () => "„Åì„ÅÆ„Éï„Ç°„Ç§„É´„ÅÆ„Çø„Ç∞„Çí„Ç´„É≥„Éû„ÅßÂå∫Âàá„Å£„Å¶ÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ: ",
        headerInjectQuestion: () => "„Åì„ÅÆ„Éâ„Ç≠„É•„É°„É≥„Éà„Å´„Éò„ÉÉ„ÉÄ„Éº„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇËøΩÂä†„Åó„Åæ„Åô„ÅãÔºü",
        headerInjectQuestionRefused: () => "„Éï„Ç°„Ç§„É´„Å´„Éò„ÉÉ„ÉÄ„Éº„ÇíËøΩÂä†„Åó„Å™„ÅÑ„Åì„Å®„Å´„Åó„Åæ„Åó„Åü„ÄÇ",
        headerNotFound: () => "„Åì„ÅÆ„Éâ„Ç≠„É•„É°„É≥„Éà„Å´„Éò„ÉÉ„ÉÄ„Éº„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇ",
        headerOpenerAndCloserFound: () => "„Éò„ÉÉ„ÉÄ„Éº„ÅÆÈñãÂßã„Å®ÁµÇ‰∫Ü„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åó„Åü„ÄÇ„ÉÅ„Çß„ÉÉ„ÇØÂæå„ÄÅÊó•‰ªò„ÇíÊõ¥Êñ∞„Åó„Åæ„Åô„ÄÇ",
        headerOpenerFound: () => "„Éò„ÉÉ„ÉÄ„Éº„ÅÆÈñãÂßã„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åó„Åü„ÄÇ",
        headerWriteFailed: () => "„Éï„Ç°„Ç§„É´„Å´„Éò„ÉÉ„ÉÄ„Éº„ÇíÊõ∏„ÅçËæº„ÇÅ„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ„É≠„Ç∞„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ",
        headerWriteSuccess: () => "„Éò„ÉÉ„ÉÄ„Éº„ÇíÊõ∏„ÅçËæº„Åø„Åæ„Åó„Åü„ÄÇ",
        helloWorldGreetingsCommand: (moduleName: string) => `Hello World from ${moduleName}ÔºÅ`,
        identifiedLanguage: (langName: string) => `Ë≠òÂà•„Åï„Çå„ÅüË®ÄË™û: ${langName}„ÄÇ`,
        inFunction: (functionName: string, className: string = "Êú™ÊåáÂÆö") => `Èñ¢Êï∞: '${functionName}' Ôºà„ÇØ„É©„Çπ: '${className}'ÔºâÂÜÖ`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string) => `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        inputboxError: (promptText: string, err: string) => `${promptText} „ÅÆÂÖ•Âäõ„Éú„ÉÉ„ÇØ„Çπ„Åß„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü: ${err}`,
        jsonContent: (jsonContentString: String) => `„Ç≥„É°„É≥„Éà JSON „Éï„Ç°„Ç§„É´„ÅÆÂÜÖÂÆπ: ${jsonContentString}`,
        languageNotFound: (LanguageId: string, fileExtension: string) => `„Åì„ÅÆ„Éâ„Ç≠„É•„É°„É≥„Éà„ÅÆ„Éï„Ç°„Ç§„É´Ë®ÄË™û„ÇíË≠òÂà•„Åß„Åç„Åæ„Åõ„Çì„ÄÇlanguageID: ${LanguageId}, „Éï„Ç°„Ç§„É´Êã°ÂºµÂ≠ê: ${fileExtension}`,
        lastModifiedLineNotFound: () => "„Éò„ÉÉ„ÉÄ„Éº„Å´„ÄåÊúÄÁµÇÊõ¥Êñ∞Êó•„ÄçË°å„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ",
        lastModifiedUpdated: () => "„ÄåÊúÄÁµÇÊõ¥Êñ∞Êó•„Äç„ÅåÊ≠£Â∏∏„Å´Êõ¥Êñ∞„Åï„Çå„Åæ„Åó„Åü„ÄÇ",
        logoChosen: (logo: string[]) => `Ë°®Á§∫„Åô„Çã„É≠„Ç¥: ${JSON.stringify(logo)}`,
        logoCopied: (logoName: string) => `${logoName} „ÅÆ ASCII „Ç¢„Éº„Éà„Çí„Ç≥„Éî„Éº„Åó„Åæ„Åó„ÅüÔºÅ`,
        logoCopyAscii: () => "ASCII „Çí„Ç≥„Éî„Éº",
        logoDisplayed: (name: string) => `„É≠„Ç¥ '${name}' „ÇíË°®Á§∫„Åó„Åæ„Åó„Åü„ÄÇ`,
        logoMessage: (logoPath: string) => `„Éï„Ç°„Ç§„É´ (${logoPath}) „ÅØÂØæË±°„Çø„Ç§„Éó„Åß„ÅØ„Å™„ÅÑ„Åü„ÇÅÁÑ°Ë¶ñ„Åï„Çå„Åæ„Åó„Åü„ÄÇ`,
        logoName: () => "„É≠„Ç¥Âêç",
        logoNoRootDir: () => "„É≠„Ç¥„ÇíÂèéÈõÜ„Åô„Çã„Åü„ÇÅ„ÅÆ„É´„Éº„Éà„Éá„Ç£„É¨„ÇØ„Éà„É™„ÅåÊèê‰æõ„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì",
        logoNotFound: () => "„É≠„Ç¥„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì",
        logoRootDirUpdateError: (error: string) => `„É≠„Ç¥„Éï„Ç°„Ç§„É´„ÅÆÊõ¥Êñ∞‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü: ${error}`,
        logoView: () => "„É≠„Ç¥„Éì„É•„Éº",
        logoZoomIn: (): string => "„Ç∫„Éº„É†„Ç§„É≥",
        logoZoomOut: (): string => "„Ç∫„Éº„É†„Ç¢„Ç¶„Éà",
        messageNotFound: (key: string) => `„É°„ÉÉ„Çª„Éº„Ç∏ '${key}' „ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇ`,
        messageWritten: () => "„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÊõ∏„ÅçËæº„Åø„Åæ„Åó„Åü",
        missingFileError: () => "Ë®ÄË™ûËæûÊõ∏„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ„Ç≥„É°„É≥„Éà„ÅÆÈÅ©ÂøúÊÄß„ÅØÁÑ°Âäπ„Åß„Åô„ÄÇ",
        missingLanguageComment: () => "Ë®ÄË™û„Ç≥„É°„É≥„Éà„ÅåÊèê‰æõ„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇÂâ≤„ÇäÂΩì„Å¶„Çí„Çπ„Ç≠„ÉÉ„Éó„Åó„Åæ„Åô„ÄÇ",
        morseConverted: (input: string, final: string) => `Â§âÊèõ: ${input} ‚Üí ${final}`,
        morseDecoded: (input: string, final: string) => `Âæ©Âè∑: ${input} ‚Üí ${final}`,
        noActiveEditor: () => "„Ç¢„ÇØ„ÉÜ„Ç£„Éñ„Å™„Éï„Ç°„Ç§„É´„Åå„ÅÇ„Çä„Åæ„Åõ„ÇìÔºÅ",
        noCommentToShow: () => "Ë°®Á§∫„Åô„Çã„Ç≥„É°„É≥„Éà„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ",
        noFilesAvailableForLoading: (): string => "Ë™≠„ÅøËæº„ÇÄ„Åì„Å®„Åå„Åß„Åç„Çã„Éï„Ç°„Ç§„É´„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ",
        noFocusedEditors: () => "„Éï„Ç©„Éº„Ç´„Çπ„Åï„Çå„Å¶„ÅÑ„Çã„Éï„Ç°„Ç§„É´„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ",
        noLogoInstanceProvided: () => "Êèê‰æõ„Åï„Çå„Åü„É≠„Ç¥„É©„É≥„ÉÄ„Éû„Ç§„Ç∂„Éº„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ",
        noProvidedCommentOptions: () => "Êèê‰æõ„Åï„Çå„Åü„Ç≥„É°„É≥„Éà„Ç™„Éó„Ç∑„Éß„É≥„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ",
        notFoundFilePath: (filePath: string, error: string = "Êú™Êèê‰æõ") => `ÊåáÂÆö„Åï„Çå„Åü„Éï„Ç°„Ç§„É´„Éë„Çπ„ÅØÂ≠òÂú®„Åó„Åæ„Åõ„Çì: '${filePath}'„ÄÅ„Ç®„É©„Éº: '${error}'`,
        openFileToApplyHeader: () => "„Éò„ÉÉ„ÉÄ„Éº„ÇíÈÅ©Áî®„Åô„Çã„Éï„Ç°„Ç§„É´„ÇíÈñã„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ",
        operationCanceled: (): string => "Êìç‰Ωú„Åå„Ç≠„É£„É≥„Çª„É´„Åï„Çå„Åæ„Åó„Åü",
        quickPickError: (err: string) => `QuickPick „Åß„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü: ${err}`,
        quickPickNo: () => "„ÅÑ„ÅÑ„Åà",
        quickPickYes: () => "„ÅØ„ÅÑ",
        ramdomLogoGatheringLogoUndefined: () => "„É≠„Ç¥„ÅÆÂÜÖÂÆπ„ÅåÊú™ÂÆöÁæ©„Åß„Åô„ÄÇ",
        randomLogoGatheringFailed: (error: string) => `„É©„É≥„ÉÄ„É†„É≠„Ç¥„ÅÆÂèéÈõÜ„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ„Éá„Éï„Ç©„É´„Éà„É≠„Ç¥„Çí‰ΩøÁî®„Åó„Åæ„Åô„ÄÇ„Ç®„É©„Éº: "${error}"`,
        readTimeout: (timeout: number, filePath: string): string => `${filePath} „ÅÆË™≠„ÅøËæº„Åø„Åå ${timeout}ms Âæå„Å´„Çø„Ç§„É†„Ç¢„Ç¶„Éà„Åó„Åæ„Åó„Åü„ÄÇ`,
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string) => `Hello World! „Éï„Ç°„Ç§„É´„ÅÆÊã°ÂºµÂ≠ê: ${fileExtension}, ÂêçÂâç: ${fileName}, „Éë„Çπ: ${filePath}, Ë®ÄË™û: ${languageId}\n`,
        toMorseGetInput: (): string => "Â§âÊèõ„Åô„Çã„ÉÜ„Ç≠„Çπ„Éà„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ",
        unknown: () => "‰∏çÊòé",
        unknownFileStructure: () => "Ë®ÄË™ûËæûÊõ∏„ÅÆÊßãÈÄ†„Åå‰∏çÊòé„Åß„Åô„ÄÇ„Ç≥„É°„É≥„Éà„ÅÆÈÅ©ÂøúÊÄß„ÅØÁÑ°Âäπ„Åß„Åô„ÄÇ",
        updateAbortedBecauseFileClosedSyncCancelled: () => "„Éï„Ç°„Ç§„É´„ÅåÈñâ„Åò„Çâ„Çå„Å¶„ÅÑ„Çã„Åü„ÇÅ„ÄÅÊõ¥Êñ∞„ÅØ‰∏≠Ê≠¢„Åï„ÇåÂêåÊúü„Åï„Çå„Åæ„Åõ„Çì„ÄÇ",
        updateEditDateMissingBounds: () => "„Éò„ÉÉ„ÉÄ„Éº„ÇíÊõ¥Êñ∞„Åß„Åç„Åæ„Åõ„Çì: ÂÜÖÈÉ®„Éû„Éº„Ç´„Éº„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇ",
        updatingEditionDate: () => "Á∑®ÈõÜÊó•„ÇíÊõ¥Êñ∞„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ",
        watermarkAuthorName: () => "‰ΩúÊàêËÄÖÂêç",
        watermarkChosen: (watermark: string[]) => `Ë°®Á§∫„Åô„Çã„Ç¶„Ç©„Éº„Çø„Éº„Éû„Éº„ÇØ: ${JSON.stringify(watermark)}`,
        watermarkCopied: (name: string) => `${name} „ÅÆ ASCII „Ç¢„Éº„Éà„Çí„Ç≥„Éî„Éº„Åó„Åæ„Åó„ÅüÔºÅ`,
        watermarkCopyAscii: () => "ASCII „Çí„Ç≥„Éî„Éº",
        watermarkJsonFileInvalid: () => "„Ç¶„Ç©„Éº„Çø„Éº„Éû„Éº„ÇØ JSON „Éï„Ç°„Ç§„É´„ÅåÁ©∫„Åæ„Åü„ÅØÁÑ°Âäπ„Åß„Åô",
        watermarkName: () => "„Ç¶„Ç©„Éº„Çø„Éº„Éû„Éº„ÇØÂêç",
        watermarkNotFound: () => "„Ç¶„Ç©„Éº„Çø„Éº„Éû„Éº„ÇØ„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì",
        watermarkPersonDisplayed: (name: string) => `„Ç¶„Ç©„Éº„Çø„Éº„Éû„Éº„ÇØ '${name}' „ÇíË°®Á§∫„Åó„Åæ„Åó„Åü„ÄÇ`,
        watermarkView: () => "„Ç¶„Ç©„Éº„Çø„Éº„Éû„Éº„ÇØ„Éì„É•„Éº",
        watermarkZoomIn: () => "„Ç∫„Éº„É†„Ç§„É≥",
        watermarkZoomOut: () => "„Ç∫„Éº„É†„Ç¢„Ç¶„Éà"
    },
    "ko": {
        alternateFilePathUpdated: (oldFilePath: string, newFilePath: string): string => `ÎåÄÏ≤¥ Í≤ΩÎ°úÍ∞Ä ${oldFilePath} ÏóêÏÑú ${newFilePath}(Ïúº)Î°ú ÏóÖÎç∞Ïù¥Ìä∏ÎêòÏóàÏäµÎãàÎã§.`,
        alternateLogoDirectoryNotFound: (alternateRootDirectory: string, error: string = "Ï†úÍ≥µÎêòÏßÄ ÏïäÏùå") => `ÎåÄÏ≤¥ Î°úÍ≥† Î£®Ìä∏ ÎîîÎ†âÌÑ∞Î¶¨ '${alternateRootDirectory}'Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§, Ïò§Î•ò: '${error}'.`,
        alternateLogoDirectoryNotProvided: () => `ÎåÄÏ≤¥ Î°úÍ≥† ÎîîÎ†âÌÑ∞Î¶¨Í∞Ä Ï†úÍ≥µÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.`,
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]) => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}.`,
        brokenHeader: () => "ÏÜêÏÉÅÎêú Ìó§ÎçîÍ∞Ä Í∞êÏßÄÎêòÏóàÏäµÎãàÎã§. ÏÉà Ìó§ÎçîÎ•º ÏÇΩÏûÖÌï©ÎãàÎã§. Ïù¥Ï†Ñ Í≤ÉÏùÑ ÏÇ≠Ï†úÌïòÏÑ∏Ïöî.",
        cacheAlreadyLoaded: (): string => "Ï∫êÏãúÍ∞Ä Ïù¥ÎØ∏ Î°úÎìúÎêòÏñ¥ Ï†ÄÏû•Îêú Ïù∏Ïä§ÌÑ¥Ïä§Î•º Î∞òÌôòÌï©ÎãàÎã§.",
        chooseSingleLineCommentOption: () => "ÏïÑÎûò ÏòµÏÖòÏóêÏÑú ÏõêÌïòÎäî Ï£ºÏÑù Ï†ëÎëêÏÇ¨Î•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî: ",
        closedDocument: () => "Î¨∏ÏÑúÍ∞Ä Îã´ÌòÄ ÏûàÏñ¥ ÏûëÏóÖÏùÑ Ï§ëÎã®Ìï©ÎãàÎã§.",
        convertedContentCli: (content: string): string => `Î≥ÄÌôòÎêú ÎÇ¥Ïö©: ${content}`,
        convertedContentGui: (): string => "Î≥ÄÌôòÎêú ÎÇ¥Ïö©: ",
        corruptedFileMetaData: () => "ÌïÑÏöîÌïú ÌååÏùº Î©îÌÉÄÎç∞Ïù¥ÌÑ∞Í∞Ä Ïò¨Î∞îÎ•¥Í≤å ÏàòÏßëÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§. Ï§ëÎã®Ìï©ÎãàÎã§.",
        cwdDoesNotExist: (cwd: string) => `Ï†úÍ≥µÎêú ÏûëÏóÖ ÎîîÎ†âÌÑ∞Î¶¨ ${cwd}Í∞Ä Ï°¥Ïû¨ÌïòÏßÄ ÏïäÏäµÎãàÎã§.`,
        cwdUpdated: (oldCwd: string, newCwd: string) => `ÌòÑÏû¨ ÏûëÏóÖ ÎîîÎ†âÌÑ∞Î¶¨Í∞Ä ${oldCwd}ÏóêÏÑú ${newCwd}Î°ú ÏóÖÎç∞Ïù¥Ìä∏ÎêòÏóàÏäµÎãàÎã§.`,
        darlingAge: () => "ÎÇòÏù¥",
        darlingAlias: () => "Î≥ÑÎ™Ö",
        darlingCopied: (name: string) => `${name}Ïùò ASCII ÏïÑÌä∏Í∞Ä Î≥µÏÇ¨ÎêòÏóàÏäµÎãàÎã§!`,
        darlingCopyAscii: () => "ASCII Î≥µÏÇ¨",
        darlingDescription: () => "ÏÑ§Î™Ö",
        darlingHeight: () => "ÌÇ§",
        darlingImage: () => "Ïù¥ÎØ∏ÏßÄ",
        darlingJsonFileInvalid: () => "Darling JSON ÌååÏùºÏù¥ ÎπÑÏñ¥ ÏûàÍ±∞ÎÇò Ïú†Ìö®ÌïòÏßÄ ÏïäÏäµÎãàÎã§",
        darlingMoreInfo: () => "Ï∂îÍ∞Ä Ï†ïÎ≥¥",
        darlingPersonDisplayed: (name: string) => `Ï∫êÎ¶≠ÌÑ∞ '${name}' ÌëúÏãúÎê®.`,
        darlingQuote: () => "Ïù∏Ïö©Íµ¨",
        darlingType: () => "Ïú†Ìòï",
        darlingView: () => "Ï∫êÎ¶≠ÌÑ∞ Î∑∞",
        darlingZoomIn: () => "ÌôïÎåÄ",
        darlingZoomOut: () => "Ï∂ïÏÜå",
        documentLineScanExceeded: (maxScanLength: number) => `ÌååÏùºÏùò Ï≤òÏùå ${maxScanLength}Ï§ÑÏùÑ Ïä§Ï∫îÌñàÏßÄÎßå Ìó§ÎçîÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.`,
        emptyDocument: () => "ÏûëÏóÖÌï† Î¨∏ÏÑú ÎÇ¥Ïö©Ïù¥ ÏóÜÏäµÎãàÎã§.",
        errorDuringFunctionCall: (functionName: string) => `Ìï®Ïàò (${functionName}) Ìò∏Ï∂ú Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§. Î°úÍ∑∏Î•º ÌôïÏù∏ÌïòÏÑ∏Ïöî.`,
        extensionActivated: (moduleName: string) => `üöÄ "${moduleName}" ÌôïÏû•Ïù¥ ÌôúÏÑ±ÌôîÎêòÏóàÏäµÎãàÎã§!`,
        fileExcludedActivationDisabled: () => "ÌôúÏÑ±Ìôî ÎπÑÌôúÏÑ±ÌôîÎê®, ÌååÏùºÏù¥ Ï†úÏô∏ Î™©Î°ùÏóê ÏûàÏäµÎãàÎã§.",
        fileLength: (filePath: string, fileLength: number): string => `ÌååÏùº: '${filePath}', Í∏∏Ïù¥: ${fileLength}Î∞îÏù¥Ìä∏.`,
        fileLoaded: (absolutePath: string) => `ÌååÏùº ${absolutePath} Î°úÎìú ÏôÑÎ£å!`,
        fileLoadError: (filePath: string, error: string = "Ï†úÍ≥µÎêòÏßÄÏïäÏùå"): string => `ÌååÏùº '${filePath}'ÏùÑ(Î•º) Î°úÎìúÌïòÏßÄ Î™ªÌñàÏäµÎãàÎã§. Ïò§Î•ò: ${error}.`,
        fileNotFound: (filePath: string): string => `ÌååÏùºÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§: ${filePath}`,
        fileParseError: (filePath: string, error: string) => `ÌååÏùº ÎÇ¥Ïö© (${filePath})ÏùÑ(Î•º) Ï†ïÏÉÅÏ†ÅÏúºÎ°ú Î°úÎìúÌï† Ïàò ÏóÜÏäµÎãàÎã§. Ïò§Î•ò: ${error}.`,
        filepathPresenceCheck: (filePath: string): string => `ÌååÏùº Í≤ΩÎ°ú Ï°¥Ïû¨ Ïó¨Î∂Ä ÌôïÏù∏ Ï§ë: ${filePath}`,
        filePathProcessing: (filepath: string): string => `ÌååÏùº Í≤ΩÎ°ú Ï≤òÎ¶¨ Ï§ë: '${filepath}'.`,
        filePathUpdated: (oldFilePath: string, newFilePath: string) => `Í≤ΩÎ°úÍ∞Ä ${oldFilePath}ÏóêÏÑú ${newFilePath}Î°ú ÏóÖÎç∞Ïù¥Ìä∏ÎêòÏóàÏäµÎãàÎã§.`,
        fileRefreshed: () => "ÌååÏùº ÎÇ¥Ïö©ÏùÑ ÏÉàÎ°ú Í≥†ÏπòÎäî Ï§ëÏûÖÎãàÎã§.",
        fileSaveFailed: () => "ÌååÏùº Ï†ÄÏû• Ïã§Ìå®, Îã§Ïãú ÏãúÎèÑÌïòÏã≠ÏãúÏò§.",
        fileUnloaded: (filePath: string) => `ÌååÏùº ${filePath}Ïù¥(Í∞Ä) Î©îÎ™®Î¶¨ÏóêÏÑú Ïñ∏Î°úÎìúÎêòÏóàÏäµÎãàÎã§.`,
        foundAlternateFilePathToLoad: (alternateFilePath: string) => `Î°úÎìúÌï† ÎåÄÏ≤¥ ÌååÏùº Í≤ΩÎ°úÍ∞Ä '${alternateFilePath}'Î°ú ÏÑ§Ï†ïÎêòÏóàÏäµÎãàÎã§.`,
        foundAlternateLogoRootDir: (rootDir: string) => `ÌòÑÏû¨ ÎåÄÏ≤¥ Î°úÍ≥† Î£®Ìä∏ ÎîîÎ†âÌÑ∞Î¶¨Îäî '${rootDir}'ÏûÖÎãàÎã§.`,
        foundCurrentWorkingDirectory: (cwd: string) => `ÌòÑÏû¨ ÏûëÏóÖ ÎîîÎ†âÌÑ∞Î¶¨Í∞Ä '${cwd}'Î°ú ÏÑ§Ï†ïÎêòÏóàÏäµÎãàÎã§.`,
        foundFilePath: (filePath: string) => `Ï†úÍ≥µÎêú ÌååÏùº Í≤ΩÎ°úÍ∞Ä Ï°¥Ïû¨Ìï©ÎãàÎã§: '${filePath}'.`,
        foundFilePathToLoad: (filePath: string) => `Î°úÎìúÌï† ÌååÏùº Í≤ΩÎ°úÍ∞Ä '${filePath}'Î°ú ÏÑ§Ï†ïÎêòÏóàÏäµÎãàÎã§.`,
        foundFocusEditor: () => `Ìè¨Ïª§Ïä§Îêú ÏóêÎîîÌÑ∞Í∞Ä ÏûàÏäµÎãàÎã§.`,
        foundLanguageComment: () => `Ïñ∏Ïñ¥ Ï£ºÏÑù ÌååÏùºÏù¥ Ï°¥Ïû¨Ìï©ÎãàÎã§.`,
        foundLogoInstance: () => `Î°úÍ≥† Ïù∏Ïä§ÌÑ¥Ïä§Í∞Ä Ï†úÍ≥µÎêòÏóàÏäµÎãàÎã§.`,
        foundLogoRootDir: (rootDir: string) => `ÌòÑÏû¨ Î°úÍ≥† Î£®Ìä∏ ÎîîÎ†âÌÑ∞Î¶¨Îäî '${rootDir}'ÏûÖÎãàÎã§.`,
        foundNewLine: (newLineType: string) => `ÏÉàÎ°ú Í∞êÏßÄÎêú Ï§ÑÎ∞îÍøà Ïú†ÌòïÏùÄ '${newLineType}'ÏûÖÎãàÎã§.`,
        foundWorkingDirectory: () => `Ï†úÍ≥µÎêú ÏûëÏóÖ ÎîîÎ†âÌÑ∞Î¶¨Í∞Ä Ï°¥Ïû¨Ìï©ÎãàÎã§.`,
        fromMorseGetInput: (): string => "Î≥ÄÌôòÌï† ÏõêÎ≥∏ ÌÖçÏä§Ìä∏Î•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî",
        getHeaderDescription: () => "ÏÑ§Î™ÖÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî: ",
        getHeaderPurpose: () => "ÌååÏùºÏùò Î™©Ï†ÅÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî: ",
        getHeaderTags: () => "Ïù¥ ÌååÏùºÏùò ÌÉúÍ∑∏Î•º ÏâºÌëúÎ°ú Íµ¨Î∂ÑÌïòÏó¨ ÏûÖÎ†•ÌïòÏÑ∏Ïöî: ",
        headerInjectQuestion: () => "Ïù¥ Î¨∏ÏÑúÏóêÏÑú Ìó§ÎçîÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§. Ï∂îÍ∞ÄÌïòÏãúÍ≤†ÏäµÎãàÍπå?",
        headerInjectQuestionRefused: () => "ÌååÏùºÏóê Ìó§ÎçîÎ•º Ï∂îÍ∞ÄÌïòÏßÄ ÏïäÍ∏∞Î°ú Í≤∞Ï†ïÌñàÏäµÎãàÎã§.",
        headerNotFound: () => "Ïù¥ Î¨∏ÏÑúÏóêÏÑú Ìó§ÎçîÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.",
        headerOpenerAndCloserFound: () => "Ìó§Îçî ÏãúÏûë Î∞è Ï¢ÖÎ£å Î∞úÍ≤¨, Í≤ÄÏÇ¨ ÌõÑ ÎÇ†ÏßúÎ•º ÏóÖÎç∞Ïù¥Ìä∏Ìï©ÎãàÎã§.",
        headerOpenerFound: () => "Ìó§Îçî ÏãúÏûë Î∞úÍ≤¨.",
        headerWriteFailed: () => "ÌååÏùºÏóê Ìó§ÎçîÎ•º Ïì∏ Ïàò ÏóÜÏäµÎãàÎã§. Î°úÍ∑∏Î•º ÌôïÏù∏ÌïòÏÑ∏Ïöî.",
        headerWriteSuccess: () => "Ìó§ÎçîÍ∞Ä ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÏûëÏÑ±ÎêòÏóàÏäµÎãàÎã§.",
        helloWorldGreetingsCommand: (moduleName: string) => `Hello World from ${moduleName}!`,
        identifiedLanguage: (langName: string) => `ÏãùÎ≥ÑÎêú Ïñ∏Ïñ¥: ${langName}.`,
        inFunction: (functionName: string, className: string = "ÏßÄÏ†ïÎêòÏßÄ ÏïäÏùå") => `Ìï®Ïàò: '${functionName}' (ÌÅ¥ÎûòÏä§: '${className}') ÎÇ¥Î∂Ä`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string) => `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        inputboxError: (promptText: string, err: string) => `${promptText} ÏûÖÎ†• ÏÉÅÏûêÏóêÏÑú Ïò§Î•ò Î∞úÏÉù: ${err}`,
        jsonContent: (jsonContentString: String) => `Ï£ºÏÑù JSON ÌååÏùº ÎÇ¥Ïö©: ${jsonContentString}`,
        languageNotFound: (LanguageId: string, fileExtension: string) => `Ïù¥ Î¨∏ÏÑúÏùò ÌååÏùº Ïñ∏Ïñ¥Î•º ÏãùÎ≥ÑÌï† Ïàò ÏóÜÏäµÎãàÎã§. languageID: ${LanguageId}, ÌååÏùº ÌôïÏû•Ïûê: ${fileExtension}`,
        lastModifiedLineNotFound: () => "Ìó§ÎçîÏóê 'ÎßàÏßÄÎßâ ÏàòÏ†ïÏùº' ÎùºÏù∏Ïù¥ ÏóÜÏäµÎãàÎã§.",
        lastModifiedUpdated: () => "'ÎßàÏßÄÎßâ ÏàòÏ†ïÏùº'Ïù¥ ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÏóÖÎç∞Ïù¥Ìä∏ÎêòÏóàÏäµÎãàÎã§.",
        logoChosen: (logo: string[]) => `ÌëúÏãúÌï† Î°úÍ≥†: ${JSON.stringify(logo)}`,
        logoCopied: (logoName: string) => `${logoName}Ïùò ASCII ÏïÑÌä∏Í∞Ä Î≥µÏÇ¨ÎêòÏóàÏäµÎãàÎã§!`,
        logoCopyAscii: () => "ASCII Î≥µÏÇ¨",
        logoDisplayed: (name: string) => `Î°úÍ≥† '${name}' ÌëúÏãúÎê®.`,
        logoMessage: (logoPath: string) => `ÌååÏùº (${logoPath})ÏùÄ(Îäî) ÏõêÌïòÎäî Ïú†ÌòïÏù¥ ÏïÑÎãàÎØÄÎ°ú Î¨¥ÏãúÎê©ÎãàÎã§.`,
        logoName: () => "Î°úÍ≥† Ïù¥Î¶Ñ",
        logoNoRootDir: () => "Î°úÍ≥†Î•º ÏàòÏßëÌï† Î£®Ìä∏ ÎîîÎ†âÌÑ∞Î¶¨Í∞Ä Ï†úÍ≥µÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§",
        logoNotFound: () => "Î°úÍ≥†Î•º Ï∞æÏùÑ Ïàò ÏóÜÏùå",
        logoRootDirUpdateError: (error: string) => `Î°úÍ≥† ÌååÏùº ÏóÖÎç∞Ïù¥Ìä∏ Ï§ë Ïò§Î•ò Î∞úÏÉù: ${error}`,
        logoView: () => "Î°úÍ≥† Î∑∞",
        logoZoomIn: (): string => "ÌôïÎåÄ",
        logoZoomOut: (): string => "Ï∂ïÏÜå",
        messageNotFound: (key: string) => `Î©îÏãúÏßÄ '${key}'Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.`,
        messageWritten: () => "Î©îÏãúÏßÄ ÏûëÏÑ± ÏôÑÎ£å",
        missingFileError: () => "Ïñ∏Ïñ¥ ÏÇ¨Ï†ÑÏù¥ ÏóÜÏäµÎãàÎã§. Ï£ºÏÑù Ï†ÅÏùë Í∏∞Îä•Ïù¥ ÎπÑÌôúÏÑ±ÌôîÎê©ÎãàÎã§.",
        missingLanguageComment: () => "Ïñ∏Ïñ¥ Ï£ºÏÑùÏù¥ Ï†úÍ≥µÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§. Ìï†ÎãπÏùÑ Í±¥ÎÑàÎúÅÎãàÎã§.",
        morseConverted: (input: string, final: string) => `Î≥ÄÌôòÎê®: ${input} ‚Üí ${final}`,
        morseDecoded: (input: string, final: string) => `Î≥µÌò∏ÌôîÎê®: ${input} ‚Üí ${final}`,
        noActiveEditor: () => "ÌôúÏÑ± ÌååÏùºÏù¥ ÏóÜÏäµÎãàÎã§!",
        noCommentToShow: () => "ÌëúÏãúÌï† Ï£ºÏÑùÏù¥ ÏóÜÏäµÎãàÎã§.",
        noFilesAvailableForLoading: (): string => "Î°úÎìúÌï† Ïàò ÏûàÎäî ÌååÏùºÏù¥ ÏóÜÏäµÎãàÎã§.",
        noFocusedEditors: () => "Ìè¨Ïª§Ïä§Îêú ÌååÏùºÏù¥ ÏóÜÏäµÎãàÎã§.",
        noLogoInstanceProvided: () => "Ï†úÍ≥µÎêú Î°úÍ≥† ÎûúÎç§ Ïù∏Ïä§ÌÑ¥Ïä§Í∞Ä ÏóÜÏäµÎãàÎã§.",
        noProvidedCommentOptions: () => "Ï†úÍ≥µÎêú Ï£ºÏÑù ÏòµÏÖòÏù¥ ÏóÜÏäµÎãàÎã§.",
        notFoundFilePath: (filePath: string, error: string = "Ï†úÍ≥µÎêòÏßÄ ÏïäÏùå") => `Ï†úÍ≥µÎêú ÌååÏùº Í≤ΩÎ°úÍ∞Ä Ï°¥Ïû¨ÌïòÏßÄ ÏïäÏäµÎãàÎã§: '${filePath}', Ïò§Î•ò: '${error}'`,
        openFileToApplyHeader: () => "Ìó§ÎçîÎ•º Ï†ÅÏö©Ìï† ÌååÏùºÏùÑ Ïó¥Ïñ¥Ï£ºÏÑ∏Ïöî.",
        operationCanceled: (): string => "ÏûëÏóÖÏù¥ Ï∑®ÏÜåÎêòÏóàÏäµÎãàÎã§",
        quickPickError: (err: string) => `QuickPickÏóêÏÑú Ïò§Î•ò Î∞úÏÉù: ${err}`,
        quickPickNo: () => "ÏïÑÎãàÏò§",
        quickPickYes: () => "Ïòà",
        ramdomLogoGatheringLogoUndefined: () => "Î°úÍ≥† ÎÇ¥Ïö©Ïù¥ Ï†ïÏùòÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.",
        randomLogoGatheringFailed: (error: string) => `ÎûúÎç§ Î°úÍ≥† ÏàòÏßë Ïã§Ìå®, Í∏∞Î≥∏ Î°úÍ≥† ÏÇ¨Ïö©, Ïò§Î•ò: "${error}"`,
        readTimeout: (timeout: number, filePath: string): string => `${filePath}Ïùò ÏùΩÍ∏∞ ÏãúÍ∞ÑÏù¥ ${timeout}ms ÌõÑ Ï¥àÍ≥ºÎêòÏóàÏäµÎãàÎã§.`,
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string) => `Hello World! ÌååÏùº ÌôïÏû•Ïûê: ${fileExtension}, Ïù¥Î¶Ñ: ${fileName}, Í≤ΩÎ°ú: ${filePath}, Ïñ∏Ïñ¥: ${languageId}\n`,
        toMorseGetInput: (): string => "Î≥ÄÌôòÌï† ÌÖçÏä§Ìä∏Î•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî",
        unknown: () => "Ïïå Ïàò ÏóÜÏùå",
        unknownFileStructure: () => "Ïñ∏Ïñ¥ ÏÇ¨Ï†Ñ Íµ¨Ï°∞Î•º Ïïå Ïàò ÏóÜÏäµÎãàÎã§. Ï£ºÏÑù Ï†ÅÏùë Í∏∞Îä•Ïù¥ ÎπÑÌôúÏÑ±ÌôîÎê©ÎãàÎã§.",
        updateAbortedBecauseFileClosedSyncCancelled: () => "ÌååÏùºÏù¥ Îã´ÌòÄ ÏûàÏñ¥ ÏóÖÎç∞Ïù¥Ìä∏Í∞Ä Ï§ëÎã®ÎêòÏóàÏúºÎ©∞ ÎèôÍ∏∞ÌôîÎêòÏßÄ ÏïäÏäµÎãàÎã§.",
        updateEditDateMissingBounds: () => "Ìó§ÎçîÎ•º ÏóÖÎç∞Ïù¥Ìä∏Ìï† Ïàò ÏóÜÏäµÎãàÎã§: ÎÇ¥Î∂Ä ÎßàÏª§Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.",
        updatingEditionDate: () => "ÏàòÏ†ïÏùºÏùÑ ÏóÖÎç∞Ïù¥Ìä∏ Ï§ëÏûÖÎãàÎã§.",
        watermarkAuthorName: () => "ÏûëÏÑ±Ïûê Ïù¥Î¶Ñ",
        watermarkChosen: (watermark: string[]) => `ÌëúÏãúÌï† ÏõåÌÑ∞ÎßàÌÅ¨: ${JSON.stringify(watermark)}`,
        watermarkCopied: (name: string) => `${name}Ïùò ASCII ÏïÑÌä∏Í∞Ä Î≥µÏÇ¨ÎêòÏóàÏäµÎãàÎã§!`,
        watermarkCopyAscii: () => "ASCII Î≥µÏÇ¨",
        watermarkJsonFileInvalid: () => "ÏõåÌÑ∞ÎßàÌÅ¨ JSON ÌååÏùºÏù¥ ÎπÑÏñ¥ ÏûàÍ±∞ÎÇò Ïú†Ìö®ÌïòÏßÄ ÏïäÏäµÎãàÎã§",
        watermarkName: () => "ÏõåÌÑ∞ÎßàÌÅ¨ Ïù¥Î¶Ñ",
        watermarkNotFound: () => "ÏõåÌÑ∞ÎßàÌÅ¨Î•º Ï∞æÏùÑ Ïàò ÏóÜÏùå",
        watermarkPersonDisplayed: (name: string) => `ÏõåÌÑ∞ÎßàÌÅ¨ '${name}' ÌëúÏãúÎê®.`,
        watermarkView: () => "ÏõåÌÑ∞ÎßàÌÅ¨ Î∑∞",
        watermarkZoomIn: () => "ÌôïÎåÄ",
        watermarkZoomOut: () => "Ï∂ïÏÜå"
    },
    "ru": {
        alternateFilePathUpdated: (oldFilePath: string, newFilePath: string): string => `–ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π –ø—É—Ç—å –±—ã–ª –æ–±–Ω–æ–≤–ª—ë–Ω —Å ${oldFilePath} –Ω–∞ ${newFilePath}.`,
        alternateLogoDirectoryNotFound: (alternateRootDirectory: string, error: string = "–ù–µ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω–æ") => `–ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π –∫–æ—Ä–Ω–µ–≤–æ–π –∫–∞—Ç–∞–ª–æ–≥ –ª–æ–≥–æ—Ç–∏–ø–æ–≤ '${alternateRootDirectory}' –Ω–µ –Ω–∞–π–¥–µ–Ω, –æ—à–∏–±–∫–∞: '${error}'.`,
        alternateLogoDirectoryNotProvided: () => `–ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π –∫–∞—Ç–∞–ª–æ–≥ –ª–æ–≥–æ—Ç–∏–ø–æ–≤ –Ω–µ —É–∫–∞–∑–∞–Ω.`,
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]) => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}.`,
        brokenHeader: () => "–û–±–Ω–∞—Ä—É–∂–µ–Ω –ø–æ–≤—Ä–µ–∂–¥–µ–Ω–Ω—ã–π –∑–∞–≥–æ–ª–æ–≤–æ–∫, –≤—Å—Ç–∞–≤–ª—è–µ—Ç—Å—è –Ω–æ–≤—ã–π, —É–¥–∞–ª–∏—Ç–µ –ø—Ä–µ–¥—ã–¥—É—â–∏–π.",
        cacheAlreadyLoaded: (): string => "–ö—ç—à —É–∂–µ –∑–∞–≥—Ä—É–∂–µ–Ω, –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç—Å—è —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä.",
        chooseSingleLineCommentOption: () => "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –ø—Ä–µ–¥–ø–æ—á–∏—Ç–∞–µ–º—ã–π –ø—Ä–µ—Ñ–∏–∫—Å –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏—è –∏–∑ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–Ω—ã—Ö –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤: ",
        closedDocument: () => "–î–æ–∫—É–º–µ–Ω—Ç –∑–∞–∫—Ä—ã—Ç, –æ–ø–µ—Ä–∞—Ü–∏—è –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞.",
        convertedContentCli: (content: string): string => `–ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–Ω—ã–π –∫–æ–Ω—Ç–µ–Ω—Ç: ${content}`,
        convertedContentGui: (): string => "–ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–Ω—ã–π –∫–æ–Ω—Ç–µ–Ω—Ç: ",
        corruptedFileMetaData: () => "–ù–µ —É–¥–∞–ª–æ—Å—å –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ —Å–æ–±—Ä–∞—Ç—å –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ —Ñ–∞–π–ª–∞, –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏–µ.",
        cwdDoesNotExist: (cwd: string) => `–£–∫–∞–∑–∞–Ω–Ω—ã–π —Ä–∞–±–æ—á–∏–π –∫–∞—Ç–∞–ª–æ–≥ ${cwd} –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç.`,
        cwdUpdated: (oldCwd: string, newCwd: string) => `–¢–µ–∫—É—â–∏–π —Ä–∞–±–æ—á–∏–π –∫–∞—Ç–∞–ª–æ–≥ –æ–±–Ω–æ–≤–ª–µ–Ω —Å ${oldCwd} –Ω–∞ ${newCwd}.`,
        darlingAge: () => "–í–æ–∑—Ä–∞—Å—Ç",
        darlingAlias: () => "–ü—Å–µ–≤–¥–æ–Ω–∏–º",
        darlingCopied: (name: string) => `ASCII-–∞—Ä—Ç –¥–ª—è ${name} —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω!`,
        darlingCopyAscii: () => "–°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å ASCII",
        darlingDescription: () => "–û–ø–∏—Å–∞–Ω–∏–µ",
        darlingHeight: () => "–†–æ—Å—Ç",
        darlingImage: () => "–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ",
        darlingJsonFileInvalid: () => "–§–∞–π–ª JSON –ø–µ—Ä—Å–æ–Ω–∞–∂–∞ –ø—É—Å—Ç –∏–ª–∏ –Ω–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª–µ–Ω",
        darlingMoreInfo: () => "–î–æ–ø. –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è",
        darlingPersonDisplayed: (name: string) => `–ü–µ—Ä—Å–æ–Ω–∞–∂ '${name}' –æ—Ç–æ–±—Ä–∞–∂–µ–Ω.`,
        darlingQuote: () => "–¶–∏—Ç–∞—Ç–∞",
        darlingType: () => "–¢–∏–ø",
        darlingView: () => "–ø—Ä–æ—Å–º–æ—Ç—Ä –ø–µ—Ä—Å–æ–Ω–∞–∂–∞",
        darlingZoomIn: () => "–£–≤–µ–ª–∏—á–∏—Ç—å",
        darlingZoomOut: () => "–£–º–µ–Ω—å—à–∏—Ç—å",
        documentLineScanExceeded: (maxScanLength: number) => `–ü—Ä–æ—Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–æ –ø–µ—Ä–≤—ã–µ ${maxScanLength} —Å—Ç—Ä–æ–∫–∏ —Ñ–∞–π–ª–∞, –∑–∞–≥–æ–ª–æ–≤–æ–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω.`,
        emptyDocument: () => "–ù–µ—Ç —Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ –¥–æ–∫—É–º–µ–Ω—Ç–∞ –¥–ª—è —Ä–∞–±–æ—Ç—ã.",
        errorDuringFunctionCall: (functionName: string) => `–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–∑–æ–≤–µ —Ñ—É–Ω–∫—Ü–∏–∏ (${functionName}), –ø—Ä–æ–≤–µ—Ä—å—Ç–µ –ª–æ–≥–∏.`,
        extensionActivated: (moduleName: string) => `üöÄ –†–∞—Å—à–∏—Ä–µ–Ω–∏–µ "${moduleName}" —Ç–µ–ø–µ—Ä—å –∞–∫—Ç–∏–≤–Ω–æ!`,
        fileExcludedActivationDisabled: () => "–ê–∫—Ç–∏–≤–∞—Ü–∏—è –æ—Ç–∫–ª—é—á–µ–Ω–∞, —Ñ–∞–π–ª –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ —Å–ø–∏—Å–∫–µ –∏—Å–∫–ª—é—á–µ–Ω–∏–π.",
        fileLength: (filePath: string, fileLength: number): string => `–§–∞–π–ª: '${filePath}', –¥–ª–∏–Ω–∞: ${fileLength} –±–∞–π—Ç.`,
        fileLoaded: (absolutePath: string) => `–§–∞–π–ª ${absolutePath} –∑–∞–≥—Ä—É–∂–µ–Ω!`,
        fileLoadError: (filePath: string, error: string = "–ù–µ–ü—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω–æ"): string => `–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Ñ–∞–π–ª: '${filePath}'. –û—à–∏–±–∫–∞: ${error}.`,
        fileNotFound: (filePath: string): string => `–§–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω: ${filePath}`,
        fileParseError: (filePath: string, error: string) => `–°–æ–¥–µ—Ä–∂–∏–º–æ–µ —Ñ–∞–π–ª–∞ (${filePath}) –Ω–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å. –û—à–∏–±–∫–∞: ${error}.`,
        filepathPresenceCheck: (filePath: string): string => `–ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞–ª–∏—á–∏—è –ø—É—Ç–∏ –∫ —Ñ–∞–π–ª—É: ${filePath}`,
        filePathProcessing: (filepath: string): string => `–û–±—Ä–∞–±–æ—Ç–∫–∞ –ø—É—Ç–∏ –∫ —Ñ–∞–π–ª—É: '${filepath}'.`,
        filePathUpdated: (oldFilePath: string, newFilePath: string) => `–ü—É—Ç—å –æ–±–Ω–æ–≤–ª–µ–Ω —Å ${oldFilePath} –Ω–∞ ${newFilePath}.`,
        fileRefreshed: () => "–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ —Ñ–∞–π–ª–∞.",
        fileSaveFailed: () => "–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ñ–∞–π–ª, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.",
        fileUnloaded: (filePath: string) => `–§–∞–π–ª ${filePath} –≤—ã–≥—Ä—É–∂–µ–Ω –∏–∑ –ø–∞–º—è—Ç–∏.`,
        foundAlternateFilePathToLoad: (alternateFilePath: string) => `–ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π –ø—É—Ç—å –∫ —Ñ–∞–π–ª—É –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏: '${alternateFilePath}'.`,
        foundAlternateLogoRootDir: (rootDir: string) => `–¢–µ–∫—É—â–∏–π –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π –∫–æ—Ä–Ω–µ–≤–æ–π –∫–∞—Ç–∞–ª–æ–≥ –ª–æ–≥–æ—Ç–∏–ø–æ–≤: '${rootDir}'.`,
        foundCurrentWorkingDirectory: (cwd: string) => `–¢–µ–∫—É—â–∏–π —Ä–∞–±–æ—á–∏–π –∫–∞—Ç–∞–ª–æ–≥: '${cwd}'.`,
        foundFilePath: (filePath: string) => `–£–∫–∞–∑–∞–Ω–Ω—ã–π –ø—É—Ç—å –∫ —Ñ–∞–π–ª—É —Å—É—â–µ—Å—Ç–≤—É–µ—Ç: '${filePath}'.`,
        foundFilePathToLoad: (filePath: string) => `–ü—É—Ç—å –∫ —Ñ–∞–π–ª—É –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏: '${filePath}'.`,
        foundFocusEditor: () => `–ê–∫—Ç–∏–≤–µ–Ω —Ä–µ–¥–∞–∫—Ç–æ—Ä.`,
        foundLanguageComment: () => `–§–∞–π–ª —è–∑—ã–∫–æ–≤—ã—Ö –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–≤ –Ω–∞–π–¥–µ–Ω.`,
        foundLogoInstance: () => `–≠–∫–∑–µ–º–ø–ª—è—Ä –ª–æ–≥–æ—Ç–∏–ø–∞ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω.`,
        foundLogoRootDir: (rootDir: string) => `–¢–µ–∫—É—â–∏–π –∫–æ—Ä–Ω–µ–≤–æ–π –∫–∞—Ç–∞–ª–æ–≥ –ª–æ–≥–æ—Ç–∏–ø–æ–≤: '${rootDir}'.`,
        foundNewLine: (newLineType: string) => `–ù–æ–≤—ã–π —Ç–∏–ø —Å—Ç—Ä–æ–∫–∏: '${newLineType}'.`,
        foundWorkingDirectory: () => `–£–∫–∞–∑–∞–Ω–Ω—ã–π —Ä–∞–±–æ—á–∏–π –∫–∞—Ç–∞–ª–æ–≥ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç.`,
        fromMorseGetInput: (): string => "–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –¥–ª—è –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è –∏–∑",
        getHeaderDescription: () => "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø—Ä–µ–¥–æ—Å—Ç–∞–≤—å—Ç–µ –æ–ø–∏—Å–∞–Ω–∏–µ: ",
        getHeaderPurpose: () => "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ –Ω–∞–∑–Ω–∞—á–µ–Ω–∏–µ —Ñ–∞–π–ª–∞: ",
        getHeaderTags: () => "–í–≤–µ–¥–∏—Ç–µ —Ç–µ–≥–∏ –¥–ª—è —ç—Ç–æ–≥–æ —Ñ–∞–π–ª–∞ —á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é: ",
        headerInjectQuestion: () => "–ó–∞–≥–æ–ª–æ–≤–æ–∫ –≤ —ç—Ç–æ–º –¥–æ–∫—É–º–µ–Ω—Ç–µ –Ω–µ –Ω–∞–π–¥–µ–Ω. –•–æ—Ç–∏—Ç–µ –¥–æ–±–∞–≤–∏—Ç—å –µ–≥–æ?",
        headerInjectQuestionRefused: () => "–í—ã —Ä–µ—à–∏–ª–∏ –Ω–µ –¥–æ–±–∞–≤–ª—è—Ç—å –∑–∞–≥–æ–ª–æ–≤–æ–∫ –≤ —Ñ–∞–π–ª.",
        headerNotFound: () => "–ó–∞–≥–æ–ª–æ–≤–æ–∫ –≤ —ç—Ç–æ–º –¥–æ–∫—É–º–µ–Ω—Ç–µ –Ω–µ –Ω–∞–π–¥–µ–Ω.",
        headerOpenerAndCloserFound: () => "–ù–∞—á–∞–ª–æ –∏ –∫–æ–Ω–µ—Ü –∑–∞–≥–æ–ª–æ–≤–∫–∞ –Ω–∞–π–¥–µ–Ω—ã, –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –¥–∞—Ç—ã –ø–æ—Å–ª–µ –ø—Ä–æ–≤–µ—Ä–∫–∏.",
        headerOpenerFound: () => "–ù–∞—á–∞–ª–æ –∑–∞–≥–æ–ª–æ–≤–∫–∞ –Ω–∞–π–¥–µ–Ω–æ.",
        headerWriteFailed: () => "–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–ø–∏—Å–∞—Ç—å –∑–∞–≥–æ–ª–æ–≤–æ–∫ –≤ —Ñ–∞–π–ª, –ø—Ä–æ–≤–µ—Ä—å—Ç–µ –ª–æ–≥–∏.",
        headerWriteSuccess: () => "–ó–∞–≥–æ–ª–æ–≤–æ–∫ —É—Å–ø–µ—à–Ω–æ –∑–∞–ø–∏—Å–∞–Ω.",
        helloWorldGreetingsCommand: (moduleName: string) => `Hello World –∏–∑ ${moduleName}!`,
        identifiedLanguage: (langName: string) => `–û–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã–π —è–∑—ã–∫: ${langName}.`,
        inFunction: (functionName: string, className: string = "–ù–µ —É–∫–∞–∑–∞–Ω–æ") => `–í —Ñ—É–Ω–∫—Ü–∏–∏: '${functionName}' –∏–∑ –∫–ª–∞—Å—Å–∞: '${className}'`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string) => `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        inputboxError: (promptText: string, err: string) => `–û—à–∏–±–∫–∞ –≤ –ø–æ–ª–µ –≤–≤–æ–¥–∞ –¥–ª—è ${promptText}: ${err}`,
        jsonContent: (jsonContentString: String) => `–°–æ–¥–µ—Ä–∂–∏–º–æ–µ JSON-—Ñ–∞–π–ª–∞ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–≤: ${jsonContentString}`,
        languageNotFound: (LanguageId: string, fileExtension: string) => `–ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å —è–∑—ã–∫ —Ñ–∞–π–ª–∞ —ç—Ç–æ–≥–æ –¥–æ–∫—É–º–µ–Ω—Ç–∞, languageID: ${LanguageId}, —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ —Ñ–∞–π–ª–∞: ${fileExtension}`,
        lastModifiedLineNotFound: () => "–í –∑–∞–≥–æ–ª–æ–≤–∫–µ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç —Å—Ç—Ä–æ–∫–∞ '–ü–æ—Å–ª–µ–¥–Ω–µ–µ –∏–∑–º–µ–Ω–µ–Ω–∏–µ' –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è.",
        lastModifiedUpdated: () => "–î–∞—Ç–∞ '–ü–æ—Å–ª–µ–¥–Ω–µ–µ –∏–∑–º–µ–Ω–µ–Ω–∏–µ' —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∞.",
        logoChosen: (logo: string[]) => `–í—ã–±—Ä–∞–Ω–Ω—ã–π –ª–æ–≥–æ—Ç–∏–ø: ${JSON.stringify(logo)}`,
        logoCopied: (logoName: string) => `ASCII-–∞—Ä—Ç –¥–ª—è ${logoName} —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω!`,
        logoCopyAscii: () => "–°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å ASCII",
        logoDisplayed: (name: string) => `–õ–æ–≥–æ—Ç–∏–ø '${name}' –æ—Ç–æ–±—Ä–∞–∂–µ–Ω.`,
        logoMessage: (logoPath: string) => `–§–∞–π–ª (${logoPath}) –ø—Ä–æ–∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω, —Ç–∞–∫ –∫–∞–∫ —ç—Ç–æ –Ω–µ –Ω—É–∂–Ω—ã–π —Ç–∏–ø.`,
        logoName: () => "–ù–∞–∑–≤–∞–Ω–∏–µ –ª–æ–≥–æ—Ç–∏–ø–∞",
        logoNoRootDir: () => "–ù–µ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω –∫–æ—Ä–Ω–µ–≤–æ–π –∫–∞—Ç–∞–ª–æ–≥ –¥–ª—è —Å–±–æ—Ä–∞ –ª–æ–≥–æ—Ç–∏–ø–æ–≤",
        logoNotFound: () => "–õ–æ–≥–æ—Ç–∏–ø –Ω–µ –Ω–∞–π–¥–µ–Ω",
        logoRootDirUpdateError: (error: string) => `–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —Ñ–∞–π–ª–æ–≤ –ª–æ–≥–æ—Ç–∏–ø–∞: ${error}`,
        logoView: () => "–ø—Ä–æ—Å–º–æ—Ç—Ä –ª–æ–≥–æ—Ç–∏–ø–∞",
        logoZoomIn: (): string => "–£–≤–µ–ª–∏—á–∏—Ç—å",
        logoZoomOut: (): string => "–£–º–µ–Ω—å—à–∏—Ç—å",
        messageNotFound: (key: string) => `–°–æ–æ–±—â–µ–Ω–∏–µ '${key}' –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.`,
        messageWritten: () => "–°–æ–æ–±—â–µ–Ω–∏–µ –∑–∞–ø–∏—Å–∞–Ω–æ",
        missingFileError: () => "–°–ª–æ–≤–∞—Ä—å —è–∑—ã–∫–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç, –∞–¥–∞–ø—Ç–∞—Ü–∏—è –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–≤ –æ—Ç–∫–ª—é—á–µ–Ω–∞.",
        missingLanguageComment: () => "–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –¥–ª—è —è–∑—ã–∫–∞ –Ω–µ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω, –ø—Ä–æ–ø—É—Å–∫ –ø—Ä–∏—Å–≤–æ–µ–Ω–∏—è.",
        morseConverted: (input: string, final: string) => `–ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–æ: ${input} ‚Üí ${final}`,
        morseDecoded: (input: string, final: string) => `–î–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–æ: ${input} ‚Üí ${final}`,
        noActiveEditor: () => "–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–≥–æ —Ñ–∞–π–ª–∞!",
        noCommentToShow: () => "–ù–µ—Ç –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–≤ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è.",
        noFilesAvailableForLoading: (): string => "–ù–µ—Ç —Ñ–∞–π–ª–æ–≤, –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏.",
        noFocusedEditors: () => "–ù–µ—Ç —Ñ–∞–π–ª–æ–≤ –≤ —Ñ–æ–∫—É—Å–µ.",
        noLogoInstanceProvided: () => "–ù–µ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω —ç–∫–∑–µ–º–ø–ª—è—Ä —Ä–∞–Ω–¥–æ–º–∏–∑–∞—Ç–æ—Ä–∞ –ª–æ–≥–æ—Ç–∏–ø–∞.",
        noProvidedCommentOptions: () => "–ù–µ—Ç –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω–Ω—ã—Ö –æ–ø—Ü–∏–π –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–≤.",
        notFoundFilePath: (filePath: string, error: string = "–ù–µ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω–æ") => `–£–∫–∞–∑–∞–Ω–Ω—ã–π –ø—É—Ç—å –∫ —Ñ–∞–π–ª—É –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç: '${filePath}', –æ—à–∏–±–∫–∞: '${error}'`,
        openFileToApplyHeader: () => "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–∫—Ä–æ–π—Ç–µ —Ñ–∞–π–ª, —á—Ç–æ–±—ã –ø—Ä–∏–º–µ–Ω–∏—Ç—å –∑–∞–≥–æ–ª–æ–≤–æ–∫.",
        operationCanceled: (): string => "–û–ø–µ—Ä–∞—Ü–∏—è –æ—Ç–º–µ–Ω–µ–Ω–∞",
        quickPickError: (err: string) => `–û—à–∏–±–∫–∞ –≤ quickPick: ${err}`,
        quickPickNo: () => "–ù–µ—Ç",
        quickPickYes: () => "–î–∞",
        ramdomLogoGatheringLogoUndefined: () => "–°–æ–¥–µ—Ä–∂–∏–º–æ–µ –ª–æ–≥–æ—Ç–∏–ø–∞ –Ω–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–æ.",
        randomLogoGatheringFailed: (error: string) => `–°–±–æ—Ä —Å–ª—É—á–∞–π–Ω–æ–≥–æ –ª–æ–≥–æ—Ç–∏–ø–∞ –Ω–µ —É–¥–∞–ª—Å—è, –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –ª–æ–≥–æ—Ç–∏–ø –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é, –æ—à–∏–±–∫–∞: "${error}"`,
        readTimeout: (timeout: number, filePath: string): string => `–í—Ä–µ–º—è –æ–∂–∏–¥–∞–Ω–∏—è —á—Ç–µ–Ω–∏—è –∏—Å—Ç–µ–∫–ª–æ —á–µ—Ä–µ–∑ ${timeout} –º—Å –¥–ª—è ${filePath}`,
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string) => `Hello World! –†–∞—Å—à–∏—Ä–µ–Ω–∏–µ —Ñ–∞–π–ª–∞: ${fileExtension}, –∏–º—è: ${fileName}, –ø—É—Ç—å: ${filePath}, —è–∑—ã–∫: ${languageId}\n`,
        toMorseGetInput: (): string => "–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –¥–ª—è –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è",
        unknown: () => "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ",
        unknownFileStructure: () => "–°—Ç—Ä—É–∫—Ç—É—Ä–∞ —Å–ª–æ–≤–∞—Ä—è —è–∑—ã–∫–∞ –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–∞, –∞–¥–∞–ø—Ç–∞—Ü–∏—è –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–≤ –æ—Ç–∫–ª—é—á–µ–Ω–∞.",
        updateAbortedBecauseFileClosedSyncCancelled: () => "–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—Ä–µ—Ä–≤–∞–Ω–æ, —Ç–∞–∫ –∫–∞–∫ —Ñ–∞–π–ª –∑–∞–∫—Ä—ã—Ç –∏ –Ω–µ –±—É–¥–µ—Ç —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞–Ω.",
        updateEditDateMissingBounds: () => "–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±–Ω–æ–≤–∏—Ç—å –∑–∞–≥–æ–ª–æ–≤–æ–∫: –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ –º–∞—Ä–∫–µ—Ä—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã.",
        updatingEditionDate: () => "–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –¥–∞—Ç—ã —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è.",
        watermarkAuthorName: () => "–ò–º—è –∞–≤—Ç–æ—Ä–∞",
        watermarkChosen: (watermark: string[]) => `–í—ã–±—Ä–∞–Ω–Ω—ã–π –≤–æ–¥—è–Ω–æ–π –∑–Ω–∞–∫: ${JSON.stringify(watermark)}`,
        watermarkCopied: (name: string) => `ASCII-–∞—Ä—Ç –¥–ª—è ${name} —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω!`,
        watermarkCopyAscii: () => "–°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å ASCII",
        watermarkJsonFileInvalid: () => "–§–∞–π–ª JSON –≤–æ–¥—è–Ω–æ–≥–æ –∑–Ω–∞–∫–∞ –ø—É—Å—Ç –∏–ª–∏ –Ω–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª–µ–Ω",
        watermarkName: () => "–ù–∞–∑–≤–∞–Ω–∏–µ –≤–æ–¥—è–Ω–æ–≥–æ –∑–Ω–∞–∫–∞",
        watermarkNotFound: () => "–í–æ–¥—è–Ω–æ–π –∑–Ω–∞–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω",
        watermarkPersonDisplayed: (name: string) => `–í–æ–¥—è–Ω–æ–π –∑–Ω–∞–∫ '${name}' –æ—Ç–æ–±—Ä–∞–∂–µ–Ω.`,
        watermarkView: () => "–ø—Ä–æ—Å–º–æ—Ç—Ä –≤–æ–¥—è–Ω–æ–≥–æ –∑–Ω–∞–∫–∞",
        watermarkZoomIn: () => "–£–≤–µ–ª–∏—á–∏—Ç—å",
        watermarkZoomOut: () => "–£–º–µ–Ω—å—à–∏—Ç—å"
    },
    "pt-br": {
        alternateFilePathUpdated: (oldFilePath: string, newFilePath: string): string => `O caminho alternativo foi atualizado de ${oldFilePath} para ${newFilePath}.`,
        alternateLogoDirectoryNotFound: (alternateRootDirectory: string, error: string = "N√£o fornecido") => `O diret√≥rio raiz alternativo do logotipo '${alternateRootDirectory}' n√£o foi encontrado, erro: '${error}'.`,
        alternateLogoDirectoryNotProvided: () => `Nenhum diret√≥rio alternativo de logotipo foi fornecido.`,
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]) => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}.`,
        brokenHeader: () => "Cabe√ßalho corrompido detectado, inserindo novo, por favor remova o anterior.",
        cacheAlreadyLoaded: (): string => "O cache j√° est√° carregado, retornando a inst√¢ncia armazenada.",
        chooseSingleLineCommentOption: () => "Por favor, selecione seu prefixo de coment√°rio preferido entre as op√ß√µes abaixo:",
        closedDocument: () => "O documento est√° fechado, interrompendo opera√ß√µes.",
        convertedContentCli: (content: string): string => `Conte√∫do convertido: ${content}`,
        convertedContentGui: (): string => "Conte√∫do convertido: ",
        corruptedFileMetaData: () => "Os metadados do arquivo n√£o foram coletados corretamente, abortando.",
        cwdDoesNotExist: (cwd: string) => `O diret√≥rio de trabalho fornecido ${cwd} n√£o existe.`,
        cwdUpdated: (oldCwd: string, newCwd: string) => `O diret√≥rio de trabalho atual foi atualizado de ${oldCwd} para ${newCwd}.`,
        darlingAge: () => "Idade",
        darlingAlias: () => "Apelido",
        darlingCopied: (name: string) => `ASCII art copiado para ${name}!`,
        darlingCopyAscii: () => "Copiar ASCII",
        darlingDescription: () => "Descri√ß√£o",
        darlingHeight: () => "Altura",
        darlingImage: () => "Imagem",
        darlingJsonFileInvalid: () => "O arquivo JSON do personagem est√° vazio ou inv√°lido",
        darlingMoreInfo: () => "Mais informa√ß√µes",
        darlingPersonDisplayed: (name: string) => `Personagem '${name}' exibido.`,
        darlingQuote: () => "Cita√ß√£o",
        darlingType: () => "Tipo",
        darlingView: () => "visualiza√ß√£o do personagem",
        darlingZoomIn: () => "Aumentar zoom",
        darlingZoomOut: () => "Diminuir zoom",
        documentLineScanExceeded: (maxScanLength: number) => `Verificadas as primeiras ${maxScanLength} linhas do arquivo, mas nenhum cabe√ßalho encontrado.`,
        emptyDocument: () => "N√£o h√° corpo do documento para trabalhar.",
        errorDuringFunctionCall: (functionName: string) => `Algo deu errado durante a chamada da fun√ß√£o (${functionName}), verifique os logs.`,
        extensionActivated: (moduleName: string) => `üöÄ "${moduleName}" agora est√° ativo!`,
        fileExcludedActivationDisabled: () => "Ativa√ß√£o desativada, o arquivo est√° na lista de exclus√£o.",
        fileLength: (filePath: string, fileLength: number): string => `Arquivo: '${filePath}', tamanho: ${fileLength} bytes.`,
        fileLoaded: (absolutePath: string) => `Arquivo ${absolutePath} carregado!`,
        fileLoadError: (filePath: string, error: string = "N√£oFornecido"): string => `Falha ao carregar o arquivo: '${filePath}'. Erro: ${error}.`,
        fileNotFound: (filePath: string): string => `Arquivo n√£o encontrado: ${filePath}`,
        fileParseError: (filePath: string, error: string) => `O conte√∫do do arquivo (${filePath}) n√£o p√¥de ser carregado com sucesso. Erro: ${error}.`,
        filepathPresenceCheck: (filePath: string): string => `Verificando a presen√ßa do caminho do arquivo: ${filePath}`,
        filePathProcessing: (filepath: string): string => `Processando o caminho do arquivo: '${filepath}'.`,
        filePathUpdated: (oldFilePath: string, newFilePath: string) => `O caminho foi atualizado de ${oldFilePath} para ${newFilePath}.`,
        fileRefreshed: () => "Atualizando o conte√∫do do arquivo.",
        fileSaveFailed: () => "Falha ao salvar o arquivo, por favor tente novamente.",
        fileUnloaded: (filePath: string) => `Arquivo ${filePath} descarregado da mem√≥ria.`,
        foundAlternateFilePathToLoad: (alternateFilePath: string) => `O caminho alternativo do arquivo a ser carregado est√° definido como '${alternateFilePath}'.`,
        foundAlternateLogoRootDir: (rootDir: string) => `O diret√≥rio raiz alternativo atual do logotipo √©: '${rootDir}'.`,
        foundCurrentWorkingDirectory: (cwd: string) => `O diret√≥rio de trabalho atual est√° definido como '${cwd}'.`,
        foundFilePath: (filePath: string) => `O caminho do arquivo fornecido existe: '${filePath}'.`,
        foundFilePathToLoad: (filePath: string) => `O caminho do arquivo a ser carregado est√° definido como '${filePath}'.`,
        foundFocusEditor: () => `H√° um editor em foco.`,
        foundLanguageComment: () => `O arquivo de coment√°rios de idioma est√° presente.`,
        foundLogoInstance: () => `Uma inst√¢ncia de logotipo foi fornecida.`,
        foundLogoRootDir: (rootDir: string) => `O diret√≥rio raiz atual do logotipo √©: '${rootDir}'.`,
        foundNewLine: (newLineType: string) => `O novo tipo de linha determinado √© '${newLineType}'.`,
        foundWorkingDirectory: () => `O diret√≥rio de trabalho fornecido existe.`,
        fromMorseGetInput: (): string => "Por favor, insira o texto para converter de",
        getHeaderDescription: () => "Por favor, forne√ßa uma descri√ß√£o: ",
        getHeaderPurpose: () => "Por favor, forne√ßa o prop√≥sito do arquivo:",
        getHeaderTags: () => "Digite as tags para este arquivo, separadas por v√≠rgulas:",
        headerInjectQuestion: () => "Nenhum cabe√ßalho encontrado neste documento. Deseja adicionar um?",
        headerInjectQuestionRefused: () => "Voc√™ optou por n√£o adicionar um cabe√ßalho ao arquivo.",
        headerNotFound: () => "Nenhum cabe√ßalho encontrado neste documento.",
        headerOpenerAndCloserFound: () => "In√≠cio e fim do cabe√ßalho encontrados, atualizando data ap√≥s verifica√ß√£o.",
        headerOpenerFound: () => "In√≠cio do cabe√ßalho encontrado.",
        headerWriteFailed: () => "Falha ao escrever o cabe√ßalho no arquivo, verifique os logs.",
        headerWriteSuccess: () => "Cabe√ßalho escrito com sucesso.",
        helloWorldGreetingsCommand: (moduleName: string) => `Ol√° Mundo do ${moduleName}!`,
        identifiedLanguage: (langName: string) => `Idioma identificado: ${langName}.`,
        inFunction: (functionName: string, className: string = "N√£o especificado") => `Na fun√ß√£o: '${functionName}' da classe: '${className}'`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string) => `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        inputboxError: (promptText: string, err: string) => `Erro na caixa de entrada para ${promptText}: ${err}`,
        jsonContent: (jsonContentString: String) => `Conte√∫do do arquivo JSON de coment√°rios: ${jsonContentString}`,
        languageNotFound: (LanguageId: string, fileExtension: string) => `N√£o foi poss√≠vel identificar o idioma do arquivo deste documento, languageID: ${LanguageId}, extens√£o do arquivo: ${fileExtension}`,
        lastModifiedLineNotFound: () => "O cabe√ßalho n√£o cont√©m uma linha '√öltima Modifica√ß√£o' para atualizar.",
        lastModifiedUpdated: () => "Data de '√öltima Modifica√ß√£o' atualizada com sucesso.",
        logoChosen: (logo: string[]) => `Logotipo a ser exibido: ${JSON.stringify(logo)}`,
        logoCopied: (logoName: string) => `ASCII art copiado para ${logoName}!`,
        logoCopyAscii: () => "Copiar ASCII",
        logoDisplayed: (name: string) => `Logotipo '${name}' exibido.`,
        logoMessage: (logoPath: string) => `Arquivo (${logoPath}) ignorado, pois n√£o √© do tipo esperado.`,
        logoName: () => "Nome do logotipo",
        logoNoRootDir: () => "Nenhum diret√≥rio raiz fornecido para coleta de logotipos",
        logoNotFound: () => "Logotipo n√£o encontrado",
        logoRootDirUpdateError: (error: string) => `Erro ao atualizar arquivos de logotipo: ${error}`,
        logoView: () => "visualiza√ß√£o do logotipo",
        logoZoomIn: (): string => "Aumentar Zoom",
        logoZoomOut: (): string => "Diminuir Zoom",
        messageNotFound: (key: string) => `Mensagem '${key}' n√£o encontrada.`,
        messageWritten: () => "Mensagem escrita",
        missingFileError: () => "O dicion√°rio de idioma est√° faltando, adaptabilidade de coment√°rio desativada.",
        missingLanguageComment: () => "Coment√°rio de idioma n√£o fornecido, atribui√ß√£o ignorada.",
        morseConverted: (input: string, final: string) => `Convertido: ${input} para ${final}`,
        morseDecoded: (input: string, final: string) => `Decodificado: ${input} para ${final}`,
        noActiveEditor: () => "Nenhum arquivo ativo!",
        noCommentToShow: () => "N√£o h√° coment√°rios para exibir.",
        noFilesAvailableForLoading: (): string => "N√£o h√° arquivos dispon√≠veis para carregar.",
        noFocusedEditors: () => "N√£o h√° arquivos em foco.",
        noLogoInstanceProvided: () => "Nenhuma inst√¢ncia de randomizador de logotipo fornecida.",
        noProvidedCommentOptions: () => "Nenhuma op√ß√£o de coment√°rio fornecida.",
        notFoundFilePath: (filePath: string, error: string = "N√£o fornecido") => `O caminho do arquivo fornecido n√£o existe: '${filePath}', erro: '${error}'`,
        openFileToApplyHeader: () => "Por favor, abra um arquivo para aplicar o cabe√ßalho.",
        operationCanceled: (): string => "Opera√ß√£o cancelada",
        quickPickError: (err: string) => `Erro no quickPick: ${err}`,
        quickPickNo: () => "N√£o",
        quickPickYes: () => "Sim",
        ramdomLogoGatheringLogoUndefined: () => "O conte√∫do do logotipo est√° indefinido.",
        randomLogoGatheringFailed: (error: string) => `Falha na coleta aleat√≥ria de logotipos, usando logotipo padr√£o, erro: "${error}"`,
        readTimeout: (timeout: number, filePath: string): string => `Tempo de leitura esgotado ap√≥s ${timeout}ms para ${filePath}`,
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string) => `Ol√° mundo! Extens√£o do arquivo: ${fileExtension}, nome: ${fileName}, caminho: ${filePath}, idioma: ${languageId}\n`,
        toMorseGetInput: (): string => "Por favor, insira o texto para converter",
        unknown: () => "Desconhecido",
        unknownFileStructure: () => "A estrutura do dicion√°rio de idioma √© desconhecida, adaptabilidade de coment√°rio desativada.",
        updateAbortedBecauseFileClosedSyncCancelled: () => "Atualiza√ß√£o abortada porque o arquivo est√° fechado e n√£o ser√° sincronizado.",
        updateEditDateMissingBounds: () => "N√£o foi poss√≠vel atualizar o cabe√ßalho: marcadores internos n√£o encontrados.",
        updatingEditionDate: () => "Atualizando a data de edi√ß√£o.",
        watermarkAuthorName: () => "Nome do autor",
        watermarkChosen: (watermark: string[]) => `Marca d'√°gua a ser exibida: ${JSON.stringify(watermark)}`,
        watermarkCopied: (name: string) => `ASCII art copiado para ${name}!`,
        watermarkCopyAscii: () => "Copiar ASCII",
        watermarkJsonFileInvalid: () => "O arquivo JSON da marca d'√°gua est√° vazio ou inv√°lido",
        watermarkName: () => "Nome da marca d'√°gua",
        watermarkNotFound: () => "Marca d'√°gua n√£o encontrada",
        watermarkPersonDisplayed: (name: string) => `Marca d'√°gua '${name}' exibida.`,
        watermarkView: () => "visualiza√ß√£o da marca d'√°gua",
        watermarkZoomIn: () => "Aumentar zoom",
        watermarkZoomOut: () => "Diminuir zoom"
    },
    "tr": {
        alternateFilePathUpdated: (oldFilePath: string, newFilePath: string): string => `Alternatif yol ${oldFilePath} konumundan ${newFilePath} konumuna g√ºncellendi.`,
        alternateLogoDirectoryNotFound: (alternateRootDirectory: string, error: string = "Saƒülanmadƒ±") => `Alternatif logo k√∂k dizini '${alternateRootDirectory}' bulunamadƒ±, hata: '${error}'.`,
        alternateLogoDirectoryNotProvided: () => `Alternatif logo dizini belirtilmedi.`,
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]) => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}.`,
        brokenHeader: () => "Bozuk ba≈ülƒ±k tespit edildi, yeni ba≈ülƒ±k ekleniyor, l√ºtfen √∂ncekini kaldƒ±rƒ±n.",
        cacheAlreadyLoaded: (): string => "√ñnbellek zaten y√ºkl√º, depolanan √∂rnek geri d√∂nd√ºr√ºl√ºyor.",
        chooseSingleLineCommentOption: () => "A≈üaƒüƒ±daki se√ßeneklerden tercih ettiƒüiniz yorum √∂n ekini se√ßin:",
        closedDocument: () => "Belge kapalƒ±, i≈ülemler durduruluyor.",
        convertedContentCli: (content: string): string => `D√∂n√º≈üt√ºr√ºlen i√ßerik: ${content}`,
        convertedContentGui: (): string => "D√∂n√º≈üt√ºr√ºlen i√ßerik: ",
        corruptedFileMetaData: () => "Gerekli dosya meta verileri doƒüru ≈üekilde alƒ±namadƒ±, i≈ülem durduruldu.",
        cwdDoesNotExist: (cwd: string) => `Saƒülanan √ßalƒ±≈üma dizini ${cwd} mevcut deƒüil.`,
        cwdUpdated: (oldCwd: string, newCwd: string) => `Mevcut √ßalƒ±≈üma dizini ${oldCwd}‚Äôden ${newCwd}‚Äôye g√ºncellendi.`,
        darlingAge: () => "Ya≈ü",
        darlingAlias: () => "Takma ad",
        darlingCopied: (name: string) => `${name} i√ßin ASCII sanatƒ± kopyalandƒ±!`,
        darlingCopyAscii: () => "ASCII'yi Kopyala",
        darlingDescription: () => "A√ßƒ±klama",
        darlingHeight: () => "Boy",
        darlingImage: () => "Resim",
        darlingJsonFileInvalid: () => "Karakter JSON dosyasƒ± bo≈ü veya ge√ßersiz",
        darlingMoreInfo: () => "Daha fazla bilgi",
        darlingPersonDisplayed: (name: string) => `'${name}' karakteri g√∂r√ºnt√ºlendi.`,
        darlingQuote: () => "Alƒ±ntƒ±",
        darlingType: () => "T√ºr",
        darlingView: () => "karakterG√∂r√ºn√ºm√º",
        darlingZoomIn: () => "Yakƒ±nla≈ütƒ±r",
        darlingZoomOut: () => "Uzakla≈ütƒ±r",
        documentLineScanExceeded: (maxScanLength: number) => `Dosyanƒ±n ilk ${maxScanLength} satƒ±rƒ± tarandƒ±, ba≈ülƒ±k bulunamadƒ±.`,
        emptyDocument: () => "√úzerinde √ßalƒ±≈üƒ±lacak belge yok.",
        errorDuringFunctionCall: (functionName: string) => `Fonksiyon (${functionName}) √ßaƒürƒ±lƒ±rken bir hata olu≈ütu, loglarƒ± kontrol edin.`,
        extensionActivated: (moduleName: string) => `üöÄ "${moduleName}" artƒ±k aktif!`,
        fileExcludedActivationDisabled: () => "Aktivasyon devre dƒ±≈üƒ±, dosya hari√ß tutma listesinde.",
        fileLength: (filePath: string, fileLength: number): string => `Dosya: '${filePath}', boyut: ${fileLength} byte.`,
        fileLoaded: (absolutePath: string) => `Dosya ${absolutePath} y√ºklendi!`,
        fileLoadError: (filePath: string, error: string = "Saƒülanmadƒ±"): string => `Dosya y√ºklenemedi: '${filePath}'. Hata: ${error}.`,
        fileNotFound: (filePath: string): string => `Dosya bulunamadƒ±: ${filePath}`,
        fileParseError: (filePath: string, error: string) => `Dosya i√ßeriƒüi (${filePath}) ba≈üarƒ±yla y√ºklenemedi. Hata: ${error}.`,
        filepathPresenceCheck: (filePath: string): string => `Dosya yolu kontrol ediliyor: ${filePath}`,
        filePathProcessing: (filepath: string): string => `Dosya yolu i≈üleniyor: '${filepath}'.`,
        filePathUpdated: (oldFilePath: string, newFilePath: string) => `Yol ${oldFilePath}‚Äôden ${newFilePath}‚Äôe g√ºncellendi.`,
        fileRefreshed: () => "Dosya i√ßeriƒüi yenileniyor.",
        fileSaveFailed: () => "Dosya kaydedilemedi, l√ºtfen tekrar deneyin.",
        fileUnloaded: (filePath: string) => `Dosya ${filePath} hafƒ±zadan bo≈üaltƒ±ldƒ±.`,
        foundAlternateFilePathToLoad: (alternateFilePath: string) => `Y√ºklenecek alternatif dosya yolu '${alternateFilePath}' olarak ayarlandƒ±.`,
        foundAlternateLogoRootDir: (rootDir: string) => `Ge√ßerli alternatif logo k√∂k dizini: '${rootDir}'.`,
        foundCurrentWorkingDirectory: (cwd: string) => `Ge√ßerli √ßalƒ±≈üma dizini '${cwd}' olarak ayarlandƒ±.`,
        foundFilePath: (filePath: string) => `Belirtilen dosya yolu mevcut: '${filePath}'.`,
        foundFilePathToLoad: (filePath: string) => `Y√ºklenecek dosya yolu '${filePath}' olarak ayarlandƒ±.`,
        foundFocusEditor: () => `Odakta bir d√ºzenleyici var.`,
        foundLanguageComment: () => `Dil yorum dosyasƒ± mevcut.`,
        foundLogoInstance: () => `Bir logo √∂rneƒüi saƒülandƒ±.`,
        foundLogoRootDir: (rootDir: string) => `Ge√ßerli logo k√∂k dizini: '${rootDir}'.`,
        foundNewLine: (newLineType: string) => `Yeni belirlenen satƒ±r t√ºr√º: '${newLineType}'.`,
        foundWorkingDirectory: () => `Belirtilen √ßalƒ±≈üma dizini mevcut.`,
        fromMorseGetInput: (): string => "L√ºtfen d√∂n√º≈üt√ºr√ºlecek metni buradan girin",
        getHeaderDescription: () => "L√ºtfen bir a√ßƒ±klama saƒülayƒ±n: ",
        getHeaderPurpose: () => "L√ºtfen dosyanƒ±n amacƒ±nƒ± belirtin:",
        getHeaderTags: () => "Bu dosya i√ßin etiketleri virg√ºlle ayƒ±rarak girin:",
        headerInjectQuestion: () => "Bu belgede ba≈ülƒ±k bulunamadƒ±. Eklemek ister misiniz?",
        headerInjectQuestionRefused: () => "Dosyaya ba≈ülƒ±k eklememeyi se√ßtiniz.",
        headerNotFound: () => "Bu belgede ba≈ülƒ±k bulunamadƒ±.",
        headerOpenerAndCloserFound: () => "Ba≈ülƒ±k a√ßƒ±lƒ±≈üƒ± ve kapanƒ±≈üƒ± bulundu, denetim sonrasƒ± tarih g√ºncellemesine ge√ßiliyor.",
        headerOpenerFound: () => "Ba≈ülƒ±k a√ßƒ±lƒ±≈üƒ± bulundu.",
        headerWriteFailed: () => "Ba≈ülƒ±k dosyaya yazƒ±lamadƒ±, g√ºnl√ºkleri kontrol edin.",
        headerWriteSuccess: () => "Ba≈ülƒ±k ba≈üarƒ±yla yazƒ±ldƒ±.",
        helloWorldGreetingsCommand: (moduleName: string) => `${moduleName}‚Äôden Merhaba D√ºnya!`,
        identifiedLanguage: (langName: string) => `Belirlenen dil: ${langName}.`,
        inFunction: (functionName: string, className: string = "Belirtilmedi") => `'${className}' sƒ±nƒ±fƒ±ndaki '${functionName}' fonksiyonunda`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string) => `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        inputboxError: (promptText: string, err: string) => `${promptText} i√ßin inputBox hatasƒ±: ${err}`,
        jsonContent: (jsonContentString: String) => `Yorum JSON dosyasƒ±nƒ±n i√ßeriƒüi: ${jsonContentString}`,
        languageNotFound: (LanguageId: string, fileExtension: string) => `Bu belgenin dosya dili tanƒ±mlanamadƒ±, languageID: ${LanguageId}, dosya uzantƒ±sƒ±: ${fileExtension}`,
        lastModifiedLineNotFound: () => "Ba≈ülƒ±kta g√ºncellenecek 'Son Deƒüi≈üiklik' satƒ±rƒ± yok.",
        lastModifiedUpdated: () => "'Son Deƒüi≈üiklik' tarihi ba≈üarƒ±yla g√ºncellendi.",
        logoChosen: (logo: string[]) => `G√∂sterilecek logo: ${JSON.stringify(logo)}`,
        logoCopied: (logoName: string) => `${logoName} i√ßin ASCII sanatƒ± kopyalandƒ±!`,
        logoCopyAscii: () => "ASCII'yi Kopyala",
        logoDisplayed: (name: string) => `'${name}' logosu g√∂r√ºnt√ºlendi.`,
        logoMessage: (logoPath: string) => `Dosya (${logoPath}) g√∂z ardƒ± edildi, √ß√ºnk√º aranan t√ºr deƒüil.`,
        logoName: () => "Logo adƒ±",
        logoNoRootDir: () => "Logo toplamak i√ßin k√∂k dizin saƒülanmadƒ±",
        logoNotFound: () => "Logo bulunamadƒ±",
        logoRootDirUpdateError: (error: string) => `Logo dosyalarƒ± g√ºncellenirken bir hata olu≈ütu: ${error}`,
        logoView: () => "logoG√∂r√ºn√ºm√º",
        logoZoomIn: (): string => "Yakƒ±nla≈ütƒ±r",
        logoZoomOut: (): string => "Uzakla≈ütƒ±r",
        messageNotFound: (key: string) => `'${key}' mesajƒ± bulunamadƒ±.`,
        messageWritten: () => "Mesaj yazƒ±ldƒ±",
        missingFileError: () => "Dil s√∂zl√ºƒü√º eksik, yorum uyumluluƒüu devre dƒ±≈üƒ±.",
        missingLanguageComment: () => "Dil yorumu saƒülanmadƒ±, atlama yapƒ±lƒ±yor.",
        morseConverted: (input: string, final: string) => `D√∂n√º≈üt√ºr√ºld√º: ${input} -> ${final}`,
        morseDecoded: (input: string, final: string) => `√á√∂z√ºld√º: ${input} -> ${final}`,
        noActiveEditor: () => "Aktif dosya yok!",
        noCommentToShow: () => "G√∂sterilecek yorum yok.",
        noFilesAvailableForLoading: (): string => "Y√ºklenecek dosya bulunmamaktadƒ±r.",
        noFocusedEditors: () => "Odaklanmƒ±≈ü dosya yok.",
        noLogoInstanceProvided: () => "Hi√ßbir logo rastgelele≈ütirici √∂rneƒüi saƒülanmadƒ±.",
        noProvidedCommentOptions: () => "Saƒülanmƒ±≈ü yorum se√ßeneƒüi yok.",
        notFoundFilePath: (filePath: string, error: string = "Saƒülanmadƒ±") => `Belirtilen dosya yolu mevcut deƒüil: '${filePath}', hata: '${error}'`,
        openFileToApplyHeader: () => "Ba≈ülƒ±ƒüƒ± uygulamak i√ßin bir dosya a√ßƒ±n.",
        operationCanceled: (): string => "ƒ∞≈ülem iptal edildi",
        quickPickError: (err: string) => `quickPick hatasƒ±: ${err}`,
        quickPickNo: () => "Hayƒ±r",
        quickPickYes: () => "Evet",
        ramdomLogoGatheringLogoUndefined: () => "Logo i√ßeriƒüi tanƒ±msƒ±z.",
        randomLogoGatheringFailed: (error: string) => `Rastgele logo toplama ba≈üarƒ±sƒ±z, varsayƒ±lan logo kullanƒ±lƒ±yor, hata: "${error}"`,
        readTimeout: (timeout: number, filePath: string): string => `${filePath} i√ßin okuma s√ºresi ${timeout}ms sonra doldu`,
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string) => `Merhaba d√ºnya! Bu dosyanƒ±n uzantƒ±sƒ±: ${fileExtension}, adƒ±: ${fileName}, yolu: ${filePath}, belirlenen dil: ${languageId}\n`,
        toMorseGetInput: (): string => "L√ºtfen d√∂n√º≈üt√ºr√ºlecek metni girin",
        unknown: () => "Bilinmeyen",
        unknownFileStructure: () => "Dil s√∂zl√ºƒü√º yapƒ±sƒ± bilinmiyor, yorum uyumluluƒüu devre dƒ±≈üƒ±.",
        updateAbortedBecauseFileClosedSyncCancelled: () => "Dosya kapalƒ± olduƒüu i√ßin g√ºncelleme iptal edildi ve senkronize edilmeyecek.",
        updateEditDateMissingBounds: () => "Ba≈ülƒ±k g√ºncellenemedi: i√ß ba≈ülƒ±k i≈üaret√ßileri bulunamadƒ±.",
        updatingEditionDate: () => "S√ºr√ºm tarihi g√ºncelleniyor.",
        watermarkAuthorName: () => "Yazar adƒ±",
        watermarkChosen: (watermark: string[]) => `G√∂sterilecek filigran: ${JSON.stringify(watermark)}`,
        watermarkCopied: (name: string) => `${name} i√ßin ASCII sanatƒ± kopyalandƒ±!`,
        watermarkCopyAscii: () => "ASCII'yi Kopyala",
        watermarkJsonFileInvalid: () => "Filigran JSON dosyasƒ± bo≈ü veya ge√ßersiz",
        watermarkName: () => "Filigran adƒ±",
        watermarkNotFound: () => "Filigran bulunamadƒ±",
        watermarkPersonDisplayed: (name: string) => `'${name}' filigranƒ± g√∂r√ºnt√ºlendi.`,
        watermarkView: () => "filigranG√∂r√ºn√ºm√º",
        watermarkZoomIn: () => "Yakƒ±nla≈ütƒ±r",
        watermarkZoomOut: () => "Uzakla≈ütƒ±r"
    },
    "pl": {
        alternateFilePathUpdated: (oldFilePath: string, newFilePath: string): string => `Alternatywna ≈õcie≈ºka zosta≈Ça zaktualizowana z ${oldFilePath} na ${newFilePath}.`,
        alternateLogoDirectoryNotFound: (alternateRootDirectory: string, error: string = "Nie podano") => `Alternatywny katalog g≈Ç√≥wny logo '${alternateRootDirectory}' nie zosta≈Ç znaleziony, b≈ÇƒÖd: '${error}'.`,
        alternateLogoDirectoryNotProvided: () => `Nie podano alternatywnego katalogu logo.`,
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]) => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}.`,
        brokenHeader: () => "Wykryto uszkodzony nag≈Ç√≥wek, wstrzykiwanie nowego, usu≈Ñ poprzedni.",
        cacheAlreadyLoaded: (): string => "Pamiƒôƒá podrƒôczna jest ju≈º za≈Çadowana, zwracanie zapisanej instancji.",
        chooseSingleLineCommentOption: () => "Wybierz preferowany prefiks komentarza z poni≈ºszych opcji:",
        closedDocument: () => "Dokument jest zamkniƒôty, zatrzymywanie operacji.",
        convertedContentCli: (content: string): string => `Przekonwertowana zawarto≈õƒá: ${content}`,
        convertedContentGui: (): string => "Przekonwertowana zawarto≈õƒá: ",
        corruptedFileMetaData: () => "Wymagane metadane pliku nie zosta≈Çy poprawnie zebrane, przerywanie.",
        cwdDoesNotExist: (cwd: string) => `Podany katalog roboczy ${cwd} nie istnieje.`,
        cwdUpdated: (oldCwd: string, newCwd: string) => `Bie≈ºƒÖcy katalog roboczy zaktualizowano z ${oldCwd} na ${newCwd}.`,
        darlingAge: () => "Wiek",
        darlingAlias: () => "Alias",
        darlingCopied: (name: string) => `Sztuka ASCII skopiowana dla ${name}!`,
        darlingCopyAscii: () => "Kopiuj ASCII",
        darlingDescription: () => "Opis",
        darlingHeight: () => "Wzrost",
        darlingImage: () => "Obraz",
        darlingJsonFileInvalid: () => "Plik JSON postaci jest pusty lub nieprawid≈Çowy",
        darlingMoreInfo: () => "Wiƒôcej informacji",
        darlingPersonDisplayed: (name: string) => `Postaƒá '${name}' zosta≈Ça wy≈õwietlona.`,
        darlingQuote: () => "Cytat",
        darlingType: () => "Typ",
        darlingView: () => "widokPostaci",
        darlingZoomIn: () => "Powiƒôksz",
        darlingZoomOut: () => "Pomniejsz",
        documentLineScanExceeded: (maxScanLength: number) => `Przeskanowano pierwsze ${maxScanLength} linie pliku, ale nie znaleziono nag≈Ç√≥wka.`,
        emptyDocument: () => "Brak zawarto≈õci dokumentu do pracy.",
        errorDuringFunctionCall: (functionName: string) => `WystƒÖpi≈Ç b≈ÇƒÖd podczas wywo≈Çania funkcji (${functionName}), sprawd≈∫ logi.`,
        extensionActivated: (moduleName: string) => `üöÄ "${moduleName}" jest teraz aktywny!`,
        fileExcludedActivationDisabled: () => "Aktywacja wy≈ÇƒÖczona, plik znajduje siƒô na li≈õcie wyklucze≈Ñ.",
        fileLength: (filePath: string, fileLength: number): string => `Plik: '${filePath}', d≈Çugo≈õƒá: ${fileLength} bajt√≥w.`,
        fileLoaded: (absolutePath: string) => `Plik ${absolutePath} zosta≈Ç za≈Çadowany!`,
        fileLoadError: (filePath: string, error: string = "Niepodano"): string => `Nie uda≈Ço siƒô za≈Çadowaƒá pliku: '${filePath}'. B≈ÇƒÖd: ${error}.`,
        fileNotFound: (filePath: string): string => `Nie znaleziono pliku: ${filePath}`,
        fileParseError: (filePath: string, error: string) => `Zawarto≈õƒá pliku (${filePath}) nie mog≈Ça zostaƒá za≈Çadowana poprawnie. B≈ÇƒÖd: ${error}.`,
        filepathPresenceCheck: (filePath: string): string => `Sprawdzanie obecno≈õci ≈õcie≈ºki pliku: ${filePath}`,
        filePathProcessing: (filepath: string): string => `Przetwarzanie ≈õcie≈ºki pliku: '${filepath}'.`,
        filePathUpdated: (oldFilePath: string, newFilePath: string) => `≈öcie≈ºka zosta≈Ça zaktualizowana z ${oldFilePath} na ${newFilePath}.`,
        fileRefreshed: () => "Od≈õwie≈ºanie zawarto≈õci pliku.",
        fileSaveFailed: () => "Nie uda≈Ço siƒô zapisaƒá pliku, spr√≥buj ponownie.",
        fileUnloaded: (filePath: string) => `Plik ${filePath} zosta≈Ç usuniƒôty z pamiƒôci.`,
        foundAlternateFilePathToLoad: (alternateFilePath: string) => `Alternatywna ≈õcie≈ºka pliku do za≈Çadowania to '${alternateFilePath}'.`,
        foundAlternateLogoRootDir: (rootDir: string) => `Bie≈ºƒÖcy alternatywny katalog g≈Ç√≥wny logo to: '${rootDir}'.`,
        foundCurrentWorkingDirectory: (cwd: string) => `Bie≈ºƒÖcy katalog roboczy to '${cwd}'.`,
        foundFilePath: (filePath: string) => `Podana ≈õcie≈ºka pliku istnieje: '${filePath}'.`,
        foundFilePathToLoad: (filePath: string) => `≈öcie≈ºka pliku do za≈Çadowania to '${filePath}'.`,
        foundFocusEditor: () => `Edytor jest aktywny.`,
        foundLanguageComment: () => `Plik komentarzy jƒôzykowych jest obecny.`,
        foundLogoInstance: () => `Dostarczono instancjƒô logo.`,
        foundLogoRootDir: (rootDir: string) => `Bie≈ºƒÖcy katalog g≈Ç√≥wny logo to: '${rootDir}'.`,
        foundNewLine: (newLineType: string) => `Nowy typ linii to '${newLineType}'.`,
        foundWorkingDirectory: () => `Podany katalog roboczy istnieje.`,
        fromMorseGetInput: (): string => "Proszƒô wprowadziƒá tekst do konwersji z",
        getHeaderDescription: () => "Podaj opis: ",
        getHeaderPurpose: () => "Podaj cel pliku:",
        getHeaderTags: () => "Wprowad≈∫ tagi dla tego pliku, oddzielone przecinkami:",
        headerInjectQuestion: () => "Nie znaleziono nag≈Ç√≥wka w tym dokumencie. Czy chcesz dodaƒá jeden?",
        headerInjectQuestionRefused: () => "Zdecydowano nie dodawaƒá nag≈Ç√≥wka do pliku.",
        headerNotFound: () => "Nie znaleziono nag≈Ç√≥wka w tym dokumencie.",
        headerOpenerAndCloserFound: () => "Znaleziono otwieracz i zamykacz nag≈Ç√≥wka, kontynuowanie aktualizacji daty po kontroli poprawno≈õci.",
        headerOpenerFound: () => "Znaleziono otwieracz nag≈Ç√≥wka.",
        headerWriteFailed: () => "Nie uda≈Ço siƒô zapisaƒá nag≈Ç√≥wka do pliku, sprawd≈∫ logi.",
        headerWriteSuccess: () => "Nag≈Ç√≥wek zapisany pomy≈õlnie.",
        helloWorldGreetingsCommand: (moduleName: string) => `Witaj ≈öwiecie z ${moduleName}!`,
        identifiedLanguage: (langName: string) => `Zidentyfikowany jƒôzyk: ${langName}.`,
        inFunction: (functionName: string, className: string = "Nie okre≈õlono") => `W funkcji: '${functionName}' z klasy: '${className}'`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string) => `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        inputboxError: (promptText: string, err: string) => `B≈ÇƒÖd w inputBox dla ${promptText}: ${err}`,
        jsonContent: (jsonContentString: String) => `Zawarto≈õƒá pliku JSON komentarza: ${jsonContentString}`,
        languageNotFound: (LanguageId: string, fileExtension: string) => `Nie uda≈Ço siƒô zidentyfikowaƒá jƒôzyka pliku tego dokumentu, languageID: ${LanguageId}, rozszerzenie pliku: ${fileExtension}`,
        lastModifiedLineNotFound: () => "Nag≈Ç√≥wek nie zawiera wiersza 'Ostatnia modyfikacja' do aktualizacji.",
        lastModifiedUpdated: () => "Data 'Ostatnia modyfikacja' zosta≈Ça pomy≈õlnie zaktualizowana.",
        logoChosen: (logo: string[]) => `Logo do wy≈õwietlenia: ${JSON.stringify(logo)}`,
        logoCopied: (logoName: string) => `Sztuka ASCII skopiowana dla ${logoName}!`,
        logoCopyAscii: () => "Kopiuj ASCII",
        logoDisplayed: (name: string) => `Logo '${name}' zosta≈Ço wy≈õwietlone.`,
        logoMessage: (logoPath: string) => `Plik (${logoPath}) pominiƒôty, poniewa≈º nie jest szukanym typem.`,
        logoName: () => "Nazwa logo",
        logoNoRootDir: () => "Nie podano katalogu g≈Ç√≥wnego do zbierania logotyp√≥w",
        logoNotFound: () => "Logo nie znaleziono",
        logoRootDirUpdateError: (error: string) => `WystƒÖpi≈Ç b≈ÇƒÖd podczas aktualizacji plik√≥w logo: ${error}`,
        logoView: () => "widokLogo",
        logoZoomIn: (): string => "Powiƒôksz",
        logoZoomOut: (): string => "Pomniejsz",
        messageNotFound: (key: string) => `Nie znaleziono komunikatu '${key}'.`,
        messageWritten: () => "Wiadomo≈õƒá zapisana",
        missingFileError: () => "S≈Çownik jƒôzykowy jest brakujƒÖcy, dostosowanie komentarzy jest wy≈ÇƒÖczone.",
        missingLanguageComment: () => "Komentarz jƒôzyka nie zosta≈Ç dostarczony, pomijanie przypisania.",
        morseConverted: (input: string, final: string) => `Przekonwertowano: ${input} na ${final}`,
        morseDecoded: (input: string, final: string) => `Rozkodowano: ${input} na ${final}`,
        noActiveEditor: () => "Brak aktywnego pliku!",
        noCommentToShow: () => "Brak komentarzy do wy≈õwietlenia.",
        noFilesAvailableForLoading: (): string => "Brak plik√≥w do za≈Çadowania.",
        noFocusedEditors: () => "Brak plik√≥w w fokusie.",
        noLogoInstanceProvided: () => "Nie podano instancji losowego loga.",
        noProvidedCommentOptions: () => "Nie dostarczono ≈ºadnych opcji komentarza.",
        notFoundFilePath: (filePath: string, error: string = "Nie podano") => `Podana ≈õcie≈ºka pliku nie istnieje: '${filePath}', b≈ÇƒÖd: '${error}'`,
        openFileToApplyHeader: () => "Otw√≥rz plik, aby zastosowaƒá nag≈Ç√≥wek.",
        operationCanceled: (): string => "Operacja anulowana",
        quickPickError: (err: string) => `B≈ÇƒÖd w quickPick: ${err}`,
        quickPickNo: () => "Nie",
        quickPickYes: () => "Tak",
        ramdomLogoGatheringLogoUndefined: () => "Zawarto≈õƒá loga jest niezdefiniowana.",
        randomLogoGatheringFailed: (error: string) => `Losowe zbieranie loga nie powiod≈Ço siƒô, u≈ºycie domy≈õlnego loga, b≈ÇƒÖd: "${error}"`,
        readTimeout: (timeout: number, filePath: string): string => `Limit czasu odczytu po ${timeout}ms dla ${filePath}`,
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string) => `Witaj ≈õwiecie! Rozszerzenie tego pliku: ${fileExtension}, nazwa: ${fileName}, ≈õcie≈ºka: ${filePath}, okre≈õlony jƒôzyk: ${languageId}\n`,
        toMorseGetInput: (): string => "Proszƒô wprowadziƒá tekst do konwersji",
        unknown: () => "Nieznany",
        unknownFileStructure: () => "Struktura s≈Çownika jƒôzykowego jest nieznana, dostosowanie komentarzy jest wy≈ÇƒÖczone.",
        updateAbortedBecauseFileClosedSyncCancelled: () => "Aktualizacja przerwana, poniewa≈º plik jest zamkniƒôty i nie zostanie zsynchronizowany.",
        updateEditDateMissingBounds: () => "Nie mo≈ºna zaktualizowaƒá nag≈Ç√≥wka: nie znaleziono wewnƒôtrznych znacznik√≥w nag≈Ç√≥wka.",
        updatingEditionDate: () => "Aktualizacja daty edycji.",
        watermarkAuthorName: () => "Autor",
        watermarkChosen: (watermark: string[]) => `Filigran do wy≈õwietlenia: ${JSON.stringify(watermark)}`,
        watermarkCopied: (name: string) => `Sztuka ASCII skopiowana dla ${name}!`,
        watermarkCopyAscii: () => "Kopiuj ASCII",
        watermarkJsonFileInvalid: () => "Plik JSON filigranu jest pusty lub nieprawid≈Çowy",
        watermarkName: () => "Nazwa filigranu",
        watermarkNotFound: () => "Filigran nie zosta≈Ç znaleziony",
        watermarkPersonDisplayed: (name: string) => `Filigran '${name}' zosta≈Ç wy≈õwietlony.`,
        watermarkView: () => "widokWatermark",
        watermarkZoomIn: () => "Powiƒôksz",
        watermarkZoomOut: () => "Pomniejsz"
    },
    "cs": {
        alternateFilePathUpdated: (oldFilePath: string, newFilePath: string): string => `Alternativn√≠ cesta byla aktualizov√°na z ${oldFilePath} na ${newFilePath}.`,
        alternateLogoDirectoryNotFound: (alternateRootDirectory: string, error: string = "Neuvedeno") => `Alternativn√≠ ko≈ôenov√Ω adres√°≈ô loga '${alternateRootDirectory}' nebyl nalezen, chyba: '${error}'.`,
        alternateLogoDirectoryNotProvided: () => `Nebyl zad√°n alternativn√≠ adres√°≈ô s logy.`,
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]) => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}.`,
        brokenHeader: () => "Byla detekov√°na po≈°kozen√° hlaviƒçka, vkl√°d√° se nov√°, odstra≈àte p≈ôedchoz√≠.",
        cacheAlreadyLoaded: (): string => "Cache je ji≈æ naƒçtena, vrac√≠m ulo≈æenou instanci.",
        chooseSingleLineCommentOption: () => "Vyberte preferovan√Ω prefix koment√°≈ôe z n√≠≈æe uveden√Ωch mo≈ænost√≠:",
        closedDocument: () => "Dokument je uzav≈ôen, operace zastaveny.",
        convertedContentCli: (content: string): string => `P≈ôeveden√Ω obsah: ${content}`,
        convertedContentGui: (): string => "P≈ôeveden√Ω obsah: ",
        corruptedFileMetaData: () => "Po≈æadovan√° metadata souboru nebyla spr√°vnƒõ shrom√°≈ædƒõna, p≈ôeru≈°en√≠.",
        cwdDoesNotExist: (cwd: string) => `Zadan√Ω pracovn√≠ adres√°≈ô ${cwd} neexistuje.`,
        cwdUpdated: (oldCwd: string, newCwd: string) => `Aktu√°ln√≠ pracovn√≠ adres√°≈ô byl aktualizov√°n z ${oldCwd} na ${newCwd}.`,
        darlingAge: () => "Vƒõk",
        darlingAlias: () => "P≈ôezd√≠vka",
        darlingCopied: (name: string) => `ASCII umƒõn√≠ zkop√≠rov√°no pro ${name}!`,
        darlingCopyAscii: () => "Kop√≠rovat ASCII",
        darlingDescription: () => "Popis",
        darlingHeight: () => "V√Ω≈°ka",
        darlingImage: () => "Obr√°zek",
        darlingJsonFileInvalid: () => "Soubor JSON postavy je pr√°zdn√Ω nebo neplatn√Ω",
        darlingMoreInfo: () => "V√≠ce informac√≠",
        darlingPersonDisplayed: (name: string) => `Postava '${name}' zobrazena.`,
        darlingQuote: () => "Cit√°t",
        darlingType: () => "Typ",
        darlingView: () => "zobrazen√≠Postavy",
        darlingZoomIn: () => "P≈ôibl√≠≈æit",
        darlingZoomOut: () => "Odd√°lit",
        documentLineScanExceeded: (maxScanLength: number) => `Prohled√°no prvn√≠ch ${maxScanLength} ≈ô√°dk≈Ø souboru, ale hlaviƒçka nebyla nalezena.`,
        emptyDocument: () => "Neexistuje ≈æ√°dn√Ω obsah dokumentu k pr√°ci.",
        errorDuringFunctionCall: (functionName: string) => `Nƒõco se pokazilo bƒõhem vol√°n√≠ funkce (${functionName}), zkontrolujte logy.`,
        extensionActivated: (moduleName: string) => `üöÄ "${moduleName}" je nyn√≠ aktivn√≠!`,
        fileExcludedActivationDisabled: () => "Aktivace zak√°z√°na, soubor je na seznamu vylouƒçen√≠.",
        fileLength: (filePath: string, fileLength: number): string => `Soubor: '${filePath}', d√©lka: ${fileLength} bajt≈Ø.`,
        fileLoaded: (absolutePath: string) => `Soubor ${absolutePath} byl naƒçten!`,
        fileLoadError: (filePath: string, error: string = "Neuvedeno"): string => `Nepoda≈ôilo se naƒç√≠st soubor: '${filePath}'. Chyba: ${error}.`,
        fileNotFound: (filePath: string): string => `Soubor nenalezen: ${filePath}`,
        fileParseError: (filePath: string, error: string) => `Obsah souboru (${filePath}) nelze √∫spƒõ≈°nƒõ naƒç√≠st. Chyba: ${error}.`,
        filepathPresenceCheck: (filePath: string): string => `Kontrola p≈ô√≠tomnosti cesty k souboru: ${filePath}`,
        filePathProcessing: (filepath: string): string => `Zpracov√°v√°m cestu k souboru: '${filepath}'.`,
        filePathUpdated: (oldFilePath: string, newFilePath: string) => `Cesta byla aktualizov√°na z ${oldFilePath} na ${newFilePath}.`,
        fileRefreshed: () => "Obnovov√°n√≠ obsahu souboru.",
        fileSaveFailed: () => "Nepoda≈ôilo se ulo≈æit soubor, zkuste to znovu.",
        fileUnloaded: (filePath: string) => `Soubor ${filePath} byl odstranƒõn z pamƒõti.`,
        foundAlternateFilePathToLoad: (alternateFilePath: string) => `Alternativn√≠ cesta k souboru k naƒçten√≠ je nastavena na '${alternateFilePath}'.`,
        foundAlternateLogoRootDir: (rootDir: string) => `Aktu√°ln√≠ alternativn√≠ ko≈ôenov√Ω adres√°≈ô loga je: '${rootDir}'.`,
        foundCurrentWorkingDirectory: (cwd: string) => `Aktu√°ln√≠ pracovn√≠ adres√°≈ô je nastaven na '${cwd}'.`,
        foundFilePath: (filePath: string) => `Zadan√° cesta k souboru existuje: '${filePath}'.`,
        foundFilePathToLoad: (filePath: string) => `Cesta k souboru k naƒçten√≠ je nastavena na '${filePath}'.`,
        foundFocusEditor: () => `Editor je aktivn√≠.`,
        foundLanguageComment: () => `Soubor s jazykov√Ωmi koment√°≈ôi je p≈ô√≠tomen.`,
        foundLogoInstance: () => `Byla poskytnuta instance loga.`,
        foundLogoRootDir: (rootDir: string) => `Aktu√°ln√≠ ko≈ôenov√Ω adres√°≈ô loga je: '${rootDir}'.`,
        foundNewLine: (newLineType: string) => `Nov√Ω urƒçen√Ω typ ≈ô√°dku je '${newLineType}'.`,
        foundWorkingDirectory: () => `Zadan√Ω pracovn√≠ adres√°≈ô existuje.`,
        fromMorseGetInput: (): string => "Zadejte pros√≠m text k p≈ôevodu z",
        getHeaderDescription: () => "Zadejte popis: ",
        getHeaderPurpose: () => "Zadejte √∫ƒçel souboru:",
        getHeaderTags: () => "Zadejte tagy pro tento soubor, oddƒõlen√© ƒç√°rkou:",
        headerInjectQuestion: () => "V tomto dokumentu nebyla nalezena ≈æ√°dn√° hlaviƒçka. Chcete ji p≈ôidat?",
        headerInjectQuestionRefused: () => "Rozhodli jste se nep≈ôid√°vat hlaviƒçku do souboru.",
        headerNotFound: () => "V tomto dokumentu nebyla nalezena ≈æ√°dn√° hlaviƒçka.",
        headerOpenerAndCloserFound: () => "Otev√≠raƒç a zav√≠raƒç hlaviƒçky nalezeny, pokraƒçuje aktualizace data po kontrole spr√°vnosti.",
        headerOpenerFound: () => "Otev√≠raƒç hlaviƒçky nalezen.",
        headerWriteFailed: () => "Nepoda≈ôilo se zapsat hlaviƒçku do souboru, zkontrolujte protokoly.",
        headerWriteSuccess: () => "Hlaviƒçka √∫spƒõ≈°nƒõ zaps√°na.",
        helloWorldGreetingsCommand: (moduleName: string) => `Hello World z ${moduleName}!`,
        identifiedLanguage: (langName: string) => `Identifikovan√Ω jazyk: ${langName}.`,
        inFunction: (functionName: string, className: string = "Nespecifikov√°no") => `Ve funkci: '${functionName}' ze t≈ô√≠dy: '${className}'`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string) => `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        inputboxError: (promptText: string, err: string) => `Chyba v inputBox pro ${promptText}: ${err}`,
        jsonContent: (jsonContentString: String) => `Obsah JSON souboru koment√°≈ô≈Ø: ${jsonContentString}`,
        languageNotFound: (LanguageId: string, fileExtension: string) => `Jazyk souboru tohoto dokumentu nelze identifikovat, languageID: ${LanguageId}, p≈ô√≠pona souboru: ${fileExtension}`,
        lastModifiedLineNotFound: () => "Hlaviƒçka neobsahuje ≈ô√°dek 'Posledn√≠ √∫prava' k aktualizaci.",
        lastModifiedUpdated: () => "Datum 'Posledn√≠ √∫prava' bylo √∫spƒõ≈°nƒõ aktualizov√°no.",
        logoChosen: (logo: string[]) => `Logo k zobrazen√≠: ${JSON.stringify(logo)}`,
        logoCopied: (logoName: string) => `ASCII umƒõn√≠ zkop√≠rov√°no pro ${logoName}!`,
        logoCopyAscii: () => "Kop√≠rovat ASCII",
        logoDisplayed: (name: string) => `Logo '${name}' zobrazeno.`,
        logoMessage: (logoPath: string) => `Soubor (${logoPath}) byl ignorov√°n, proto≈æe nen√≠ po≈æadovan√©ho typu.`,
        logoName: () => "N√°zev loga",
        logoNoRootDir: () => "Nebyl poskytnut ≈æ√°dn√Ω ko≈ôenov√Ω adres√°≈ô pro sbƒõr log",
        logoNotFound: () => "Logo nenalezeno",
        logoRootDirUpdateError: (error: string) => `Do≈°lo k chybƒõ p≈ôi aktualizaci soubor≈Ø loga, chyba: ${error}`,
        logoView: () => "zobrazen√≠Loga",
        logoZoomIn: (): string => "P≈ôibl√≠≈æit",
        logoZoomOut: (): string => "Odd√°lit",
        messageNotFound: (key: string) => `Zpr√°va '${key}' nenalezena.`,
        messageWritten: () => "Zpr√°va zaps√°na",
        missingFileError: () => "Slovn√≠k jazyk≈Ø chyb√≠, p≈ôizp≈Øsoben√≠ koment√°≈ô≈Ø je deaktivov√°no.",
        missingLanguageComment: () => "Koment√°≈ô jazyka nebyl poskytnut, p≈ôi≈ôazen√≠ p≈ôeskoƒçeno.",
        morseConverted: (input: string, final: string) => `P≈ôevedeno: ${input} na ${final}`,
        morseDecoded: (input: string, final: string) => `Dek√≥dov√°no: ${input} na ${final}`,
        noActiveEditor: () => "≈Ω√°dn√Ω aktivn√≠ soubor!",
        noCommentToShow: () => "≈Ω√°dn√Ω koment√°≈ô k zobrazen√≠.",
        noFilesAvailableForLoading: (): string => "Nejsou k dispozici ≈æ√°dn√© soubory k naƒçten√≠.",
        noFocusedEditors: () => "≈Ω√°dn√© soubory nejsou ve fokus.",
        noLogoInstanceProvided: () => "Nebyla poskytnuta instance n√°hodn√©ho loga.",
        noProvidedCommentOptions: () => "Nebyly poskytnuty ≈æ√°dn√© mo≈ænosti koment√°≈ôe.",
        notFoundFilePath: (filePath: string, error: string = "Neuvedeno") => `Zadan√° cesta k souboru neexistuje: '${filePath}', chyba: '${error}'`,
        openFileToApplyHeader: () => "Otev≈ôete soubor, na kter√Ω chcete aplikovat hlaviƒçku.",
        operationCanceled: (): string => "Operace byla zru≈°ena",
        quickPickError: (err: string) => `Chyba v quickPick: ${err}`,
        quickPickNo: () => "Ne",
        quickPickYes: () => "Ano",
        ramdomLogoGatheringLogoUndefined: () => "Obsah loga nen√≠ definov√°n.",
        randomLogoGatheringFailed: (error: string) => `Shroma≈æƒèov√°n√≠ n√°hodn√©ho loga selhalo, pou≈æit√≠ v√Ωchoz√≠ho loga, chyba: "${error}"`,
        readTimeout: (timeout: number, filePath: string): string => `ƒåas pro ƒçten√≠ vypr≈°el po ${timeout}ms pro ${filePath}`,
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string) => `Hello world! P≈ô√≠pona tohoto souboru: ${fileExtension}, n√°zev: ${fileName}, cesta: ${filePath}, urƒçen√Ω jazyk: ${languageId}\n`,
        toMorseGetInput: (): string => "Zadejte pros√≠m text k p≈ôevodu",
        unknown: () => "Nezn√°m√Ω",
        unknownFileStructure: () => "Struktura slovn√≠ku jazyk≈Ø je nezn√°m√°, p≈ôizp≈Øsoben√≠ koment√°≈ô≈Ø je deaktivov√°no.",
        updateAbortedBecauseFileClosedSyncCancelled: () => "Aktualizace p≈ôeru≈°ena, proto≈æe soubor je uzav≈ôen a nebude synchronizov√°n.",
        updateEditDateMissingBounds: () => "Nelze aktualizovat hlaviƒçku: intern√≠ markery hlaviƒçky nebyly nalezeny.",
        updatingEditionDate: () => "Aktualizace data edice.",
        watermarkAuthorName: () => "Jm√©no autora",
        watermarkChosen: (watermark: string[]) => `Vodoznak k zobrazen√≠: ${JSON.stringify(watermark)}`,
        watermarkCopied: (name: string) => `ASCII umƒõn√≠ zkop√≠rov√°no pro ${name}!`,
        watermarkCopyAscii: () => "Kop√≠rovat ASCII",
        watermarkJsonFileInvalid: () => "Soubor JSON vodoznaku je pr√°zdn√Ω nebo neplatn√Ω",
        watermarkName: () => "N√°zev vodoznaku",
        watermarkNotFound: () => "Vodoznak nenalezen",
        watermarkPersonDisplayed: (name: string) => `Vodoznak '${name}' zobrazen.`,
        watermarkView: () => "zobrazen√≠Watermark",
        watermarkZoomIn: () => "P≈ôibl√≠≈æit",
        watermarkZoomOut: () => "Odd√°lit"
    },
    "hu": {
        alternateFilePathUpdated: (oldFilePath: string, newFilePath: string): string => `Az alternat√≠v el√©r√©si √∫t friss√≠tve lett: ${oldFilePath} ‚Üí ${newFilePath}.`,
        alternateLogoDirectoryNotFound: (alternateRootDirectory: string, error: string = "Nincs megadva") => `Az alternat√≠v log√≥ gy√∂k√©rk√∂nyvt√°r '${alternateRootDirectory}' nem tal√°lhat√≥, hiba: '${error}'.`,
        alternateLogoDirectoryNotProvided: () => `Nem lett megadva alternat√≠v log√≥k√∂nyvt√°r.`,
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]) => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}.`,
        brokenHeader: () => "S√©r√ºlt fejl√©c √©szlelve, √∫j besz√∫r√°sa folyamatban, k√©rj√ºk t√°vol√≠tsa el az el≈ëz≈ët.",
        cacheAlreadyLoaded: (): string => "A gyors√≠t√≥t√°r m√°r bet√∂ltve van, a t√°rolt p√©ld√°ny visszaadva.",
        chooseSingleLineCommentOption: () => "K√©rj√ºk, v√°lassza ki a k√≠v√°nt komment prefixet az al√°bbi lehet≈ës√©gek k√∂z√ºl:",
        closedDocument: () => "A dokumentum z√°rva, a m≈±veletek le√°ll√≠tva.",
        convertedContentCli: (content: string): string => `√Åtalak√≠tott tartalom: ${content}`,
        convertedContentGui: (): string => "√Åtalak√≠tott tartalom: ",
        corruptedFileMetaData: () => "A sz√ºks√©ges f√°jl metaadatok nem lettek megfelel≈ëen √∂sszegy≈±jtve, megszak√≠t√°s.",
        cwdDoesNotExist: (cwd: string) => `A megadott munkak√∂nyvt√°r ${cwd} nem l√©tezik.`,
        cwdUpdated: (oldCwd: string, newCwd: string) => `A munkak√∂nyvt√°r friss√≠tve lett: ${oldCwd} -> ${newCwd}.`,
        darlingAge: () => "Kor",
        darlingAlias: () => "Becen√©v",
        darlingCopied: (name: string) => `ASCII m≈±v√©szet m√°solva ${name} sz√°m√°ra!`,
        darlingCopyAscii: () => "M√°sol√°s ASCII",
        darlingDescription: () => "Le√≠r√°s",
        darlingHeight: () => "Magass√°g",
        darlingImage: () => "K√©p",
        darlingJsonFileInvalid: () => "A karakter JSON f√°jl √ºres vagy √©rv√©nytelen",
        darlingMoreInfo: () => "Tov√°bbi info",
        darlingPersonDisplayed: (name: string) => `Karakter '${name}' megjelen√≠tve.`,
        darlingQuote: () => "Id√©zet",
        darlingType: () => "T√≠pus",
        darlingView: () => "karakterN√©zet",
        darlingZoomIn: () => "Nagy√≠t√°s",
        darlingZoomOut: () => "Kicsiny√≠t√©s",
        documentLineScanExceeded: (maxScanLength: number) => `Az els≈ë ${maxScanLength} sor beolvasva, de nem tal√°lhat√≥ fejl√©c.`,
        emptyDocument: () => "Nincs dokumentumtartalom, amin dolgozni lehetne.",
        errorDuringFunctionCall: (functionName: string) => `Hiba t√∂rt√©nt a ${functionName} f√ºggv√©ny h√≠v√°sakor, ellen≈ërizze a napl√≥kat.`,
        extensionActivated: (moduleName: string) => `üöÄ A(z) "${moduleName}" modul most akt√≠v!`,
        fileExcludedActivationDisabled: () => "Az aktiv√°l√°s letiltva, a f√°jl a kiz√°r√°si list√°n van.",
        fileLength: (filePath: string, fileLength: number): string => `F√°jl: '${filePath}', m√©ret: ${fileLength} b√°jt.`,
        fileLoaded: (absolutePath: string) => `A f√°jl ${absolutePath} bet√∂ltve!`,
        fileLoadError: (filePath: string, error: string = "Nem megadott"): string => `A f√°jl bet√∂lt√©se sikertelen: '${filePath}'. Hiba: ${error}.`,
        fileNotFound: (filePath: string): string => `F√°jl nem tal√°lhat√≥: ${filePath}`,
        fileParseError: (filePath: string, error: string) => `A f√°jl tartalma (${filePath}) nem t√∂lthet≈ë be sikeresen. Hiba: ${error}.`,
        filepathPresenceCheck: (filePath: string): string => `F√°jl el√©rhet≈ës√©g√©nek ellen≈ërz√©se: ${filePath}`,
        filePathProcessing: (filepath: string): string => `F√°jl √∫tvonal feldolgoz√°sa: '${filepath}'.`,
        filePathUpdated: (oldFilePath: string, newFilePath: string) => `Az √∫tvonal friss√≠tve lett: ${oldFilePath} -> ${newFilePath}.`,
        fileRefreshed: () => "F√°jl tartalm√°nak friss√≠t√©se.",
        fileSaveFailed: () => "A f√°jl ment√©se sikertelen, pr√≥b√°lja √∫jra.",
        fileUnloaded: (filePath: string) => `A f√°jl ${filePath} elt√°vol√≠tva a mem√≥ri√°b√≥l.`,
        foundAlternateFilePathToLoad: (alternateFilePath: string) => `Az alternat√≠v bet√∂ltend≈ë f√°jl√∫tvonal '${alternateFilePath}'.`,
        foundAlternateLogoRootDir: (rootDir: string) => `A jelenlegi alternat√≠v log√≥ gy√∂k√©rk√∂nyvt√°r: '${rootDir}'.`,
        foundCurrentWorkingDirectory: (cwd: string) => `A jelenlegi munkak√∂nyvt√°r: '${cwd}'.`,
        foundFilePath: (filePath: string) => `A megadott f√°jl√∫tvonal l√©tezik: '${filePath}'.`,
        foundFilePathToLoad: (filePath: string) => `A bet√∂ltend≈ë f√°jl√∫tvonal '${filePath}'.`,
        foundFocusEditor: () => `Egy szerkeszt≈ë van f√≥kuszban.`,
        foundLanguageComment: () => `A nyelvi megjegyz√©sf√°jl megtal√°lhat√≥.`,
        foundLogoInstance: () => `Egy log√≥ p√©ld√°ny meg lett adva.`,
        foundLogoRootDir: (rootDir: string) => `A jelenlegi log√≥ gy√∂k√©rk√∂nyvt√°r: '${rootDir}'.`,
        foundNewLine: (newLineType: string) => `Az √∫j sor t√≠pusa: '${newLineType}'.`,
        foundWorkingDirectory: () => `A megadott munkak√∂nyvt√°r l√©tezik.`,
        fromMorseGetInput: (): string => "K√©rj√ºk, adja meg a konvert√°land√≥ sz√∂veget innen",
        getHeaderDescription: () => "Adjon meg egy le√≠r√°st: ",
        getHeaderPurpose: () => "Adja meg a f√°jl c√©lj√°t:",
        getHeaderTags: () => "Adja meg a f√°jl c√≠mk√©it, vessz≈ëvel elv√°lasztva:",
        headerInjectQuestion: () => "Nem tal√°lhat√≥ fejl√©c ebben a dokumentumban. Szeretne hozz√°adni egyet?",
        headerInjectQuestionRefused: () => "√ögy d√∂nt√∂tt, hogy nem ad hozz√° fejl√©cet a f√°jlhoz.",
        headerNotFound: () => "Nem tal√°lhat√≥ fejl√©c ebben a dokumentumban.",
        headerOpenerAndCloserFound: () => "Fejl√©c nyit√≥ √©s z√°r√≥ megtal√°lva, a d√°tum friss√≠t√©se k√∂vetkezik ellen≈ërz√©s ut√°n.",
        headerOpenerFound: () => "Fejl√©c nyit√≥ megtal√°lva.",
        headerWriteFailed: () => "Nem siker√ºlt √≠rni a fejl√©cet a f√°jlba, ellen≈ërizze a napl√≥kat.",
        headerWriteSuccess: () => "Fejl√©c sikeresen √≠rva.",
        helloWorldGreetingsCommand: (moduleName: string) => `Hello World a ${moduleName}-b√≥l!`,
        identifiedLanguage: (langName: string) => `Azonos√≠tott nyelv: ${langName}.`,
        inFunction: (functionName: string, className: string = "Nincs megadva") => `A(z) '${className}' oszt√°ly '${functionName}' f√ºggv√©ny√©ben`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string) => `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        inputboxError: (promptText: string, err: string) => `Hiba az inputBox-n√°l a(z) ${promptText} eset√©n: ${err}`,
        jsonContent: (jsonContentString: String) => `A komment JSON f√°jl tartalma: ${jsonContentString}`,
        languageNotFound: (LanguageId: string, fileExtension: string) => `A dokumentum nyelve nem azonos√≠that√≥, languageID: ${LanguageId}, f√°jlkiterjeszt√©s: ${fileExtension}`,
        lastModifiedLineNotFound: () => "A fejl√©c nem tartalmaz 'Utols√≥ m√≥dos√≠t√°s' sort a friss√≠t√©shez.",
        lastModifiedUpdated: () => "Az 'Utols√≥ m√≥dos√≠t√°s' d√°tum sikeresen friss√≠tve.",
        logoChosen: (logo: string[]) => `Megjelen√≠tend≈ë log√≥: ${JSON.stringify(logo)}`,
        logoCopied: (logoName: string) => `ASCII m≈±v√©szet m√°solva ${logoName} sz√°m√°ra!`,
        logoCopyAscii: () => "M√°sol√°s ASCII",
        logoDisplayed: (name: string) => `Log√≥ '${name}' megjelen√≠tve.`,
        logoMessage: (logoPath: string) => `F√°jl (${logoPath}) figyelmen k√≠v√ºl hagyva, mert nem a keresett t√≠pus.`,
        logoName: () => "Log√≥ neve",
        logoNoRootDir: () => "Nincs megadva gy√∂k√©rk√∂nyvt√°r a log√≥k gy≈±jt√©s√©hez",
        logoNotFound: () => "Log√≥ nem tal√°lhat√≥",
        logoRootDirUpdateError: (error: string) => `Hiba t√∂rt√©nt a log√≥f√°jlok friss√≠t√©se k√∂zben, hiba: ${error}`,
        logoView: () => "logoN√©zet",
        logoZoomIn: (): string => "Nagy√≠t√°s",
        logoZoomOut: (): string => "Kicsiny√≠t√©s",
        messageNotFound: (key: string) => `'${key}' √ºzenet nem tal√°lhat√≥.`,
        messageWritten: () => "√úzenet √≠rva",
        missingFileError: () => "A nyelvi sz√≥t√°r hi√°nyzik, a komment alkalmazkod√°s le van tiltva.",
        missingLanguageComment: () => "A nyelvi komment nem lett megadva, a hozz√°rendel√©s kihagyva.",
        morseConverted: (input: string, final: string) => `√Åtalak√≠tva: ${input} -> ${final}`,
        morseDecoded: (input: string, final: string) => `Dek√≥dolva: ${input} -> ${final}`,
        noActiveEditor: () => "Nincs akt√≠v f√°jl!",
        noCommentToShow: () => "Nincs megjelen√≠thet≈ë komment.",
        noFilesAvailableForLoading: (): string => "Nincs bet√∂lthet≈ë f√°jl.",
        noFocusedEditors: () => "Nincsenek f√≥kuszban l√©v≈ë f√°jlok.",
        noLogoInstanceProvided: () => "Nem lett log√≥ randomiz√°l√≥ p√©ld√°ny megadva.",
        noProvidedCommentOptions: () => "Nincsenek megadott komment opci√≥k.",
        notFoundFilePath: (filePath: string, error: string = "Nincs megadva") => `A megadott f√°jl√∫tvonal nem l√©tezik: '${filePath}', hiba: '${error}'`,
        openFileToApplyHeader: () => "Nyisson meg egy f√°jlt a fejl√©c alkalmaz√°s√°hoz.",
        operationCanceled: (): string => "M≈±velet megszak√≠tva",
        quickPickError: (err: string) => `Hiba a quickPick-n√°l: ${err}`,
        quickPickNo: () => "Nem",
        quickPickYes: () => "Igen",
        ramdomLogoGatheringLogoUndefined: () => "A log√≥ tartalma nem defini√°lt.",
        randomLogoGatheringFailed: (error: string) => `A v√©letlenszer≈± log√≥gy≈±jt√©s sikertelen, alap√©rtelmezett log√≥ haszn√°lata, hiba: "${error}"`,
        readTimeout: (timeout: number, filePath: string): string => `Olvas√°si id≈ëkorl√°t lej√°rt ${timeout}ms ut√°n a(z) ${filePath} f√°jlhoz`,
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string) => `Hello world! A f√°jl kiterjeszt√©se: ${fileExtension}, neve: ${fileName}, √∫tvonala: ${filePath}, nyelv: ${languageId}\n`,
        toMorseGetInput: (): string => "K√©rj√ºk, adja meg az √°talak√≠tand√≥ sz√∂veget",
        unknown: () => "Ismeretlen",
        unknownFileStructure: () => "A nyelvi sz√≥t√°r szerkezete ismeretlen, a komment alkalmazkod√°s le van tiltva.",
        updateAbortedBecauseFileClosedSyncCancelled: () => "A friss√≠t√©s megszak√≠tva, mert a f√°jl z√°rva van √©s nem lesz szinkroniz√°lva.",
        updateEditDateMissingBounds: () => "Nem siker√ºlt friss√≠teni a fejl√©cet: a bels≈ë jel√∂l≈ëk nem tal√°lhat√≥k.",
        updatingEditionDate: () => "Kiad√°s d√°tum√°nak friss√≠t√©se.",
        watermarkAuthorName: () => "Szerz≈ë neve",
        watermarkChosen: (watermark: string[]) => `Megjelen√≠tend≈ë v√≠zjel: ${JSON.stringify(watermark)}`,
        watermarkCopied: (name: string) => `ASCII m≈±v√©szet m√°solva ${name} sz√°m√°ra!`,
        watermarkCopyAscii: () => "M√°sol√°s ASCII",
        watermarkJsonFileInvalid: () => "A v√≠zjel JSON f√°jl √ºres vagy √©rv√©nytelen",
        watermarkName: () => "V√≠zjel neve",
        watermarkNotFound: () => "V√≠zjel nem tal√°lhat√≥",
        watermarkPersonDisplayed: (name: string) => `V√≠zjel '${name}' megjelen√≠tve.`,
        watermarkView: () => "v√≠zjelN√©zet",
        watermarkZoomIn: () => "Nagy√≠t√°s",
        watermarkZoomOut: () => "Kicsiny√≠t√©s"
    },
    "zh-cn": {
        alternateFilePathUpdated: (oldFilePath: string, newFilePath: string): string => `Â§áÁî®Ë∑ØÂæÑÂ∑≤‰ªé ${oldFilePath} Êõ¥Êñ∞‰∏∫ ${newFilePath}„ÄÇ`,
        alternateLogoDirectoryNotFound: (alternateRootDirectory: string, error: string = "Êú™Êèê‰æõ") => `Êú™ÊâæÂà∞Â§áÁî®ÂæΩÊ†áÊ†πÁõÆÂΩï '${alternateRootDirectory}'ÔºåÈîôËØØ: '${error}'„ÄÇ`,
        alternateLogoDirectoryNotProvided: () => `Êú™Êèê‰æõÂ§áÁî®ÂæΩÊ†áÁõÆÂΩï„ÄÇ`,
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]) => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}„ÄÇ`,
        brokenHeader: () => "Ê£ÄÊµãÂà∞Á†¥ÊçüÁöÑÂ§¥ÈÉ®ÔºåÊ≠£Âú®Ê≥®ÂÖ•Êñ∞ÁöÑÔºåËØ∑Âà†Èô§ÊóßÁöÑ„ÄÇ",
        cacheAlreadyLoaded: (): string => "ÁºìÂ≠òÂ∑≤Âä†ËΩΩÔºåËøîÂõûÂ≠òÂÇ®ÁöÑÂÆû‰æã„ÄÇ",
        chooseSingleLineCommentOption: () => "ËØ∑ÈÄâÊã©‰ª•‰∏ãÈÄâÈ°π‰∏≠ÁöÑÈ¶ñÈÄâÊ≥®ÈáäÂâçÁºÄÔºö",
        closedDocument: () => "ÊñáÊ°£Â∑≤ÂÖ≥Èó≠ÔºåÂÅúÊ≠¢Êìç‰Ωú„ÄÇ",
        convertedContentCli: (content: string): string => `ËΩ¨Êç¢ÂêéÁöÑÂÜÖÂÆπ: ${content}`,
        convertedContentGui: (): string => "ËΩ¨Êç¢ÂêéÁöÑÂÜÖÂÆπ: ",
        corruptedFileMetaData: () => "Êñá‰ª∂ÂÖÉÊï∞ÊçÆÊú™Ê≠£Á°ÆÊî∂ÈõÜÔºå‰∏≠Ê≠¢Êìç‰Ωú„ÄÇ",
        cwdDoesNotExist: (cwd: string) => `Êèê‰æõÁöÑÂ∑•‰ΩúÁõÆÂΩï ${cwd} ‰∏çÂ≠òÂú®„ÄÇ`,
        cwdUpdated: (oldCwd: string, newCwd: string) => `ÂΩìÂâçÂ∑•‰ΩúÁõÆÂΩïÂ∑≤‰ªé ${oldCwd} Êõ¥Êñ∞‰∏∫ ${newCwd}„ÄÇ`,
        darlingAge: () => "Âπ¥ÈæÑ",
        darlingAlias: () => "Âà´Âêç",
        darlingCopied: (name: string) => `${name} ÁöÑ ASCII Ëâ∫ÊúØÂ∑≤Â§çÂà∂ÔºÅ`,
        darlingCopyAscii: () => "Â§çÂà∂ ASCII",
        darlingDescription: () => "ÊèèËø∞",
        darlingHeight: () => "Ë∫´È´ò",
        darlingImage: () => "ÂõæÂÉè",
        darlingJsonFileInvalid: () => "Darling JSON Êñá‰ª∂‰∏∫Á©∫ÊàñÊó†Êïà",
        darlingMoreInfo: () => "Êõ¥Â§ö‰ø°ÊÅØ",
        darlingPersonDisplayed: (name: string) => `ËßíËâ≤ '${name}' Â∑≤ÊòæÁ§∫„ÄÇ`,
        darlingQuote: () => "ÂºïÁî®",
        darlingType: () => "Á±ªÂûã",
        darlingView: () => "ËßíËâ≤ËßÜÂõæ",
        darlingZoomIn: () => "ÊîæÂ§ß",
        darlingZoomOut: () => "Áº©Â∞è",
        documentLineScanExceeded: (maxScanLength: number) => `Êâ´ÊèèÊñá‰ª∂Ââç ${maxScanLength} Ë°åÔºå‰ΩÜÊú™ÊâæÂà∞Â§¥ÈÉ®„ÄÇ`,
        emptyDocument: () => "ÊñáÊ°£‰∏∫Á©∫ÔºåÊó†Ê≥ïÊìç‰Ωú„ÄÇ",
        errorDuringFunctionCall: (functionName: string) => `Ë∞ÉÁî®ÂáΩÊï∞ (${functionName}) Êó∂Âá∫ÈîôÔºåËØ∑Êü•ÁúãÊó•Âøó„ÄÇ`,
        extensionActivated: (moduleName: string) => `üöÄ Êâ©Â±ï "${moduleName}" Â∑≤ÊøÄÊ¥ªÔºÅ`,
        fileExcludedActivationDisabled: () => "ÊøÄÊ¥ªÂ∑≤Á¶ÅÁî®ÔºåÊñá‰ª∂Âú®ÊéíÈô§ÂàóË°®‰∏≠„ÄÇ",
        fileLength: (filePath: string, fileLength: number): string => `Êñá‰ª∂: '${filePath}'ÔºåÂ§ßÂ∞è: ${fileLength} Â≠óËäÇ„ÄÇ`,
        fileLoaded: (absolutePath: string) => `Êñá‰ª∂ ${absolutePath} Â∑≤Âä†ËΩΩÔºÅ`,
        fileLoadError: (filePath: string, error: string = "Êú™Êèê‰æõ"): string => `Êó†Ê≥ïÂä†ËΩΩÊñá‰ª∂: '${filePath}'„ÄÇÈîôËØØ: ${error}„ÄÇ`,
        fileNotFound: (filePath: string): string => `Êú™ÊâæÂà∞Êñá‰ª∂: ${filePath}`,
        fileParseError: (filePath: string, error: string) => `Êñá‰ª∂ÂÜÖÂÆπ (${filePath}) Âä†ËΩΩÂ§±Ë¥•„ÄÇÈîôËØØÔºö${error}„ÄÇ`,
        filepathPresenceCheck: (filePath: string): string => `Ê£ÄÊü•Êñá‰ª∂Ë∑ØÂæÑÂ≠òÂú®ÊÄß: ${filePath}`,
        filePathProcessing: (filepath: string): string => `Ê≠£Âú®Â§ÑÁêÜÊñá‰ª∂Ë∑ØÂæÑ: '${filepath}'„ÄÇ`,
        filePathUpdated: (oldFilePath: string, newFilePath: string) => `Ë∑ØÂæÑÂ∑≤‰ªé ${oldFilePath} Êõ¥Êñ∞‰∏∫ ${newFilePath}„ÄÇ`,
        fileRefreshed: () => "Âà∑Êñ∞Êñá‰ª∂ÂÜÖÂÆπ„ÄÇ",
        fileSaveFailed: () => "‰øùÂ≠òÊñá‰ª∂Â§±Ë¥•ÔºåËØ∑ÈáçËØï„ÄÇ",
        fileUnloaded: (filePath: string) => `Êñá‰ª∂ ${filePath} Â∑≤‰ªéÂÜÖÂ≠òÂç∏ËΩΩ„ÄÇ`,
        foundAlternateFilePathToLoad: (alternateFilePath: string) => `Ë¶ÅÂä†ËΩΩÁöÑÂ§áÁî®Êñá‰ª∂Ë∑ØÂæÑËÆæÁΩÆ‰∏∫ '${alternateFilePath}'„ÄÇ`,
        foundAlternateLogoRootDir: (rootDir: string) => `ÂΩìÂâçÂ§áÁî®ÂæΩÊ†áÊ†πÁõÆÂΩï‰∏∫: '${rootDir}'„ÄÇ`,
        foundCurrentWorkingDirectory: (cwd: string) => `ÂΩìÂâçÂ∑•‰ΩúÁõÆÂΩïËÆæÁΩÆ‰∏∫ '${cwd}'„ÄÇ`,
        foundFilePath: (filePath: string) => `Êèê‰æõÁöÑÊñá‰ª∂Ë∑ØÂæÑÂ≠òÂú®: '${filePath}'„ÄÇ`,
        foundFilePathToLoad: (filePath: string) => `Ë¶ÅÂä†ËΩΩÁöÑÊñá‰ª∂Ë∑ØÂæÑËÆæÁΩÆ‰∏∫ '${filePath}'„ÄÇ`,
        foundFocusEditor: () => `Êúâ‰∏Ä‰∏™Â§Ñ‰∫éÁÑ¶ÁÇπÁöÑÁºñËæëÂô®„ÄÇ`,
        foundLanguageComment: () => `ËØ≠Ë®ÄÊ≥®ÈáäÊñá‰ª∂Â≠òÂú®„ÄÇ`,
        foundLogoInstance: () => `Â∑≤Êèê‰æõÂæΩÊ†áÂÆû‰æã„ÄÇ`,
        foundLogoRootDir: (rootDir: string) => `ÂΩìÂâçÂæΩÊ†áÊ†πÁõÆÂΩï‰∏∫: '${rootDir}'„ÄÇ`,
        foundNewLine: (newLineType: string) => `Êñ∞Ê£ÄÊµãÂà∞ÁöÑÊç¢Ë°åÁ¨¶Á±ªÂûã‰∏∫ '${newLineType}'„ÄÇ`,
        foundWorkingDirectory: () => `Êèê‰æõÁöÑÂ∑•‰ΩúÁõÆÂΩïÂ≠òÂú®„ÄÇ`,
        fromMorseGetInput: (): string => "ËØ∑ËæìÂÖ•Ë¶Å‰ªé‰∏≠ËΩ¨Êç¢ÁöÑÊñáÊú¨",
        getHeaderDescription: () => "ËØ∑ËæìÂÖ•ÊèèËø∞Ôºö",
        getHeaderPurpose: () => "ËØ∑ËæìÂÖ•Êñá‰ª∂Áî®ÈÄîÔºö",
        getHeaderTags: () => "ËØ∑ËæìÂÖ•Êñá‰ª∂Ê†áÁ≠æÔºåÁî®ÈÄóÂè∑ÂàÜÈöîÔºö",
        headerInjectQuestion: () => "Êú™ÊâæÂà∞Â§¥ÈÉ®„ÄÇÊòØÂê¶Ê∑ªÂä†‰∏Ä‰∏™Ôºü",
        headerInjectQuestionRefused: () => "ÊÇ®ÈÄâÊã©‰∏çÂêëÊñá‰ª∂Ê∑ªÂä†Â§¥ÈÉ®„ÄÇ",
        headerNotFound: () => "Êú™ÊâæÂà∞Â§¥ÈÉ®„ÄÇ",
        headerOpenerAndCloserFound: () => "ÊâæÂà∞Â§¥ÈÉ®ÂºÄÂßãÂíåÁªìÊùüÊ†áËÆ∞ÔºåËøõË°åÊó•ÊúüÊõ¥Êñ∞ÂâçÁöÑÊ£ÄÊü•„ÄÇ",
        headerOpenerFound: () => "ÊâæÂà∞Â§¥ÈÉ®ÂºÄÂßãÊ†áËÆ∞„ÄÇ",
        headerWriteFailed: () => "ÂÜôÂÖ•Â§¥ÈÉ®Â§±Ë¥•ÔºåËØ∑Ê£ÄÊü•Êó•Âøó„ÄÇ",
        headerWriteSuccess: () => "Â§¥ÈÉ®ÂÜôÂÖ•ÊàêÂäü„ÄÇ",
        helloWorldGreetingsCommand: (moduleName: string) => `Êù•Ëá™ ${moduleName} ÁöÑ Hello WorldÔºÅ`,
        identifiedLanguage: (langName: string) => `ËØÜÂà´ÁöÑËØ≠Ë®ÄÔºö${langName}„ÄÇ`,
        inFunction: (functionName: string, className: string = "Êú™ÊåáÂÆö") => `Âú®ÂáΩÊï∞ '${functionName}' ‰∏≠ÔºàÁ±ª: '${className}'Ôºâ`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string) => `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        inputboxError: (promptText: string, err: string) => `ËæìÂÖ•Ê°ÜÈîôËØØÔºö${promptText}ÔºåÈîôËØØÔºö${err}`,
        jsonContent: (jsonContentString: String) => `ËØÑËÆ∫ JSON Êñá‰ª∂ÂÜÖÂÆπÔºö${jsonContentString}`,
        languageNotFound: (LanguageId: string, fileExtension: string) => `Êó†Ê≥ïËØÜÂà´Êñá‰ª∂ËØ≠Ë®ÄÔºålanguageID: ${LanguageId}ÔºåÊâ©Â±ïÂêçÔºö${fileExtension}`,
        lastModifiedLineNotFound: () => "Â§¥ÈÉ®‰∏≠Êú™ÊâæÂà∞‚ÄúÊúÄÂêé‰øÆÊîπ‚ÄùË°å‰ª•Êõ¥Êñ∞„ÄÇ",
        lastModifiedUpdated: () => "‚ÄúÊúÄÂêé‰øÆÊîπ‚ÄùÊó•ÊúüÂ∑≤ÊàêÂäüÊõ¥Êñ∞„ÄÇ",
        logoChosen: (logo: string[]) => `Ë¶ÅÊòæÁ§∫ÁöÑÂæΩÊ†áÔºö${JSON.stringify(logo)}`,
        logoCopied: (logoName: string) => `${logoName} ÁöÑ ASCII Ëâ∫ÊúØÂ∑≤Â§çÂà∂ÔºÅ`,
        logoCopyAscii: () => "Â§çÂà∂ ASCII",
        logoDisplayed: (name: string) => `ÂæΩÊ†á '${name}' Â∑≤ÊòæÁ§∫„ÄÇ`,
        logoMessage: (logoPath: string) => `Êñá‰ª∂ (${logoPath}) Ë¢´ÂøΩÁï•ÔºåÂõ†‰∏∫ÂÆÉ‰∏çÊòØÊàë‰ª¨ÈúÄË¶ÅÁöÑÁ±ªÂûã„ÄÇ`,
        logoName: () => "ÂæΩÊ†áÂêçÁß∞",
        logoNoRootDir: () => "Êú™Êèê‰æõÁî®‰∫éÊî∂ÈõÜÂæΩÊ†áÁöÑÊ†πÁõÆÂΩï",
        logoNotFound: () => "Êú™ÊâæÂà∞ÂæΩÊ†á",
        logoRootDirUpdateError: (error: string) => `Êõ¥Êñ∞ÂæΩÊ†áÊñá‰ª∂Êó∂Âá∫ÈîôÔºåÈîôËØØÔºö${error}`,
        logoView: () => "ÂæΩÊ†áËßÜÂõæ",
        logoZoomIn: () => "ÊîæÂ§ß",
        logoZoomOut: () => "Áº©Â∞è",
        messageNotFound: (key: string) => `Êú™ÊâæÂà∞Ê∂àÊÅØ '${key}'„ÄÇ`,
        messageWritten: () => "Ê∂àÊÅØÂ∑≤ÂÜôÂÖ•",
        missingFileError: () => "Áº∫Â∞ëËØ≠Ë®ÄÂ≠óÂÖ∏ÔºåÂõ†Ê≠§ËØÑËÆ∫ÈÄÇÈÖçË¢´Á¶ÅÁî®„ÄÇ",
        missingLanguageComment: () => "Êú™Êèê‰æõËØ≠Ë®ÄÊ≥®ÈáäÔºåË∑≥ËøáÂàÜÈÖç„ÄÇ",
        morseConverted: (input: string, final: string) => `Â∑≤ËΩ¨Êç¢Ôºö${input} -> ${final}`,
        morseDecoded: (input: string, final: string) => `Â∑≤Ëß£Á†ÅÔºö${input} -> ${final}`,
        noActiveEditor: () => "Ê≤°ÊúâÊ¥ªÂä®Êñá‰ª∂ÔºÅ",
        noCommentToShow: () => "Ê≤°ÊúâÂèØÊòæÁ§∫ÁöÑËØÑËÆ∫„ÄÇ",
        noFilesAvailableForLoading: (): string => "Ê≤°ÊúâÂèØÂä†ËΩΩÁöÑÊñá‰ª∂„ÄÇ",
        noFocusedEditors: () => "Ê≤°ÊúâÁÑ¶ÁÇπÊñá‰ª∂„ÄÇ",
        noLogoInstanceProvided: () => "Êú™Êèê‰æõÂæΩÊ†áÈöèÊú∫ÂÆû‰æã„ÄÇ",
        noProvidedCommentOptions: () => "Êú™Êèê‰æõÊ≥®ÈáäÈÄâÈ°π„ÄÇ",
        notFoundFilePath: (filePath: string, error: string = "Êú™Êèê‰æõ") => `Êèê‰æõÁöÑÊñá‰ª∂Ë∑ØÂæÑ‰∏çÂ≠òÂú®: '${filePath}'ÔºåÈîôËØØ: '${error}'`,
        openFileToApplyHeader: () => "ËØ∑ÊâìÂºÄ‰∏Ä‰∏™Êñá‰ª∂‰ª•Â∫îÁî®Â§¥ÈÉ®„ÄÇ",
        operationCanceled: (): string => "Êìç‰ΩúÂ∑≤ÂèñÊ∂à",
        quickPickError: (err: string) => `Âø´ÈÄüÈÄâÊã©ÈîôËØØÔºö${err}`,
        quickPickNo: () => "Âê¶",
        quickPickYes: () => "ÊòØ",
        ramdomLogoGatheringLogoUndefined: () => "ÂæΩÊ†áÂÜÖÂÆπÊú™ÂÆö‰πâ„ÄÇ",
        randomLogoGatheringFailed: (error: string) => `ÈöèÊú∫ÂæΩÊ†áÊî∂ÈõÜÂ§±Ë¥•Ôºå‰ΩøÁî®ÈªòËÆ§ÂæΩÊ†áÔºåÈîôËØØÔºö${error}`,
        readTimeout: (timeout: number, filePath: string): string => `ËØªÂèñË∂ÖÊó∂: ${timeout} ÊØ´ÁßíÔºåÊñá‰ª∂: ${filePath}`,
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string) => `Hello worldÔºÅÊâ©Â±ïÂêçÔºö${fileExtension}ÔºåÊñá‰ª∂ÂêçÔºö${fileName}ÔºåË∑ØÂæÑÔºö${filePath}ÔºåËØ≠Ë®ÄÔºö${languageId}\n`,
        toMorseGetInput: (): string => "ËØ∑ËæìÂÖ•Ë¶ÅËΩ¨Êç¢ÁöÑÊñáÊú¨",
        unknown: () => "Êú™Áü•",
        unknownFileStructure: () => "ËØ≠Ë®ÄÂ≠óÂÖ∏ÁªìÊûÑÊú™Áü•ÔºåÂõ†Ê≠§ËØÑËÆ∫ÈÄÇÈÖçË¢´Á¶ÅÁî®„ÄÇ",
        updateAbortedBecauseFileClosedSyncCancelled: () => "Êõ¥Êñ∞‰∏≠Ê≠¢ÔºåÂõ†‰∏∫Êñá‰ª∂Â∑≤ÂÖ≥Èó≠‰∏î‰∏ç‰ºöÂêåÊ≠•„ÄÇ",
        updateEditDateMissingBounds: () => "Êó†Ê≥ïÊõ¥Êñ∞Â§¥ÈÉ®ÔºöÊú™ÊâæÂà∞ÂÜÖÈÉ®Ê†áËÆ∞„ÄÇ",
        updatingEditionDate: () => "Êõ¥Êñ∞ÁâàÊú¨Êó•Êúü„ÄÇ",
        watermarkAuthorName: () => "‰ΩúËÄÖÂêçÁß∞",
        watermarkChosen: (watermark: string[]) => `Ë¶ÅÊòæÁ§∫ÁöÑÊ∞¥Âç∞Ôºö${JSON.stringify(watermark)}`,
        watermarkCopied: (name: string) => `${name} ÁöÑ ASCII Ëâ∫ÊúØÂ∑≤Â§çÂà∂ÔºÅ`,
        watermarkCopyAscii: () => "Â§çÂà∂ ASCII",
        watermarkJsonFileInvalid: () => "Ê∞¥Âç∞ JSON Êñá‰ª∂‰∏∫Á©∫ÊàñÊó†Êïà",
        watermarkName: () => "Ê∞¥Âç∞ÂêçÁß∞",
        watermarkNotFound: () => "Êú™ÊâæÂà∞Ê∞¥Âç∞",
        watermarkPersonDisplayed: (name: string) => `Ê∞¥Âç∞ '${name}' Â∑≤ÊòæÁ§∫„ÄÇ`,
        watermarkView: () => "Ê∞¥Âç∞ËßÜÂõæ",
        watermarkZoomIn: () => "ÊîæÂ§ß",
        watermarkZoomOut: () => "Áº©Â∞è"
    },
    "zh-tw": {
        alternateFilePathUpdated: (oldFilePath: string, newFilePath: string): string => `Êõø‰ª£Ë∑ØÂæëÂ∑≤Âæû ${oldFilePath} Êõ¥Êñ∞ÁÇ∫ ${newFilePath}„ÄÇ`,
        alternateLogoDirectoryNotFound: (alternateRootDirectory: string, error: string = "Êú™Êèê‰æõ") => `Êâæ‰∏çÂà∞Êõø‰ª£ÁöÑÊ®ôË™åÊ†πÁõÆÈåÑ '${alternateRootDirectory}'ÔºåÈåØË™§: '${error}'„ÄÇ`,
        alternateLogoDirectoryNotProvided: () => `Êú™Êèê‰æõÊõø‰ª£ÁöÑÊ®ôË™åÁõÆÈåÑ„ÄÇ`,
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]) => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}„ÄÇ`,
        brokenHeader: () => "Ê™¢Ê∏¨Âà∞Á†¥ÊêçÁöÑÈ†≠ÈÉ®ÔºåÊ≠£Âú®Ê≥®ÂÖ•Êñ∞ÁöÑÔºåË´ãÂà™Èô§ËàäÁöÑ„ÄÇ",
        cacheAlreadyLoaded: (): string => "Âø´ÂèñÂ∑≤ËºâÂÖ•ÔºåËøîÂõûÂÑ≤Â≠òÁöÑÂØ¶‰æã„ÄÇ",
        chooseSingleLineCommentOption: () => "Ë´ãÂæû‰∏ãÂàóÈÅ∏È†Ö‰∏≠ÈÅ∏ÊìáÈ¶ñÈÅ∏Ë®ªËß£ÂâçÁ∂¥Ôºö",
        closedDocument: () => "Êñá‰ª∂Â∑≤ÈóúÈñâÔºåÂÅúÊ≠¢Êìç‰Ωú„ÄÇ",
        convertedContentCli: (content: string): string => `ËΩâÊèõÂæåÁöÑÂÖßÂÆπ: ${content}`,
        convertedContentGui: (): string => "ËΩâÊèõÂæåÁöÑÂÖßÂÆπ: ",
        corruptedFileMetaData: () => "Ê™îÊ°àÂÖÉË≥áÊñôÊú™Ê≠£Á¢∫Êî∂ÈõÜÔºå‰∏≠Ê≠¢Êìç‰Ωú„ÄÇ",
        cwdDoesNotExist: (cwd: string) => `Êèê‰æõÁöÑÂ∑•‰ΩúÁõÆÈåÑ ${cwd} ‰∏çÂ≠òÂú®„ÄÇ`,
        cwdUpdated: (oldCwd: string, newCwd: string) => `Áï∂ÂâçÂ∑•‰ΩúÁõÆÈåÑÂ∑≤Âæû ${oldCwd} Êõ¥Êñ∞ÁÇ∫ ${newCwd}„ÄÇ`,
        darlingAge: () => "Âπ¥ÈΩ°",
        darlingAlias: () => "Âà•Âêç",
        darlingCopied: (name: string) => `${name} ÁöÑ ASCII ËóùË°ìÂ∑≤Ë§áË£ΩÔºÅ`,
        darlingCopyAscii: () => "Ë§áË£Ω ASCII",
        darlingDescription: () => "ÊèèËø∞",
        darlingHeight: () => "Ë∫´È´ò",
        darlingImage: () => "ÂúñÁâá",
        darlingJsonFileInvalid: () => "Darling JSON Ê™îÊ°àÁÇ∫Á©∫ÊàñÁÑ°Êïà",
        darlingMoreInfo: () => "Êõ¥Â§öË≥áË®ä",
        darlingPersonDisplayed: (name: string) => `ËßíËâ≤ '${name}' Â∑≤È°ØÁ§∫„ÄÇ`,
        darlingQuote: () => "ÂºïÁî®",
        darlingType: () => "È°ûÂûã",
        darlingView: () => "ËßíËâ≤Ê™¢Ë¶ñ",
        darlingZoomIn: () => "ÊîæÂ§ß",
        darlingZoomOut: () => "Á∏ÆÂ∞è",
        documentLineScanExceeded: (maxScanLength: number) => `ÊéÉÊèèÊ™îÊ°àÂâç ${maxScanLength} Ë°åÔºå‰ΩÜÊú™ÊâæÂà∞È†≠ÈÉ®„ÄÇ`,
        emptyDocument: () => "Êñá‰ª∂ÁÇ∫Á©∫ÔºåÁÑ°Ê≥ïÊìç‰Ωú„ÄÇ",
        errorDuringFunctionCall: (functionName: string) => `ÂëºÂè´ÂáΩÊï∏ (${functionName}) ÊôÇÁôºÁîüÈåØË™§ÔºåË´ãÊü•ÁúãÊó•Ë™å„ÄÇ`,
        extensionActivated: (moduleName: string) => `üöÄ Êì¥Â±ï "${moduleName}" Â∑≤ÂïüÂãïÔºÅ`,
        fileExcludedActivationDisabled: () => "ÂïüÁî®Â∑≤Á¶ÅÁî®ÔºåÊ™îÊ°àÂú®ÊéíÈô§Ê∏ÖÂñÆ‰∏≠„ÄÇ",
        fileLength: (filePath: string, fileLength: number): string => `Ê™îÊ°à: '${filePath}'ÔºåÂ§ßÂ∞è: ${fileLength} ‰ΩçÂÖÉÁµÑ„ÄÇ`,
        fileLoaded: (absolutePath: string) => `Ê™îÊ°à ${absolutePath} Â∑≤Âä†ËºâÔºÅ`,
        fileLoadError: (filePath: string, error: string = "Êú™Êèê‰æõ"): string => `ÁÑ°Ê≥ïËºâÂÖ•Ê™îÊ°à: '${filePath}'„ÄÇÈåØË™§: ${error}„ÄÇ`,
        fileNotFound: (filePath: string): string => `Êâæ‰∏çÂà∞Ê™îÊ°à: ${filePath}`,
        fileParseError: (filePath: string, error: string) => `Ê™îÊ°àÂÖßÂÆπ (${filePath}) Âä†ËºâÂ§±Êïó„ÄÇÈåØË™§Ôºö${error}„ÄÇ`,
        filepathPresenceCheck: (filePath: string): string => `Ê™¢Êü•Ê™îÊ°àË∑ØÂæëÂ≠òÂú®ÊÄß: ${filePath}`,
        filePathProcessing: (filepath: string): string => `ËôïÁêÜÊ™îÊ°àË∑ØÂæë: '${filepath}'„ÄÇ`,
        filePathUpdated: (oldFilePath: string, newFilePath: string) => `Ë∑ØÂæëÂ∑≤Âæû ${oldFilePath} Êõ¥Êñ∞ÁÇ∫ ${newFilePath}„ÄÇ`,
        fileRefreshed: () => "Âà∑Êñ∞Ê™îÊ°àÂÖßÂÆπ„ÄÇ",
        fileSaveFailed: () => "‰øùÂ≠òÊ™îÊ°àÂ§±ÊïóÔºåË´ãÈáçË©¶„ÄÇ",
        fileUnloaded: (filePath: string) => `Ê™îÊ°à ${filePath} Â∑≤ÂæûË®òÊÜ∂È´îÂç∏Ëºâ„ÄÇ`,
        foundAlternateFilePathToLoad: (alternateFilePath: string) => `Ë¶ÅËºâÂÖ•ÁöÑÊõø‰ª£Ê™îÊ°àË∑ØÂæëË®≠ÁÇ∫ '${alternateFilePath}'„ÄÇ`,
        foundAlternateLogoRootDir: (rootDir: string) => `ÁõÆÂâçÁöÑÊõø‰ª£Ê®ôË™åÊ†πÁõÆÈåÑÁÇ∫: '${rootDir}'„ÄÇ`,
        foundCurrentWorkingDirectory: (cwd: string) => `ÁõÆÂâçÁöÑÂ∑•‰ΩúÁõÆÈåÑË®≠ÁÇ∫ '${cwd}'„ÄÇ`,
        foundFilePath: (filePath: string) => `Êèê‰æõÁöÑÊ™îÊ°àË∑ØÂæëÂ≠òÂú®: '${filePath}'„ÄÇ`,
        foundFilePathToLoad: (filePath: string) => `Ë¶ÅËºâÂÖ•ÁöÑÊ™îÊ°àË∑ØÂæëË®≠ÁÇ∫ '${filePath}'„ÄÇ`,
        foundFocusEditor: () => `Êúâ‰∏ÄÂÄãÁ∑®ËºØÂô®ÁõÆÂâçÂú®ÁÑ¶Èªû‰∏≠„ÄÇ`,
        foundLanguageComment: () => `Ë™ûË®ÄË®ªËß£Ê™îÊ°àÂ≠òÂú®„ÄÇ`,
        foundLogoInstance: () => `Â∑≤Êèê‰æõÊ®ôË™åÂØ¶‰æã„ÄÇ`,
        foundLogoRootDir: (rootDir: string) => `ÁõÆÂâçÁöÑÊ®ôË™åÊ†πÁõÆÈåÑÁÇ∫: '${rootDir}'„ÄÇ`,
        foundNewLine: (newLineType: string) => `Êñ∞Ê™¢Ê∏¨Âà∞ÁöÑÊèõË°åÁ¨¶È°ûÂûãÁÇ∫ '${newLineType}'„ÄÇ`,
        foundWorkingDirectory: () => `Êèê‰æõÁöÑÂ∑•‰ΩúÁõÆÈåÑÂ≠òÂú®„ÄÇ`,
        fromMorseGetInput: (): string => "Ë´ãËº∏ÂÖ•Ë¶ÅÂæû‰∏≠ËΩâÊèõÁöÑÊñáÂ≠ó",
        getHeaderDescription: () => "Ë´ãÊèê‰æõÊèèËø∞Ôºö",
        getHeaderPurpose: () => "Ë´ãÊèê‰æõÊ™îÊ°àÁî®ÈÄîÔºö",
        getHeaderTags: () => "Ë´ãËº∏ÂÖ•Ê™îÊ°àÊ®ôÁ±§ÔºåÁî®ÈÄóËôüÂàÜÈöîÔºö",
        headerInjectQuestion: () => "Êú™ÊâæÂà∞È†≠ÈÉ®„ÄÇÊòØÂê¶Ê∑ªÂä†‰∏ÄÂÄãÔºü",
        headerInjectQuestionRefused: () => "ÊÇ®ÈÅ∏Êìá‰∏çÂêëÊ™îÊ°àÊ∑ªÂä†È†≠ÈÉ®„ÄÇ",
        headerNotFound: () => "Êú™ÊâæÂà∞È†≠ÈÉ®„ÄÇ",
        headerOpenerAndCloserFound: () => "ÊâæÂà∞È†≠ÈÉ®ÈñãÂßãÂíåÁµêÊùüÊ®ôË®òÔºåÈÄ≤Ë°åÊó•ÊúüÊõ¥Êñ∞ÂâçÁöÑÊ™¢Êü•„ÄÇ",
        headerOpenerFound: () => "ÊâæÂà∞È†≠ÈÉ®ÈñãÂßãÊ®ôË®ò„ÄÇ",
        headerWriteFailed: () => "ÂØ´ÂÖ•È†≠ÈÉ®Â§±ÊïóÔºåË´ãÊ™¢Êü•Êó•Ë™å„ÄÇ",
        headerWriteSuccess: () => "È†≠ÈÉ®ÂØ´ÂÖ•ÊàêÂäü„ÄÇ",
        helloWorldGreetingsCommand: (moduleName: string) => `‰æÜËá™ ${moduleName} ÁöÑ Hello WorldÔºÅ`,
        identifiedLanguage: (langName: string) => `Ë≠òÂà•ÁöÑË™ûË®ÄÔºö${langName}„ÄÇ`,
        inFunction: (functionName: string, className: string = "Êú™ÊåáÂÆö") => `Âú®ÂáΩÂºè '${functionName}' ‰∏≠ÔºàÈ°ûÂà•: '${className}'Ôºâ`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string) => `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        inputboxError: (promptText: string, err: string) => `Ëº∏ÂÖ•Ê°ÜÈåØË™§Ôºö${promptText}ÔºåÈåØË™§Ôºö${err}`,
        jsonContent: (jsonContentString: String) => `Ë®ªËß£ JSON Ê™îÊ°àÂÖßÂÆπÔºö${jsonContentString}`,
        languageNotFound: (LanguageId: string, fileExtension: string) => `ÁÑ°Ê≥ïË≠òÂà•Ê™îÊ°àË™ûË®ÄÔºålanguageID: ${LanguageId}ÔºåÂâØÊ™îÂêçÔºö${fileExtension}`,
        lastModifiedLineNotFound: () => "È†≠ÈÉ®‰∏≠Êú™ÊâæÂà∞‚ÄúÊúÄÂæå‰øÆÊîπ‚ÄùË°å‰ª•Êõ¥Êñ∞„ÄÇ",
        lastModifiedUpdated: () => "‚ÄúÊúÄÂæå‰øÆÊîπ‚ÄùÊó•ÊúüÂ∑≤ÊàêÂäüÊõ¥Êñ∞„ÄÇ",
        logoChosen: (logo: string[]) => `Ë¶ÅÈ°ØÁ§∫ÁöÑÂæΩÊ®ôÔºö${JSON.stringify(logo)}`,
        logoCopied: (logoName: string) => `${logoName} ÁöÑ ASCII ËóùË°ìÂ∑≤Ë§áË£ΩÔºÅ`,
        logoCopyAscii: () => "Ë§áË£Ω ASCII",
        logoDisplayed: (name: string) => `ÂæΩÊ®ô '${name}' Â∑≤È°ØÁ§∫„ÄÇ`,
        logoMessage: (logoPath: string) => `Ê™îÊ°à (${logoPath}) Ë¢´ÂøΩÁï•ÔºåÂõ†ÁÇ∫ÂÆÉ‰∏çÊòØÊâÄÈúÄÈ°ûÂûã„ÄÇ`,
        logoName: () => "ÂæΩÊ®ôÂêçÁ®±",
        logoNoRootDir: () => "Êú™Êèê‰æõÁî®ÊñºÊî∂ÈõÜÂæΩÊ®ôÁöÑÊ†πÁõÆÈåÑ",
        logoNotFound: () => "Êú™ÊâæÂà∞ÂæΩÊ®ô",
        logoRootDirUpdateError: (error: string) => `Êõ¥Êñ∞ÂæΩÊ®ôÊ™îÊ°àÊôÇÂá∫ÈåØÔºåÈåØË™§Ôºö${error}`,
        logoView: () => "ÂæΩÊ®ôÊ™¢Ë¶ñ",
        logoZoomIn: () => "ÊîæÂ§ß",
        logoZoomOut: () => "Á∏ÆÂ∞è",
        messageNotFound: (key: string) => `Êú™ÊâæÂà∞Ê∂àÊÅØ '${key}'„ÄÇ`,
        messageWritten: () => "Ê∂àÊÅØÂ∑≤ÂØ´ÂÖ•",
        missingFileError: () => "Áº∫Â∞ëË™ûË®ÄÂ≠óÂÖ∏ÔºåÂõ†Ê≠§Ë©ïË´ñÈÅ©ÈÖçË¢´Á¶ÅÁî®„ÄÇ",
        missingLanguageComment: () => "Êú™Êèê‰æõË™ûË®ÄË®ªËß£ÔºåË∑≥ÈÅéÂàÜÈÖç„ÄÇ",
        morseConverted: (input: string, final: string) => `Â∑≤ËΩâÊèõÔºö${input} -> ${final}`,
        morseDecoded: (input: string, final: string) => `Â∑≤Ëß£Á¢ºÔºö${input} -> ${final}`,
        noActiveEditor: () => "Ê≤íÊúâÊ¥ªÂãïÊ™îÊ°àÔºÅ",
        noCommentToShow: () => "Ê≤íÊúâÂèØÈ°ØÁ§∫ÁöÑË©ïË´ñ„ÄÇ",
        noFilesAvailableForLoading: (): string => "Ê≤íÊúâÂèØËºâÂÖ•ÁöÑÊ™îÊ°à„ÄÇ",
        noFocusedEditors: () => "Ê≤íÊúâÁÑ¶ÈªûÊ™îÊ°à„ÄÇ",
        noLogoInstanceProvided: () => "Êú™Êèê‰æõÂæΩÊ®ôÈö®Ê©üÂØ¶‰æã„ÄÇ",
        noProvidedCommentOptions: () => "Êú™Êèê‰æõË®ªËß£ÈÅ∏È†Ö„ÄÇ",
        notFoundFilePath: (filePath: string, error: string = "Êú™Êèê‰æõ") => `Êèê‰æõÁöÑÊ™îÊ°àË∑ØÂæë‰∏çÂ≠òÂú®: '${filePath}'ÔºåÈåØË™§: '${error}'`,
        openFileToApplyHeader: () => "Ë´ãÊâìÈñã‰∏ÄÂÄãÊ™îÊ°à‰ª•ÊáâÁî®È†≠ÈÉ®„ÄÇ",
        operationCanceled: (): string => "Êìç‰ΩúÂ∑≤ÂèñÊ∂à",
        quickPickError: (err: string) => `Âø´ÈÄüÈÅ∏ÊìáÈåØË™§Ôºö${err}`,
        quickPickNo: () => "Âê¶",
        quickPickYes: () => "ÊòØ",
        ramdomLogoGatheringLogoUndefined: () => "ÂæΩÊ®ôÂÖßÂÆπÊú™ÂÆöÁæ©„ÄÇ",
        randomLogoGatheringFailed: (error: string) => `Èö®Ê©üÂæΩÊ®ôÊî∂ÈõÜÂ§±ÊïóÔºå‰ΩøÁî®È†êË®≠ÂæΩÊ®ôÔºåÈåØË™§Ôºö${error}`,
        readTimeout: (timeout: number, filePath: string): string => `ËÆÄÂèñÈÄæÊôÇ: ${timeout} ÊØ´ÁßíÔºåÊ™îÊ°à: ${filePath}`,
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string) => `Hello worldÔºÅÂâØÊ™îÂêçÔºö${fileExtension}ÔºåÊ™îÂêçÔºö${fileName}ÔºåË∑ØÂæëÔºö${filePath}ÔºåË™ûË®ÄÔºö${languageId}\n`,
        toMorseGetInput: (): string => "Ë´ãËº∏ÂÖ•Ë¶ÅËΩâÊèõÁöÑÊñáÂ≠ó",
        unknown: () => "Êú™Áü•",
        unknownFileStructure: () => "Ë™ûË®ÄÂ≠óÂÖ∏ÁµêÊßãÊú™Áü•ÔºåÂõ†Ê≠§Ë©ïË´ñÈÅ©ÈÖçË¢´Á¶ÅÁî®„ÄÇ",
        updateAbortedBecauseFileClosedSyncCancelled: () => "Êõ¥Êñ∞‰∏≠Ê≠¢ÔºåÂõ†ÁÇ∫Ê™îÊ°àÂ∑≤ÈóúÈñâ‰∏î‰∏çÊúÉÂêåÊ≠•„ÄÇ",
        updateEditDateMissingBounds: () => "ÁÑ°Ê≥ïÊõ¥Êñ∞È†≠ÈÉ®ÔºöÊú™ÊâæÂà∞ÂÖßÈÉ®Ê®ôË®ò„ÄÇ",
        updatingEditionDate: () => "Êõ¥Êñ∞ÁâàÊú¨Êó•Êúü„ÄÇ",
        watermarkAuthorName: () => "‰ΩúËÄÖÂêçÁ®±",
        watermarkChosen: (watermark: string[]) => `Ë¶ÅÈ°ØÁ§∫ÁöÑÊ∞¥Âç∞Ôºö${JSON.stringify(watermark)}`,
        watermarkCopied: (name: string) => `${name} ÁöÑ ASCII ËóùË°ìÂ∑≤Ë§áË£ΩÔºÅ`,
        watermarkCopyAscii: () => "Ë§áË£Ω ASCII",
        watermarkJsonFileInvalid: () => "Ê∞¥Âç∞ JSON Ê™îÊ°àÁÇ∫Á©∫ÊàñÁÑ°Êïà",
        watermarkName: () => "Ê∞¥Âç∞ÂêçÁ®±",
        watermarkNotFound: () => "Êú™ÊâæÂà∞Ê∞¥Âç∞",
        watermarkPersonDisplayed: (name: string) => `Ê∞¥Âç∞ '${name}' Â∑≤È°ØÁ§∫„ÄÇ`,
        watermarkView: () => "Ê∞¥Âç∞Ê™¢Ë¶ñ",
        watermarkZoomIn: () => "ÊîæÂ§ß",
        watermarkZoomOut: () => "Á∏ÆÂ∞è"
    },
};
