/**
 * @file messageReference.ts
 * @brief Comprehensive multilingual message repository with advanced localization support
 * @author Henry Letellier
 * @version 1.0.4
 * @date 2025
 * 
 * This module serves as the authoritative multilingual message repository for the entire
 * AsperHeader extension ecosystem. It implements a sophisticated internationalization
 * framework that provides consistent, culturally-appropriate messaging across all user
 * interfaces, error conditions, and interactive elements while supporting dynamic
 * parameter interpolation and context-aware message generation.
 * 
 * Localization Architecture:
 * - **Multi-Language Support**: Complete translations for English, French, and Italian
 * - **Function-Based Messages**: Dynamic parameter interpolation with type safety
 * - **Cultural Adaptation**: Language-specific formatting and cultural considerations
 * - **Extensible Framework**: Plugin architecture for additional language support
 * - **Quality Assurance**: Comprehensive review process for translation accuracy
 * - **Version Synchronization**: Coordinated updates across all supported languages
 * 
 * Language Matrix:
 * - **English (en)**: Primary reference language with complete message coverage
 * - **French (fr)**: Full professional translation with cultural adaptations
 * - **Italian (it)**: Complete localization with attention to technical terminology
 * - **Extensibility**: Framework ready for additional European and global languages
 * 
 * Message Classification System:
 * - **User Interface**: Dialog prompts, button labels, and interactive elements
 * - **System Operations**: File I/O operations, configuration management, and processing
 * - **Header Management**: Template generation, metadata handling, and content creation
 * - **Error Reporting**: Comprehensive error messages with actionable guidance
 * - **Feature Content**: Specialized messages for watermarks, characters, and logos
 * - **Extension Lifecycle**: Activation, deactivation, and status communication
 * - **Development Support**: Debug messages and development-oriented information
 * 
 * Technical Implementation:
 * - **Function-Based Design**: Each message is a function enabling parameter injection
 * - **Type Safety**: TypeScript interfaces ensure parameter consistency across languages
 * - **Performance Optimization**: Lazy evaluation and efficient parameter handling
 * - **Memory Management**: Optimal memory usage with selective message loading
 * - **Error Resilience**: Graceful fallback mechanisms for missing translations
 * 
 * Parameter Interpolation Features:
 * - **Named Parameters**: `{paramName}` style parameter substitution
 * - **Positional Arguments**: Sequential parameter replacement for simple messages
 * - **Type Conversion**: Automatic type conversion and formatting
 * - **Escaping**: Security-conscious parameter escaping for HTML contexts
 * - **Pluralization**: Context-sensitive plural forms for different languages
 * - **Number Formatting**: Locale-appropriate number, currency, and date formatting
 * 
 * Quality Assurance Process:
 * - **Native Speaker Review**: All translations reviewed by native speakers
 * - **Technical Accuracy**: Technical terminology validated by subject matter experts
 * - **Cultural Sensitivity**: Messages adapted for cultural appropriateness
 * - **Consistency Checking**: Automated validation of message key completeness
 * - **Context Validation**: Messages tested in actual usage contexts
 * 
 * Integration Framework:
 * This module provides the foundation for all user-facing text throughout:
 * - **Core Extension**: Primary extension interfaces and workflows
 * - **Configuration System**: Settings descriptions and validation messages
 * - **Interactive Features**: Webview content and user interaction prompts
 * - **Error Handling**: Comprehensive error reporting and diagnostic messages
 * - **Development Tools**: Debug output and development-oriented information
 * 
 * @example Message structure and usage:
 * ```typescript
 * const messages = {
 *   en: {
 *     fileLoaded: (filename: string) => `Successfully loaded ${filename}`,
 *     operationComplete: (count: number, duration: string) => 
 *       `Processed ${count} files in ${duration}`
 *   },
 *   fr: {
 *     fileLoaded: (filename: string) => `Fichier ${filename} chargé avec succès`,
 *     operationComplete: (count: number, duration: string) => 
 *       `${count} fichiers traités en ${duration}`
 *   }
 * };
 * ```
 * 
 * @example Advanced localization features:
 * ```typescript
 * // Context-aware pluralization
 * itemCount: (count: number) => count === 1 ? "1 item" : `${count} items`,
 * 
 * // Cultural adaptations
 * dateFormat: (date: Date) => date.toLocaleDateString('en-US'),
 * 
 * // Technical terminology
 * configurationError: (setting: string, value: any) => 
 *   `Invalid configuration for ${setting}: ${value}`
 * ```
 */

/**
 * @brief Complete message dictionary for all supported languages
 * @export Exported for use by the MessageProvider system
 * 
 * Central repository of all localized messages used throughout the AsperHeader extension.
 * Each language is represented as a nested object where message keys map to functions
 * that generate the appropriate localized string. Function-based messages enable:
 * 
 * - Dynamic parameter interpolation for contextual information
 * - Type-safe parameter passing with TypeScript
 * - Consistent message formatting across languages
 * - Runtime message generation for complex scenarios
 * 
 * Message Organization:
 * - **en**: English (primary) - Complete message set serving as the reference
 * - **fr**: French - Full translation coverage with culturally appropriate phrasing
 * - **it**: Italian - Complete translations with proper Italian conventions
 * 
 * Usage Pattern:
 * ```typescript
 * messages.en.fileLoaded("/path/to/file") // Returns: "File /path/to/file loaded!"
 * messages.fr.fileLoaded("/chemin/vers/fichier") // Returns: "Fichier /chemin/vers/fichier chargé !"
 * ```
 * 
 * Message Categories:
 * - Input/Output operations (file loading, saving, parsing)
 * - User interface interactions (prompts, confirmations, selections)
 * - Header management (creation, updating, validation, injection)
 * - Feature displays (watermark, darling characters, logo showcases)
 * - Error handling (file errors, validation failures, system issues)
 * - Extension lifecycle (activation, status updates, notifications)
 * - Development utilities (debugging, logging, diagnostics)
 * 
 * @note All message functions should maintain consistent parameter signatures across languages
 * @note Missing translations will fall back to English through the MessageProvider system
 */
export const messages: Record<string, Record<string, (...args: any[]) => string>> = {
    "en": {
        inputboxError: (promptText: string, err: string): string => `Error in inputBox for ${promptText}: ${err}`,
        quickPickError: (err: string): string => `Error in quickPick: ${err}`,
        quickPickYes: (): string => "Yes",
        quickPickNo: (): string => "No",
        watermarkView: (): string => "watermarkView",
        watermarkJsonFileInvalid: (): string => "Watermark JSON file is empty or invalid",
        watermarkName: (): string => "Watermark name",
        watermarkCopyAscii: (): string => "Copy ASCII",
        watermarkZoomIn: (): string => "Zoom In",
        watermarkZoomOut: (): string => "Zoom Out",
        watermarkPersonDisplayed: (name: string): string => `Watermark '${name}' displayed.`,
        watermarkChosen: (watermark: string[]): string => `Watermark to display: ${JSON.stringify(watermark)}`,
        watermarkNotFound: (): string => "Watermark not found",
        watermarkCopied: (name: string): string => `ASCII art copied for ${name}!`,
        watermarkAuthorName: (): string => "Author name",
        darlingView: (): string => "darlingView",
        darlingJsonFileInvalid: (): string => "Darling JSON file is empty or invalid",
        darlingPersonDisplayed: (name: string): string => `Character '${name}' displayed.`,
        darlingCopyAscii: (): string => "Copy ASCII",
        darlingZoomIn: (): string => "Zoom In",
        darlingZoomOut: (): string => "Zoom Out",
        darlingType: (): string => "Type",
        darlingAge: (): string => "Age",
        darlingHeight: (): string => "Height",
        darlingAlias: (): string => "Alias",
        darlingDescription: (): string => "Description",
        darlingQuote: (): string => "Quote",
        darlingMoreInfo: (): string => "More info",
        darlingImage: (): string => "Image",
        darlingCopied: (name: string): string => `ASCII art copied for ${name}!`,
        logoView: (): string => "logoView",
        logoName: (): string => "Logo name",
        logoMessage: (logoPath: string): string => `File (${logoPath}) ignored because it is not the type we are looking for.`,
        logoNoRootDir: (): string => "No root directory was provided for gathering the logos",
        logoRootDirUpdateError: (error: string): string => `An error occurred during the update of the logo files, error: ${error}`,
        logoDisplayed: (name: string): string => `Logo '${name}' displayed.`,
        logoCopied: (logoName: string): string => `ASCII art copied for ${logoName}!`,
        logoChosen: (logo: string[]): string => `Logo to display: ${JSON.stringify(logo)}`,
        logoNotFound: (): string => "Logo not found",
        logoCopyAscii: (): string => "Copy ASCII",
        logoZoomIn: (): string => "Zoom In",
        logoZoomOut: (): string => "Zoom Out",
        noCommentToShow: (): string => "There is no comment to show.",
        unknown: (): string => "Unknown",
        headerOpenerFound: (): string => "Header opener found.",
        headerOpenerAndCloserFound: (): string => "Header opener and closer found, proceeding to date update after sanity check.",
        headerWriteFailed: (): string => "Failed to write the header to the file, check the logs.",
        headerWriteSuccess: (): string => "Header written successfully.",
        headerNotFound: (): string => "No header was found in this document.",
        headerInjectQuestion: (): string => "No header was found in this document. Would you like to add one?",
        headerInjectQuestionRefused: (): string => "You decided not to add the a header to the file.",
        morseConverted: (input: string, final: string): string => `Converted: ${input} to ${final}`,
        morseDecoded: (input: string, final: string): string => `Converted: ${input} to ${final}`,
        fileLoaded: (absolutePath: string): string => `File ${absolutePath} loaded!`,
        fileParseError: (filePath: string, error: string): string => `The file content (${filePath}) could not be loaded successfully. Error: ${error}.`,
        fileRefreshed: (): string => "Refreshing file content.",
        filePathUpdated: (oldFilePath: string, newFilePath: string): string => `The path has been updated from ${oldFilePath} to ${newFilePath}.`,
        fileUnloaded: (filePath: string): string => `File ${filePath} unloaded from memory`,
        fileExcludedActivationDisabled: (): string => "Activation disabled, the file is in the activation exclusion list.",
        fileSaveFailed: (): string => "Failed to save the file, please try saving it again.",
        cwdUpdated: (oldCwd: string, newCwd: string): string => `The current working directory referential has been updated from ${oldCwd} to ${newCwd}.`,
        cwdDoesNotExist: (cwd: string): string => `The provided current working directory ${cwd} does not exist.`,
        updatingEditionDate: (): string => "Updating the edition date.",
        documentLineScanExceeded: (maxScanLength: number): string => `Scanned the first ${maxScanLength} line(s) of the file but no header was found.`,
        closedDocument: (): string => "The document is closed, stopping operations.",
        emptyDocument: (): string => "There is no document body to work with.",
        brokenHeader: (): string => "Broken header detected, injecting new one, please remove the previous one.",
        extensionActivated: (moduleName: string): string => `🚀 "${moduleName}" is now active!`,
        helloWorldGreetingsCommand: (moduleName: string): string => `Hello World from ${moduleName}!`,
        noActiveEditor: (): string => "No active file!",
        noFocusedEditors: (): string => "There are no files in focus.",
        noLogoInstanceProvided: (): string => "No provided logo randomiser instance.",
        randomLogoGatheringFailed: (error: string): string => `The random logo gathering failed, using default logo, error: "${error}"`,
        ramdomLogoGatheringLogoUndefined: (): string => "The logo content is undefined.",
        openFileToApplyHeader: (): string => "Please open a file on which to apply the header.",
        corruptedFileMetaData: (): string => "The required file meta data appears to not have been gathered correctly, aborting.",
        messageWritten: (): string => "Message written",
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string): string => `Hello world! This file's extension is: ${fileExtension}, it's name is: ${fileName}, it's path is: ${filePath}, determined language: ${languageId}\n`,
        missingFileError: (): string => "The language dictionary is missing, comment adaptability is thus disabled.",
        unknownFileStructure: (): string => "The language dictionary structure is unknown, comment adaptability is thus disabled.",
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]): string => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}.`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string): string => `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        identifiedLanguage: (langName: string): string => `Identified language: ${langName}.`,
        errorDuringFunctionCall: (functionName: string): string => `Something went wrong during the function (${functionName}) call, check logs for more info.`,
        missingLanguageComment: (): string => "Language comment not provided, skipping assignement.",
        getHeaderDescription: (): string => "Please provide a description: ",
        getHeaderTags: (): string => "Please enter the tags for this file, separated by commas:",
        getHeaderPurpose: (): string => "Please provide the purpose of the file:",
        noProvidedCommentOptions: (): string => "There are no options that were provided.",
        chooseSingleLineCommentOption: (): string => "Please select your preferred comment prefix from the options below:",
        updateAbortedBecauseFileClosedSyncCancelled: (): string => "Update aborted because the file is closed and will thus not be synced.",
        updateEditDateMissingBounds: (): string => "Could not update the header: internal header markers were not found.",
        lastModifiedLineNotFound: (): string => "The header does not contain a 'Last Modified' line to update.",
        lastModifiedUpdated: (): string => "Last Modified' date has been updated successfully.",
        languageNotFound: (LanguageId: string, fileExtension: string): string => `The file language of this document could not be identified, languageID: ${LanguageId}, fileExtention: ${fileExtension}`,
        jsonContent: (jsonContentString: String) => `The content of the comment json file: ${jsonContentString}`,
        messageNotFound: (key: string): string => `Message '${key}' not found.`
    },
    "fr": {
        inputboxError: (promptText: string, err: string): string => `Erreur dans la boîte de saisie pour ${promptText} : ${err}`,
        quickPickError: (err: string): string => `Erreur dans quickPick : ${err}`,
        quickPickYes: (): string => "Oui",
        quickPickNo: (): string => "Non",
        noCommentToShow: (): string => "Il n’y a aucun commentaire à afficher.",
        unknown: (): string => "Inconnu",
        headerOpenerFound: (): string => "Début d’en-tête trouvé.",
        headerOpenerAndCloserFound: (): string => "Début et fin d’en-tête trouvés, mise à jour de la date après vérification.",
        headerWriteFailed: (): string => "Échec de l’écriture de l’en-tête dans le fichier, consultez les journaux.",
        headerWriteSuccess: (): string => "En-tête écrit avec succès.",
        morseConverted: (input: string, final: string): string => `Converti : ${input} en ${final}`,
        morseDecoded: (input: string, final: string): string => `Converti : ${input} en ${final}`,
        fileLoaded: (absolutePath: string): string => `Fichier ${absolutePath} chargé !`,
        fileParseError: (filePath: string, error: string): string => `Le contenu du fichier (${filePath}) n’a pas pu être chargé correctement. Erreur : ${error}.`,
        fileRefreshed: (): string => "Actualisation du contenu du fichier.",
        filePathUpdated: (oldFilePath: string, newFilePath: string): string => `Le chemin a été mis à jour de ${oldFilePath} vers ${newFilePath}.`,
        fileUnloaded: (filePath: string): string => `Fichier ${filePath} déchargé de la mémoire.`,
        cwdUpdated: (oldCwd: string, newCwd: string): string => `Le répertoire de travail a été mis à jour de ${oldCwd} vers ${newCwd}.`,
        cwdDoesNotExist: (cwd: string): string => `Le répertoire de travail fourni ${cwd} n’existe pas.`,
        updatingEditionDate: (): string => "Mise à jour de la date de modification.",
        documentLineScanExceeded: (maxScanLength: number): string => `Analyse des ${maxScanLength} premières lignes du fichier, aucun en-tête trouvé.`,
        closedDocument: (): string => "Le document est fermé, arrêt des opérations.",
        emptyDocument: (): string => "Il n’y a aucun document à traiter.",
        brokenHeader: (): string => "En-tête corrompu détecté, injection d’un nouveau, veuillez supprimer l’ancien.",
        extensionActivated: (moduleName: string): string => `🚀 L'extension « ${moduleName} » est maintenant active !`,
        helloWorldGreetingsCommand: (moduleName: string): string => `Hello World de ${moduleName} !`,
        noActiveEditor: (): string => "Aucun fichier actif !",
        noFocusedEditors: (): string => "Aucun fichier n’est en focus.",
        openFileToApplyHeader: (): string => "Veuillez ouvrir un fichier sur lequel appliquer l’en-tête.",
        corruptedFileMetaData: (): string => "Les métadonnées nécessaires du fichier n’ont pas été correctement collectées, abandon.",
        messageWritten: (): string => "Message écrit",
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string): string => `Hello world ! Extension : ${fileExtension}, nom : ${fileName}, chemin : ${filePath}, langage : ${languageId}\n`,
        missingFileError: (): string => "Le dictionnaire des langages est manquant, l’adaptabilité des commentaires est désactivée.",
        unknownFileStructure: (): string => "La structure du dictionnaire des langages est inconnue, l’adaptabilité des commentaires est désactivée.",
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]): string => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}.`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string): string => `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        identifiedLanguage: (langName: string): string => `Langage identifié : ${langName}.`,
        errorDuringFunctionCall: (functionName: string): string => `Une erreur est survenue lors de l’appel de la fonction (${functionName}), consultez les journaux.`,
        missingLanguageComment: (): string => "Commentaire de langage non fourni, assignation ignorée.",
        getHeaderDescription: (): string => "Veuillez fournir une description : ",
        getHeaderTags: (): string => "Veuillez saisir les tags de ce fichier, séparés par des virgules :",
        getHeaderPurpose: (): string => "Veuillez fournir l’objectif du fichier :",
        noProvidedCommentOptions: (): string => "Aucune option de commentaire n’a été fournie.",
        chooseSingleLineCommentOption: (): string => "Veuillez sélectionner votre préfixe de commentaire préféré parmi les options ci-dessous :",
        updateAbortedBecauseFileClosedSyncCancelled: (): string => "Mise à jour annulée car le fichier est fermé et ne sera pas synchronisé.",
        updateEditDateMissingBounds: (): string => "Impossible de mettre à jour l’en-tête : les marqueurs internes n’ont pas été trouvés.",
        lastModifiedLineNotFound: (): string => "L’en-tête ne contient pas de ligne « Dernière modification » à mettre à jour.",
        lastModifiedUpdated: (): string => "La date de « Dernière modification » a été mise à jour avec succès.",
        watermarkView: (): string => "vueWatermark",
        watermarkJsonFileInvalid: (): string => "Le fichier JSON de watermark est vide ou invalide",
        watermarkName: (): string => "Nom du watermark",
        watermarkCopyAscii: (): string => "Copier l'ASCII",
        watermarkZoomIn: (): string => "Zoomer",
        watermarkZoomOut: (): string => "Dézoomer",
        watermarkPersonDisplayed: (name: string): string => `Watermark '${name}' affiché.`,
        watermarkChosen: (watermark: string[]): string => `Watermark à afficher : ${JSON.stringify(watermark)}`,
        watermarkNotFound: (): string => "Watermark introuvable",
        watermarkCopied: (name: string): string => `Art ASCII copié pour ${name} !`,
        watermarkAuthorName: (): string => "Auteur",
        darlingView: (): string => "vueDarling",
        darlingJsonFileInvalid: (): string => "Le fichier JSON Darling est vide ou invalide",
        darlingPersonDisplayed: (name: string): string => `Personnage '${name}' affiché.`,
        darlingCopyAscii: (): string => "Copier l'ASCII",
        darlingZoomIn: (): string => "Zoomer",
        darlingZoomOut: (): string => "Dézoomer",
        darlingType: (): string => "Type",
        darlingAge: (): string => "Âge",
        darlingHeight: (): string => "Taille",
        darlingAlias: (): string => "Alias",
        darlingDescription: (): string => "Description",
        darlingQuote: (): string => "Citation",
        darlingMoreInfo: (): string => "Plus d'infos",
        darlingImage: (): string => "Image",
        darlingCopied: (name: string): string => `Art ASCII copié pour ${name} !`,
        logoView: (): string => "vueLogo",
        logoName: (): string => "Nom du logo",
        logoMessage: (logoPath: string): string => `Fichier (${logoPath}) ignoré car ce n'est pas le type recherché.`,
        logoNoRootDir: (): string => "Aucun répertoire racine fourni pour collecter les logos",
        logoRootDirUpdateError: (error: string): string => `Erreur lors de la mise à jour des fichiers de logo, erreur : ${error}`,
        logoDisplayed: (name: string): string => `Logo '${name}' affiché.`,
        logoCopied: (logoName: string): string => `Art ASCII copié pour ${logoName} !`,
        logoChosen: (logo: string[]): string => `Logo à afficher : ${JSON.stringify(logo)}`,
        logoNotFound: (): string => "Logo introuvable",
        logoCopyAscii: (): string => "Copier l'ASCII",
        logoZoomIn: (): string => "Zoomer",
        logoZoomOut: (): string => "Dézoomer",
        headerNotFound: (): string => "Aucun en-tête trouvé dans ce document.",
        headerInjectQuestion: (): string => "Aucun en-tête trouvé dans ce document. Souhaitez-vous en ajouter un ?",
        headerInjectQuestionRefused: (): string => "Vous avez décidé de ne pas ajouter d'en-tête au fichier.",
        fileExcludedActivationDisabled: (): string => "Activation désactivée, le fichier est dans la liste d'exclusion.",
        fileSaveFailed: (): string => "Échec de la sauvegarde du fichier, veuillez réessayer.",
        noLogoInstanceProvided: (): string => "Aucune instance de randomiseur de logo fournie.",
        randomLogoGatheringFailed: (error: string): string => `La collecte aléatoire de logo a échoué, utilisation du logo par défaut, erreur : "${error}"`,
        ramdomLogoGatheringLogoUndefined: (): string => "Le contenu du logo est indéfini.",
        languageNotFound: (LanguageId: string, fileExtension: string): string => `La langue du fichier de ce document n'a pas pu être identifiée, languageID : ${LanguageId}, extension du fichier : ${fileExtension}`,
        jsonContent: (jsonContentString: String) => `Contenu du fichier JSON de commentaires : ${jsonContentString}`,
        messageNotFound: (key: string): string => `Message '${key}' introuvable.`
    },
    "it": {
        inputboxError: (promptText: string, err: string): string => `Errore nella inputBox per ${promptText}: ${err}`,
        quickPickError: (err: string): string => `Errore in quickPick: ${err}`,
        quickPickYes: (): string => "Sì",
        quickPickNo: (): string => "No",
        noCommentToShow: (): string => "Non ci sono commenti da mostrare.",
        unknown: (): string => "Sconosciuto",
        headerOpenerFound: (): string => "Inizio intestazione trovato.",
        headerOpenerAndCloserFound: (): string => "Inizio e fine intestazione trovati, aggiornamento della data dopo il controllo.",
        headerWriteFailed: (): string => "Impossibile scrivere l’intestazione nel file, controlla i log.",
        headerWriteSuccess: (): string => "Intestazione scritta con successo.",
        morseConverted: (input: string, final: string): string => `Convertito: ${input} in ${final}`,
        morseDecoded: (input: string, final: string): string => `Convertito: ${input} in ${final}`,
        fileLoaded: (absolutePath: string): string => `File ${absolutePath} caricato!`,
        fileParseError: (filePath: string, error: string): string => `Il contenuto del file (${filePath}) non è stato caricato correttamente. Errore: ${error}.`,
        fileRefreshed: (): string => "Aggiornamento del contenuto del file.",
        filePathUpdated: (oldFilePath: string, newFilePath: string): string => `Il percorso è stato aggiornato da ${oldFilePath} a ${newFilePath}.`,
        fileUnloaded: (filePath: string): string => `File ${filePath} scaricato dalla memoria.`,
        cwdUpdated: (oldCwd: string, newCwd: string): string => `La directory di lavoro è stata aggiornata da ${oldCwd} a ${newCwd}.`,
        cwdDoesNotExist: (cwd: string): string => `La directory di lavoro fornita ${cwd} non esiste.`,
        updatingEditionDate: (): string => "Aggiornamento della data di modifica.",
        documentLineScanExceeded: (maxScanLength: number): string => `Analizzate le prime ${maxScanLength} righe del file, nessuna intestazione trovata.`,
        closedDocument: (): string => "Il documento è chiuso, operazioni interrotte.",
        emptyDocument: (): string => "Non c’è alcun documento su cui lavorare.",
        brokenHeader: (): string => "Intestazione danneggiata rilevata, iniezione di una nuova, si prega di rimuovere la precedente.",
        extensionActivated: (moduleName: string): string => `🚀 La tua estensione « ${moduleName} » è ora attiva!`,
        helloWorldGreetingsCommand: (moduleName: string): string => `Hello World da ${moduleName}!`,
        noActiveEditor: (): string => "Nessun file attivo!",
        noFocusedEditors: (): string => "Non ci sono file in focus.",
        openFileToApplyHeader: (): string => "Apri un file su cui applicare l’intestazione.",
        corruptedFileMetaData: (): string => "I metadati richiesti del file non sono stati raccolti correttamente, interruzione.",
        messageWritten: (): string => "Messaggio scritto",
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string): string => `Hello world! Estensione: ${fileExtension}, nome: ${fileName}, percorso: ${filePath}, linguaggio: ${languageId}\n`,
        missingFileError: (): string => "Il dizionario dei linguaggi è mancante, adattabilità dei commenti disabilitata.",
        unknownFileStructure: (): string => "La struttura del dizionario dei linguaggi è sconosciuta, adattabilità dei commenti disabilitata.",
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]): string => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}.`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string): string => `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        identifiedLanguage: (langName: string): string => `Linguaggio identificato: ${langName}.`,
        errorDuringFunctionCall: (functionName: string): string => `Qualcosa è andato storto durante la chiamata della funzione (${functionName}), controlla i log per maggiori informazioni.`,
        missingLanguageComment: (): string => "Commento del linguaggio non fornito, assegnazione ignorata.",
        getHeaderDescription: (): string => "Fornisci una descrizione: ",
        getHeaderTags: (): string => "Inserisci i tag per questo file, separati da virgole:",
        getHeaderPurpose: (): string => "Fornisci lo scopo del file:",
        noProvidedCommentOptions: (): string => "Non sono state fornite opzioni di commento.",
        chooseSingleLineCommentOption: (): string => "Seleziona il prefisso di commento preferito dalle opzioni qui sotto:",
        updateAbortedBecauseFileClosedSyncCancelled: (): string => "Aggiornamento annullato perché il file è chiuso e non sarà sincronizzato.",
        updateEditDateMissingBounds: (): string => "Impossibile aggiornare l’intestazione: marcatori interni non trovati.",
        lastModifiedLineNotFound: (): string => "L’intestazione non contiene una riga 'Ultima modifica' da aggiornare.",
        lastModifiedUpdated: (): string => "La data di 'Ultima modifica' è stata aggiornata con successo.",
        watermarkView: (): string => "vistaWatermark",
        watermarkJsonFileInvalid: (): string => "Il file JSON watermark è vuoto o non valido",
        watermarkName: (): string => "Nome watermark",
        watermarkCopyAscii: (): string => "Copia ASCII",
        watermarkZoomIn: (): string => "Ingrandisci",
        watermarkZoomOut: (): string => "Rimpicciolisci",
        watermarkPersonDisplayed: (name: string): string => `Watermark '${name}' visualizzato.`,
        watermarkChosen: (watermark: string[]): string => `Watermark da visualizzare: ${JSON.stringify(watermark)}`,
        watermarkNotFound: (): string => "Watermark non trovato",
        watermarkCopied: (name: string): string => `Arte ASCII copiata per ${name}!`,
        watermarkAuthorName: (): string => "Nome autore: ",
        darlingView: (): string => "vistaDarling",
        darlingJsonFileInvalid: (): string => "Il file JSON Darling è vuoto o non valido",
        darlingPersonDisplayed: (name: string): string => `Personaggio '${name}' visualizzato.`,
        darlingCopyAscii: (): string => "Copia ASCII",
        darlingZoomIn: (): string => "Ingrandisci",
        darlingZoomOut: (): string => "Rimpicciolisci",
        darlingType: (): string => "Tipo",
        darlingAge: (): string => "Età",
        darlingHeight: (): string => "Altezza",
        darlingAlias: (): string => "Alias",
        darlingDescription: (): string => "Descrizione",
        darlingQuote: (): string => "Citazione",
        darlingMoreInfo: (): string => "Maggiori info",
        darlingImage: (): string => "Immagine",
        darlingCopied: (name: string): string => `Arte ASCII copiata per ${name}!`,
        logoView: (): string => "vistaLogo",
        logoName: (): string => "Nome logo",
        logoMessage: (logoPath: string): string => `File (${logoPath}) ignorato perché non è del tipo cercato.`,
        logoNoRootDir: (): string => "Nessuna directory radice fornita per raccogliere i loghi",
        logoRootDirUpdateError: (error: string): string => `Errore durante l'aggiornamento dei file logo, errore: ${error}`,
        logoDisplayed: (name: string): string => `Logo '${name}' visualizzato.`,
        logoCopied: (logoName: string): string => `Arte ASCII copiata per ${logoName}!`,
        logoChosen: (logo: string[]): string => `Logo da visualizzare: ${JSON.stringify(logo)}`,
        logoNotFound: (): string => "Logo non trovato",
        logoCopyAscii: (): string => "Copia ASCII",
        logoZoomIn: (): string => "Ingrandisci",
        logoZoomOut: (): string => "Rimpicciolisci",
        headerNotFound: (): string => "Nessuna intestazione trovata in questo documento.",
        headerInjectQuestion: (): string => "Nessuna intestazione trovata in questo documento. Vuoi aggiungerne una?",
        headerInjectQuestionRefused: (): string => "Hai deciso di non aggiungere un'intestazione al file.",
        fileExcludedActivationDisabled: (): string => "Attivazione disabilitata, il file è nella lista di esclusione.",
        fileSaveFailed: (): string => "Salvataggio del file fallito, riprova a salvarlo.",
        noLogoInstanceProvided: (): string => "Nessuna istanza di randomizzatore logo fornita.",
        randomLogoGatheringFailed: (error: string): string => `La raccolta casuale del logo è fallita, uso del logo predefinito, errore: "${error}"`,
        ramdomLogoGatheringLogoUndefined: (): string => "Il contenuto del logo è indefinito.",
        languageNotFound: (LanguageId: string, fileExtension: string): string => `Non è stato possibile identificare la lingua del file di questo documento, languageID: ${LanguageId}, estensione del file: ${fileExtension}`,
        jsonContent: (jsonContentString: String) => `Contenuto del file JSON dei commenti: ${jsonContentString}`,
        messageNotFound: (key: string): string => `Messaggio '${key}' non trovato.`
    },
    "es": {
        inputboxError: (promptText: string, err: string): string => `Error en la inputBox para ${promptText}: ${err}`,
        quickPickError: (err: string): string => `Error en quickPick: ${err}`,
        quickPickYes: (): string => "Sí",
        quickPickNo: (): string => "No",
        noCommentToShow: (): string => "No hay comentarios para mostrar.",
        unknown: (): string => "Desconocido",
        headerOpenerFound: (): string => "Se encontró el inicio del encabezado.",
        headerOpenerAndCloserFound: (): string => "Inicio y fin del encabezado encontrados, actualizando la fecha tras la verificación.",
        headerWriteFailed: (): string => "Error al escribir el encabezado en el archivo, revise los registros.",
        headerWriteSuccess: (): string => "Encabezado escrito con éxito.",
        morseConverted: (input: string, final: string): string => `Convertido: ${input} a ${final}`,
        morseDecoded: (input: string, final: string): string => `Convertido: ${input} a ${final}`,
        fileLoaded: (absolutePath: string): string => `Archivo ${absolutePath} cargado!`,
        fileParseError: (filePath: string, error: string): string => `El contenido del archivo (${filePath}) no se pudo cargar correctamente. Error: ${error}.`,
        fileRefreshed: (): string => "Actualizando contenido del archivo.",
        filePathUpdated: (oldFilePath: string, newFilePath: string): string => `La ruta se actualizó de ${oldFilePath} a ${newFilePath}.`,
        fileUnloaded: (filePath: string): string => `Archivo ${filePath} descargado de la memoria.`,
        cwdUpdated: (oldCwd: string, newCwd: string): string => `El directorio de trabajo se actualizó de ${oldCwd} a ${newCwd}.`,
        cwdDoesNotExist: (cwd: string): string => `El directorio de trabajo proporcionado ${cwd} no existe.`,
        updatingEditionDate: (): string => "Actualizando la fecha de edición.",
        documentLineScanExceeded: (maxScanLength: number): string => `Se escanearon las primeras ${maxScanLength} líneas del archivo pero no se encontró encabezado.`,
        closedDocument: (): string => "El documento está cerrado, deteniendo operaciones.",
        emptyDocument: (): string => "No hay contenido en el documento.",
        brokenHeader: (): string => "Encabezado roto detectado, inyectando uno nuevo, por favor elimina el anterior.",
        extensionActivated: (moduleName: string): string => `🚀 La extensión "${moduleName}" ahora está activa!`,
        helloWorldGreetingsCommand: (moduleName: string): string => `¡Hola Mundo desde ${moduleName}!`,
        noActiveEditor: (): string => "¡No hay archivo activo!",
        noFocusedEditors: (): string => "No hay archivos enfocados.",
        openFileToApplyHeader: (): string => "Por favor, abre un archivo para aplicar el encabezado.",
        corruptedFileMetaData: (): string => "Los metadatos del archivo no se recopilaron correctamente, abortando.",
        messageWritten: (): string => "Mensaje escrito",
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string): string => `¡Hola mundo! La extensión de este archivo es: ${fileExtension}, su nombre es: ${fileName}, su ruta es: ${filePath}, lenguaje determinado: ${languageId}\n`,
        missingFileError: (): string => "Falta el diccionario de idiomas, la adaptabilidad de comentarios está deshabilitada.",
        unknownFileStructure: (): string => "La estructura del diccionario de idiomas es desconocida, la adaptabilidad de comentarios está deshabilitada.",
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]): string => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}.`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string): string => `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        identifiedLanguage: (langName: string): string => `Idioma identificado: ${langName}.`,
        errorDuringFunctionCall: (functionName: string): string => `Algo salió mal durante la llamada de la función (${functionName}), revise los registros.`,
        missingLanguageComment: (): string => "Comentario de idioma no proporcionado, omitiendo asignación.",
        getHeaderDescription: (): string => "Por favor, proporciona una descripción: ",
        getHeaderTags: (): string => "Ingrese las etiquetas para este archivo, separadas por comas:",
        getHeaderPurpose: (): string => "Proporcione el propósito del archivo:",
        noProvidedCommentOptions: (): string => "No se proporcionaron opciones de comentario.",
        chooseSingleLineCommentOption: (): string => "Seleccione su prefijo de comentario preferido de las opciones a continuación:",
        updateAbortedBecauseFileClosedSyncCancelled: (): string => "Actualización abortada porque el archivo está cerrado y no se sincronizará.",
        updateEditDateMissingBounds: (): string => "No se pudo actualizar el encabezado: no se encontraron los marcadores internos.",
        lastModifiedLineNotFound: (): string => "El encabezado no contiene una línea 'Última modificación' para actualizar.",
        lastModifiedUpdated: (): string => "La fecha de 'Última modificación' se actualizó correctamente.",
        watermarkView: (): string => "vistaMarcaAgua",
        watermarkJsonFileInvalid: (): string => "El archivo JSON de la marca de agua está vacío o es inválido",
        watermarkName: (): string => "Nombre de la marca de agua",
        watermarkCopyAscii: (): string => "Copiar ASCII",
        watermarkZoomIn: (): string => "Acercar",
        watermarkZoomOut: (): string => "Alejar",
        watermarkPersonDisplayed: (name: string): string => `Marca de agua '${name}' mostrada.`,
        watermarkChosen: (watermark: string[]): string => `Marca de agua a mostrar: ${JSON.stringify(watermark)}`,
        watermarkNotFound: (): string => "Marca de agua no encontrada",
        watermarkCopied: (name: string): string => `Arte ASCII copiado para ${name}!`,
        watermarkAuthorName: (): string => "Nombre del autor",
        darlingView: (): string => "vistaDarling",
        darlingJsonFileInvalid: (): string => "El archivo JSON de Darling está vacío o es inválido",
        darlingPersonDisplayed: (name: string): string => `Personaje '${name}' mostrado.`,
        darlingCopyAscii: (): string => "Copiar ASCII",
        darlingZoomIn: (): string => "Acercar",
        darlingZoomOut: (): string => "Alejar",
        darlingType: (): string => "Tipo",
        darlingAge: (): string => "Edad",
        darlingHeight: (): string => "Altura",
        darlingAlias: (): string => "Alias",
        darlingDescription: (): string => "Descripción",
        darlingQuote: (): string => "Cita",
        darlingMoreInfo: (): string => "Más información",
        darlingImage: (): string => "Imagen",
        darlingCopied: (name: string): string => `Arte ASCII copiado para ${name}!`,
        logoView: (): string => "vistaLogo",
        logoName: (): string => "Nombre del logo",
        logoMessage: (logoPath: string): string => `Archivo (${logoPath}) ignorado porque no es el tipo buscado.`,
        logoNoRootDir: (): string => "No se proporcionó directorio raíz para recopilar los logos",
        logoRootDirUpdateError: (error: string): string => `Ocurrió un error durante la actualización de los archivos de logo, error: ${error}`,
        logoDisplayed: (name: string): string => `Logo '${name}' mostrado.`,
        logoCopied: (logoName: string): string => `Arte ASCII copiado para ${logoName}!`,
        logoChosen: (logo: string[]): string => `Logo a mostrar: ${JSON.stringify(logo)}`,
        logoNotFound: (): string => "Logo no encontrado",
        logoCopyAscii: (): string => "Copiar ASCII",
        logoZoomIn: (): string => "Acercar",
        logoZoomOut: (): string => "Alejar",
        headerNotFound: (): string => "No se encontró encabezado en este documento.",
        headerInjectQuestion: (): string => "No se encontró encabezado en este documento. ¿Desea agregar uno?",
        headerInjectQuestionRefused: (): string => "Decidió no agregar un encabezado al archivo.",
        fileExcludedActivationDisabled: (): string => "Activación deshabilitada, el archivo está en la lista de exclusión.",
        fileSaveFailed: (): string => "No se pudo guardar el archivo, intente guardarlo nuevamente.",
        noLogoInstanceProvided: (): string => "No se proporcionó instancia de randomizador de logo.",
        randomLogoGatheringFailed: (error: string): string => `La recopilación aleatoria de logos falló, usando el logo predeterminado, error: "${error}"`,
        ramdomLogoGatheringLogoUndefined: (): string => "El contenido del logo es indefinido.",
        languageNotFound: (LanguageId: string, fileExtension: string): string => `No se pudo identificar el idioma del archivo de este documento, languageID: ${LanguageId}, extensión del archivo: ${fileExtension}`,
        jsonContent: (jsonContentString: String) => `Contenido del archivo JSON de comentarios: ${jsonContentString}`,
        messageNotFound: (key: string): string => `Mensaje '${key}' no encontrado.`
    },
    "zh-cn": {
        inputboxError: (promptText: string, err: string) => `输入框错误：${promptText}，错误：${err}`,
        quickPickError: (err: string) => `快速选择错误：${err}`,
        quickPickYes: () => "是",
        quickPickNo: () => "否",
        watermarkView: () => "水印视图",
        watermarkJsonFileInvalid: () => "水印 JSON 文件为空或无效",
        watermarkName: () => "水印名称",
        watermarkCopyAscii: () => "复制 ASCII",
        watermarkZoomIn: () => "放大",
        watermarkZoomOut: () => "缩小",
        watermarkPersonDisplayed: (name: string) => `水印 '${name}' 已显示。`,
        watermarkChosen: (watermark: string[]) => `要显示的水印：${JSON.stringify(watermark)}`,
        watermarkNotFound: () => "未找到水印",
        watermarkCopied: (name: string) => `${name} 的 ASCII 艺术已复制！`,
        watermarkAuthorName: () => "作者名称",
        darlingView: () => "角色视图",
        darlingJsonFileInvalid: () => "Darling JSON 文件为空或无效",
        darlingPersonDisplayed: (name: string) => `角色 '${name}' 已显示。`,
        darlingCopyAscii: () => "复制 ASCII",
        darlingZoomIn: () => "放大",
        darlingZoomOut: () => "缩小",
        darlingType: () => "类型",
        darlingAge: () => "年龄",
        darlingHeight: () => "身高",
        darlingAlias: () => "别名",
        darlingDescription: () => "描述",
        darlingQuote: () => "引用",
        darlingMoreInfo: () => "更多信息",
        darlingImage: () => "图像",
        darlingCopied: (name: string) => `${name} 的 ASCII 艺术已复制！`,
        logoView: () => "徽标视图",
        logoName: () => "徽标名称",
        logoMessage: (logoPath: string) => `文件 (${logoPath}) 被忽略，因为它不是我们需要的类型。`,
        logoNoRootDir: () => "未提供用于收集徽标的根目录",
        logoRootDirUpdateError: (error: string) => `更新徽标文件时出错，错误：${error}`,
        logoDisplayed: (name: string) => `徽标 '${name}' 已显示。`,
        logoCopied: (logoName: string) => `${logoName} 的 ASCII 艺术已复制！`,
        logoChosen: (logo: string[]) => `要显示的徽标：${JSON.stringify(logo)}`,
        logoNotFound: () => "未找到徽标",
        logoCopyAscii: () => "复制 ASCII",
        logoZoomIn: () => "放大",
        logoZoomOut: () => "缩小",
        noCommentToShow: () => "没有可显示的评论。",
        unknown: () => "未知",
        headerOpenerFound: () => "找到头部开始标记。",
        headerOpenerAndCloserFound: () => "找到头部开始和结束标记，进行日期更新前的检查。",
        headerWriteFailed: () => "写入头部失败，请检查日志。",
        headerWriteSuccess: () => "头部写入成功。",
        headerNotFound: () => "未找到头部。",
        headerInjectQuestion: () => "未找到头部。是否添加一个？",
        headerInjectQuestionRefused: () => "您选择不向文件添加头部。",
        morseConverted: (input: string, final: string) => `已转换：${input} -> ${final}`,
        morseDecoded: (input: string, final: string) => `已解码：${input} -> ${final}`,
        fileLoaded: (absolutePath: string) => `文件 ${absolutePath} 已加载！`,
        fileParseError: (filePath: string, error: string) => `文件内容 (${filePath}) 加载失败。错误：${error}。`,
        fileRefreshed: () => "刷新文件内容。",
        filePathUpdated: (oldFilePath: string, newFilePath: string) => `路径已从 ${oldFilePath} 更新为 ${newFilePath}。`,
        fileUnloaded: (filePath: string) => `文件 ${filePath} 已从内存卸载。`,
        fileExcludedActivationDisabled: () => "激活已禁用，文件在排除列表中。",
        fileSaveFailed: () => "保存文件失败，请重试。",
        cwdUpdated: (oldCwd: string, newCwd: string) => `当前工作目录已从 ${oldCwd} 更新为 ${newCwd}。`,
        cwdDoesNotExist: (cwd: string) => `提供的工作目录 ${cwd} 不存在。`,
        updatingEditionDate: () => "更新版本日期。",
        documentLineScanExceeded: (maxScanLength: number) => `扫描文件前 ${maxScanLength} 行，但未找到头部。`,
        closedDocument: () => "文档已关闭，停止操作。",
        emptyDocument: () => "文档为空，无法操作。",
        brokenHeader: () => "检测到破损的头部，正在注入新的，请删除旧的。",
        extensionActivated: (moduleName: string) => `🚀 扩展 "${moduleName}" 已激活！`,
        helloWorldGreetingsCommand: (moduleName: string) => `来自 ${moduleName} 的 Hello World！`,
        noActiveEditor: () => "没有活动文件！",
        noFocusedEditors: () => "没有焦点文件。",
        noLogoInstanceProvided: () => "未提供徽标随机实例。",
        randomLogoGatheringFailed: (error: string) => `随机徽标收集失败，使用默认徽标，错误：${error}`,
        ramdomLogoGatheringLogoUndefined: () => "徽标内容未定义。",
        openFileToApplyHeader: () => "请打开一个文件以应用头部。",
        corruptedFileMetaData: () => "文件元数据未正确收集，中止操作。",
        messageWritten: () => "消息已写入",
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string) => `Hello world！扩展名：${fileExtension}，文件名：${fileName}，路径：${filePath}，语言：${languageId}\n`,
        missingFileError: () => "缺少语言字典，因此评论适配被禁用。",
        unknownFileStructure: () => "语言字典结构未知，因此评论适配被禁用。",
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]) => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}。`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string) =>
            `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        identifiedLanguage: (langName: string) => `识别的语言：${langName}。`,
        errorDuringFunctionCall: (functionName: string) => `调用函数 (${functionName}) 时出错，请查看日志。`,
        missingLanguageComment: () => "未提供语言注释，跳过分配。",
        getHeaderDescription: () => "请输入描述：",
        getHeaderTags: () => "请输入文件标签，用逗号分隔：",
        getHeaderPurpose: () => "请输入文件用途：",
        noProvidedCommentOptions: () => "未提供注释选项。",
        chooseSingleLineCommentOption: () => "请选择以下选项中的首选注释前缀：",
        updateAbortedBecauseFileClosedSyncCancelled: () => "更新中止，因为文件已关闭且不会同步。",
        updateEditDateMissingBounds: () => "无法更新头部：未找到内部标记。",
        lastModifiedLineNotFound: () => "头部中未找到“最后修改”行以更新。",
        lastModifiedUpdated: () => "“最后修改”日期已成功更新。",
        languageNotFound: (LanguageId: string, fileExtension: string) => `无法识别文件语言，languageID: ${LanguageId}，扩展名：${fileExtension}`,
        jsonContent: (jsonContentString: String) => `评论 JSON 文件内容：${jsonContentString}`,
        messageNotFound: (key: string) => `未找到消息 '${key}'。`
    },
    "zh-tw": {
        inputboxError: (promptText: string, err: string) => `輸入框錯誤：${promptText}，錯誤：${err}`,
        quickPickError: (err: string) => `快速選擇錯誤：${err}`,
        quickPickYes: () => "是",
        quickPickNo: () => "否",
        watermarkView: () => "水印檢視",
        watermarkJsonFileInvalid: () => "水印 JSON 檔案為空或無效",
        watermarkName: () => "水印名稱",
        watermarkCopyAscii: () => "複製 ASCII",
        watermarkZoomIn: () => "放大",
        watermarkZoomOut: () => "縮小",
        watermarkPersonDisplayed: (name: string) => `水印 '${name}' 已顯示。`,
        watermarkChosen: (watermark: string[]) => `要顯示的水印：${JSON.stringify(watermark)}`,
        watermarkNotFound: () => "未找到水印",
        watermarkCopied: (name: string) => `${name} 的 ASCII 藝術已複製！`,
        watermarkAuthorName: () => "作者名稱",
        darlingView: () => "角色檢視",
        darlingJsonFileInvalid: () => "Darling JSON 檔案為空或無效",
        darlingPersonDisplayed: (name: string) => `角色 '${name}' 已顯示。`,
        darlingCopyAscii: () => "複製 ASCII",
        darlingZoomIn: () => "放大",
        darlingZoomOut: () => "縮小",
        darlingType: () => "類型",
        darlingAge: () => "年齡",
        darlingHeight: () => "身高",
        darlingAlias: () => "別名",
        darlingDescription: () => "描述",
        darlingQuote: () => "引用",
        darlingMoreInfo: () => "更多資訊",
        darlingImage: () => "圖片",
        darlingCopied: (name: string) => `${name} 的 ASCII 藝術已複製！`,
        logoView: () => "徽標檢視",
        logoName: () => "徽標名稱",
        logoMessage: (logoPath: string) => `檔案 (${logoPath}) 被忽略，因為它不是所需類型。`,
        logoNoRootDir: () => "未提供用於收集徽標的根目錄",
        logoRootDirUpdateError: (error: string) => `更新徽標檔案時出錯，錯誤：${error}`,
        logoDisplayed: (name: string) => `徽標 '${name}' 已顯示。`,
        logoCopied: (logoName: string) => `${logoName} 的 ASCII 藝術已複製！`,
        logoChosen: (logo: string[]) => `要顯示的徽標：${JSON.stringify(logo)}`,
        logoNotFound: () => "未找到徽標",
        logoCopyAscii: () => "複製 ASCII",
        logoZoomIn: () => "放大",
        logoZoomOut: () => "縮小",
        noCommentToShow: () => "沒有可顯示的評論。",
        unknown: () => "未知",
        headerOpenerFound: () => "找到頭部開始標記。",
        headerOpenerAndCloserFound: () => "找到頭部開始和結束標記，進行日期更新前的檢查。",
        headerWriteFailed: () => "寫入頭部失敗，請檢查日誌。",
        headerWriteSuccess: () => "頭部寫入成功。",
        headerNotFound: () => "未找到頭部。",
        headerInjectQuestion: () => "未找到頭部。是否添加一個？",
        headerInjectQuestionRefused: () => "您選擇不向檔案添加頭部。",
        morseConverted: (input: string, final: string) => `已轉換：${input} -> ${final}`,
        morseDecoded: (input: string, final: string) => `已解碼：${input} -> ${final}`,
        fileLoaded: (absolutePath: string) => `檔案 ${absolutePath} 已加載！`,
        fileParseError: (filePath: string, error: string) => `檔案內容 (${filePath}) 加載失敗。錯誤：${error}。`,
        fileRefreshed: () => "刷新檔案內容。",
        filePathUpdated: (oldFilePath: string, newFilePath: string) => `路徑已從 ${oldFilePath} 更新為 ${newFilePath}。`,
        fileUnloaded: (filePath: string) => `檔案 ${filePath} 已從記憶體卸載。`,
        fileExcludedActivationDisabled: () => "啟用已禁用，檔案在排除清單中。",
        fileSaveFailed: () => "保存檔案失敗，請重試。",
        cwdUpdated: (oldCwd: string, newCwd: string) => `當前工作目錄已從 ${oldCwd} 更新為 ${newCwd}。`,
        cwdDoesNotExist: (cwd: string) => `提供的工作目錄 ${cwd} 不存在。`,
        updatingEditionDate: () => "更新版本日期。",
        documentLineScanExceeded: (maxScanLength: number) => `掃描檔案前 ${maxScanLength} 行，但未找到頭部。`,
        closedDocument: () => "文件已關閉，停止操作。",
        emptyDocument: () => "文件為空，無法操作。",
        brokenHeader: () => "檢測到破損的頭部，正在注入新的，請刪除舊的。",
        extensionActivated: (moduleName: string) => `🚀 擴展 "${moduleName}" 已啟動！`,
        helloWorldGreetingsCommand: (moduleName: string) => `來自 ${moduleName} 的 Hello World！`,
        noActiveEditor: () => "沒有活動檔案！",
        noFocusedEditors: () => "沒有焦點檔案。",
        noLogoInstanceProvided: () => "未提供徽標隨機實例。",
        randomLogoGatheringFailed: (error: string) => `隨機徽標收集失敗，使用預設徽標，錯誤：${error}`,
        ramdomLogoGatheringLogoUndefined: () => "徽標內容未定義。",
        openFileToApplyHeader: () => "請打開一個檔案以應用頭部。",
        corruptedFileMetaData: () => "檔案元資料未正確收集，中止操作。",
        messageWritten: () => "消息已寫入",
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string) => `Hello world！副檔名：${fileExtension}，檔名：${fileName}，路徑：${filePath}，語言：${languageId}\n`,
        missingFileError: () => "缺少語言字典，因此評論適配被禁用。",
        unknownFileStructure: () => "語言字典結構未知，因此評論適配被禁用。",
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]) => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}。`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string) =>
            `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        identifiedLanguage: (langName: string) => `識別的語言：${langName}。`,
        errorDuringFunctionCall: (functionName: string) => `呼叫函數 (${functionName}) 時發生錯誤，請查看日誌。`,
        missingLanguageComment: () => "未提供語言註解，跳過分配。",
        getHeaderDescription: () => "請提供描述：",
        getHeaderTags: () => "請輸入檔案標籤，用逗號分隔：",
        getHeaderPurpose: () => "請提供檔案用途：",
        noProvidedCommentOptions: () => "未提供註解選項。",
        chooseSingleLineCommentOption: () => "請從下列選項中選擇首選註解前綴：",
        updateAbortedBecauseFileClosedSyncCancelled: () => "更新中止，因為檔案已關閉且不會同步。",
        updateEditDateMissingBounds: () => "無法更新頭部：未找到內部標記。",
        lastModifiedLineNotFound: () => "頭部中未找到“最後修改”行以更新。",
        lastModifiedUpdated: () => "“最後修改”日期已成功更新。",
        languageNotFound: (LanguageId: string, fileExtension: string) => `無法識別檔案語言，languageID: ${LanguageId}，副檔名：${fileExtension}`,
        jsonContent: (jsonContentString: String) => `註解 JSON 檔案內容：${jsonContentString}`,
        messageNotFound: (key: string) => `未找到消息 '${key}'。`
    },
    "de": {
        inputboxError: (promptText: string, err: string) => `Fehler im Eingabefeld für ${promptText}: ${err}`,
        quickPickError: (err: string) => `Fehler in QuickPick: ${err}`,
        quickPickYes: () => "Ja",
        quickPickNo: () => "Nein",
        watermarkView: () => "Wasserzeichen-Ansicht",
        watermarkJsonFileInvalid: () => "Wasserzeichen JSON-Datei ist leer oder ungültig",
        watermarkName: () => "Wasserzeichenname",
        watermarkCopyAscii: () => "ASCII kopieren",
        watermarkZoomIn: () => "Vergrößern",
        watermarkZoomOut: () => "Verkleinern",
        watermarkPersonDisplayed: (name: string) => `Wasserzeichen '${name}' angezeigt.`,
        watermarkChosen: (watermark: string[]) => `Anzuzeigendes Wasserzeichen: ${JSON.stringify(watermark)}`,
        watermarkNotFound: () => "Wasserzeichen nicht gefunden",
        watermarkCopied: (name: string) => `ASCII-Kunst für ${name} kopiert!`,
        watermarkAuthorName: () => "Autor",
        darlingView: () => "Charakter-Ansicht",
        darlingJsonFileInvalid: () => "Darling JSON-Datei ist leer oder ungültig",
        darlingPersonDisplayed: (name: string) => `Charakter '${name}' angezeigt.`,
        darlingCopyAscii: () => "ASCII kopieren",
        darlingZoomIn: () => "Vergrößern",
        darlingZoomOut: () => "Verkleinern",
        darlingType: () => "Typ",
        darlingAge: () => "Alter",
        darlingHeight: () => "Größe",
        darlingAlias: () => "Alias",
        darlingDescription: () => "Beschreibung",
        darlingQuote: () => "Zitat",
        darlingMoreInfo: () => "Weitere Infos",
        darlingImage: () => "Bild",
        darlingCopied: (name: string) => `ASCII-Kunst für ${name} kopiert!`,
        logoView: () => "Logo-Ansicht",
        logoName: () => "Logoname",
        logoMessage: (logoPath: string) => `Datei (${logoPath}) ignoriert, da sie nicht vom gesuchten Typ ist.`,
        logoNoRootDir: () => "Kein Stammverzeichnis zur Sammlung von Logos angegeben",
        logoRootDirUpdateError: (error: string) => `Fehler beim Aktualisieren der Logodateien, Fehler: ${error}`,
        logoDisplayed: (name: string) => `Logo '${name}' angezeigt.`,
        logoCopied: (logoName: string) => `ASCII-Kunst für ${logoName} kopiert!`,
        logoChosen: (logo: string[]) => `Anzuzeigendes Logo: ${JSON.stringify(logo)}`,
        logoNotFound: () => "Logo nicht gefunden",
        logoCopyAscii: () => "ASCII kopieren",
        logoZoomIn: () => "Vergrößern",
        logoZoomOut: () => "Verkleinern",
        noCommentToShow: () => "Kein Kommentar zum Anzeigen.",
        unknown: () => "Unbekannt",
        headerOpenerFound: () => "Header-Start gefunden.",
        headerOpenerAndCloserFound: () => "Header-Start und -Ende gefunden, aktualisiere das Datum nach Überprüfung.",
        headerWriteFailed: () => "Header konnte nicht in die Datei geschrieben werden, prüfen Sie die Logs.",
        headerWriteSuccess: () => "Header erfolgreich geschrieben.",
        headerNotFound: () => "Kein Header in diesem Dokument gefunden.",
        headerInjectQuestion: () => "Kein Header gefunden. Möchten Sie einen hinzufügen?",
        headerInjectQuestionRefused: () => "Sie haben entschieden, keinen Header hinzuzufügen.",
        morseConverted: (input: string, final: string) => `Konvertiert: ${input} -> ${final}`,
        morseDecoded: (input: string, final: string) => `Dekodiert: ${input} -> ${final}`,
        fileLoaded: (absolutePath: string) => `Datei ${absolutePath} geladen!`,
        fileParseError: (filePath: string, error: string) => `Dateiinhalt (${filePath}) konnte nicht erfolgreich geladen werden. Fehler: ${error}.`,
        fileRefreshed: () => "Dateiinhalt wird aktualisiert.",
        filePathUpdated: (oldFilePath: string, newFilePath: string) => `Pfad wurde von ${oldFilePath} auf ${newFilePath} aktualisiert.`,
        fileUnloaded: (filePath: string) => `Datei ${filePath} aus dem Speicher entfernt.`,
        fileExcludedActivationDisabled: () => "Aktivierung deaktiviert, Datei ist auf der Ausschlussliste.",
        fileSaveFailed: () => "Datei konnte nicht gespeichert werden, bitte erneut versuchen.",
        cwdUpdated: (oldCwd: string, newCwd: string) => `Das aktuelle Arbeitsverzeichnis wurde von ${oldCwd} auf ${newCwd} aktualisiert.`,
        cwdDoesNotExist: (cwd: string) => `Das angegebene Arbeitsverzeichnis ${cwd} existiert nicht.`,
        updatingEditionDate: () => "Aktualisiere das Erstellungsdatum.",
        documentLineScanExceeded: (maxScanLength: number) => `Erste ${maxScanLength} Zeilen der Datei gescannt, kein Header gefunden.`,
        closedDocument: () => "Das Dokument ist geschlossen, Operationen gestoppt.",
        emptyDocument: () => "Kein Dokument vorhanden.",
        brokenHeader: () => "Beschädigter Header erkannt, füge neuen Header ein, bitte vorherigen entfernen.",
        extensionActivated: (moduleName: string) => `🚀 Erweiterung "${moduleName}" ist jetzt aktiv!`,
        helloWorldGreetingsCommand: (moduleName: string) => `Hello World von ${moduleName}!`,
        noActiveEditor: () => "Keine aktive Datei!",
        noFocusedEditors: () => "Keine fokussierten Dateien.",
        noLogoInstanceProvided: () => "Keine Logo-Randomizer-Instanz bereitgestellt.",
        randomLogoGatheringFailed: (error: string) => `Zufälliges Logo konnte nicht geladen werden, Standardlogo wird verwendet, Fehler: "${error}"`,
        ramdomLogoGatheringLogoUndefined: () => "Logo-Inhalt ist undefiniert.",
        openFileToApplyHeader: () => "Bitte öffnen Sie eine Datei, um den Header anzuwenden.",
        corruptedFileMetaData: () => "Datei-Metadaten wurden nicht korrekt gesammelt, Abbruch.",
        messageWritten: () => "Nachricht geschrieben",
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string) => `Hello World! Dateiendung: ${fileExtension}, Name: ${fileName}, Pfad: ${filePath}, Sprache: ${languageId}\n`,
        missingFileError: () => "Sprachwörterbuch fehlt, Kommentar-Anpassung deaktiviert.",
        unknownFileStructure: () => "Sprachwörterbuchstruktur unbekannt, Kommentar-Anpassung deaktiviert.",
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]) => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}.`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string) =>
            `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        identifiedLanguage: (langName: string) => `Identifizierte Sprache: ${langName}.`,
        errorDuringFunctionCall: (functionName: string) => `Fehler beim Aufruf der Funktion (${functionName}), prüfen Sie die Logs.`,
        missingLanguageComment: () => "Sprachkommentar nicht bereitgestellt, Zuweisung übersprungen.",
        getHeaderDescription: () => "Bitte Beschreibung angeben:",
        getHeaderTags: () => "Bitte Tags für diese Datei eingeben, durch Kommas getrennt:",
        getHeaderPurpose: () => "Bitte Zweck der Datei angeben:",
        noProvidedCommentOptions: () => "Keine Kommentaroptionen bereitgestellt.",
        chooseSingleLineCommentOption: () => "Bitte bevorzugten Kommentarpräfix aus den Optionen unten auswählen:",
        updateAbortedBecauseFileClosedSyncCancelled: () => "Update abgebrochen, da die Datei geschlossen ist und nicht synchronisiert wird.",
        updateEditDateMissingBounds: () => "Header konnte nicht aktualisiert werden: interne Marker nicht gefunden.",
        lastModifiedLineNotFound: () => "Header enthält keine 'Zuletzt geändert'-Zeile zum Aktualisieren.",
        lastModifiedUpdated: () => "'Zuletzt geändert'-Datum erfolgreich aktualisiert.",
        languageNotFound: (LanguageId: string, fileExtension: string) => `Dateisprache konnte nicht erkannt werden, languageID: ${LanguageId}, Dateierweiterung: ${fileExtension}`,
        jsonContent: (jsonContentString: String) => `Inhalt der Kommentar-JSON-Datei: ${jsonContentString}`,
        messageNotFound: (key: string) => `Nachricht '${key}' nicht gefunden.`
    },
    "ja": {
        inputboxError: (promptText: string, err: string) => `${promptText} の入力ボックスでエラーが発生しました: ${err}`,
        quickPickError: (err: string) => `QuickPick でエラーが発生しました: ${err}`,
        quickPickYes: () => "はい",
        quickPickNo: () => "いいえ",
        watermarkView: () => "ウォーターマークビュー",
        watermarkJsonFileInvalid: () => "ウォーターマーク JSON ファイルが空または無効です",
        watermarkName: () => "ウォーターマーク名",
        watermarkCopyAscii: () => "ASCII をコピー",
        watermarkZoomIn: () => "ズームイン",
        watermarkZoomOut: () => "ズームアウト",
        watermarkPersonDisplayed: (name: string) => `ウォーターマーク '${name}' を表示しました。`,
        watermarkChosen: (watermark: string[]) => `表示するウォーターマーク: ${JSON.stringify(watermark)}`,
        watermarkNotFound: () => "ウォーターマークが見つかりません",
        watermarkCopied: (name: string) => `${name} の ASCII アートをコピーしました！`,
        watermarkAuthorName: () => "作成者名",
        darlingView: () => "キャラクタービュー",
        darlingJsonFileInvalid: () => "Darling JSON ファイルが空または無効です",
        darlingPersonDisplayed: (name: string) => `キャラクター '${name}' を表示しました。`,
        darlingCopyAscii: () => "ASCII をコピー",
        darlingZoomIn: () => "ズームイン",
        darlingZoomOut: () => "ズームアウト",
        darlingType: () => "タイプ",
        darlingAge: () => "年齢",
        darlingHeight: () => "身長",
        darlingAlias: () => "別名",
        darlingDescription: () => "説明",
        darlingQuote: () => "引用",
        darlingMoreInfo: () => "詳細情報",
        darlingImage: () => "画像",
        darlingCopied: (name: string) => `${name} の ASCII アートをコピーしました！`,
        logoView: () => "ロゴビュー",
        logoName: () => "ロゴ名",
        logoMessage: (logoPath: string) => `ファイル (${logoPath}) は対象タイプではないため無視されました。`,
        logoNoRootDir: () => "ロゴを収集するためのルートディレクトリが提供されていません",
        logoRootDirUpdateError: (error: string) => `ロゴファイルの更新中にエラーが発生しました: ${error}`,
        logoDisplayed: (name: string) => `ロゴ '${name}' を表示しました。`,
        logoCopied: (logoName: string) => `${logoName} の ASCII アートをコピーしました！`,
        logoChosen: (logo: string[]) => `表示するロゴ: ${JSON.stringify(logo)}`,
        logoNotFound: () => "ロゴが見つかりません",
        logoCopyAscii: () => "ASCII をコピー",
        noCommentToShow: () => "表示するコメントはありません。",
        unknown: () => "不明",
        headerOpenerFound: () => "ヘッダーの開始が見つかりました。",
        headerOpenerAndCloserFound: () => "ヘッダーの開始と終了が見つかりました。チェック後、日付を更新します。",
        headerWriteFailed: () => "ファイルにヘッダーを書き込めませんでした。ログを確認してください。",
        headerWriteSuccess: () => "ヘッダーを書き込みました。",
        headerNotFound: () => "このドキュメントにヘッダーが見つかりません。",
        headerInjectQuestion: () => "このドキュメントにヘッダーが見つかりません。追加しますか？",
        headerInjectQuestionRefused: () => "ファイルにヘッダーを追加しないことにしました。",
        morseConverted: (input: string, final: string) => `変換: ${input} → ${final}`,
        morseDecoded: (input: string, final: string) => `復号: ${input} → ${final}`,
        fileLoaded: (absolutePath: string) => `ファイル ${absolutePath} を読み込みました！`,
        fileParseError: (filePath: string, error: string) => `ファイルの内容 (${filePath}) を正常に読み込めませんでした。エラー: ${error}。`,
        fileRefreshed: () => "ファイル内容を更新しています。",
        filePathUpdated: (oldFilePath: string, newFilePath: string) => `パスを ${oldFilePath} から ${newFilePath} に更新しました。`,
        fileUnloaded: (filePath: string) => `ファイル ${filePath} をメモリからアンロードしました。`,
        fileExcludedActivationDisabled: () => "アクティベーションは無効です。ファイルは除外リストにあります。",
        fileSaveFailed: () => "ファイルの保存に失敗しました。もう一度保存してください。",
        cwdUpdated: (oldCwd: string, newCwd: string) => `現在の作業ディレクトリを ${oldCwd} から ${newCwd} に更新しました。`,
        cwdDoesNotExist: (cwd: string) => `指定された作業ディレクトリ ${cwd} は存在しません。`,
        updatingEditionDate: () => "編集日を更新しています。",
        documentLineScanExceeded: (maxScanLength: number) => `ファイルの最初の ${maxScanLength} 行をスキャンしましたが、ヘッダーは見つかりませんでした。`,
        closedDocument: () => "ドキュメントは閉じられました。操作を停止します。",
        emptyDocument: () => "ドキュメントの本文がありません。",
        brokenHeader: () => "壊れたヘッダーが検出されました。新しいヘッダーを挿入します。前のものを削除してください。",
        extensionActivated: (moduleName: string) => `🚀 "${moduleName}" 拡張機能がアクティブになりました！`,
        helloWorldGreetingsCommand: (moduleName: string) => `Hello World from ${moduleName}！`,
        noActiveEditor: () => "アクティブなファイルがありません！",
        noFocusedEditors: () => "フォーカスされているファイルはありません。",
        noLogoInstanceProvided: () => "提供されたロゴランダマイザーのインスタンスがありません。",
        randomLogoGatheringFailed: (error: string) => `ランダムロゴの収集に失敗しました。デフォルトロゴを使用します。エラー: "${error}"`,
        ramdomLogoGatheringLogoUndefined: () => "ロゴの内容が未定義です。",
        openFileToApplyHeader: () => "ヘッダーを適用するファイルを開いてください。",
        corruptedFileMetaData: () => "必要なファイルメタデータが正しく収集されていません。中止します。",
        messageWritten: () => "メッセージを書き込みました",
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string) =>
            `Hello World! ファイルの拡張子: ${fileExtension}, 名前: ${fileName}, パス: ${filePath}, 言語: ${languageId}\n`,
        missingFileError: () => "言語辞書がありません。コメントの適応性は無効です。",
        unknownFileStructure: () => "言語辞書の構造が不明です。コメントの適応性は無効です。",
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]) =>
            `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}。`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string) =>
            `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        identifiedLanguage: (langName: string) => `識別された言語: ${langName}。`,
        errorDuringFunctionCall: (functionName: string) => `関数 (${functionName}) の呼び出し中にエラーが発生しました。ログを確認してください。`,
        missingLanguageComment: () => "言語コメントが提供されていません。割り当てをスキップします。",
        getHeaderDescription: () => "説明を入力してください: ",
        getHeaderTags: () => "このファイルのタグをカンマで区切って入力してください: ",
        getHeaderPurpose: () => "ファイルの目的を入力してください: ",
        noProvidedCommentOptions: () => "提供されたコメントオプションはありません。",
        chooseSingleLineCommentOption: () => "以下のオプションからコメントのプレフィックスを選択してください: ",
        updateAbortedBecauseFileClosedSyncCancelled: () => "ファイルが閉じられているため、更新は中止され同期されません。",
        updateEditDateMissingBounds: () => "ヘッダーを更新できません: 内部マーカーが見つかりません。",
        lastModifiedLineNotFound: () => "ヘッダーに「最終更新日」行がありません。",
        lastModifiedUpdated: () => "「最終更新日」が正常に更新されました。",
        languageNotFound: (LanguageId: string, fileExtension: string) =>
            `このドキュメントのファイル言語を識別できません。languageID: ${LanguageId}, ファイル拡張子: ${fileExtension}`,
        jsonContent: (jsonContentString: String) => `コメント JSON ファイルの内容: ${jsonContentString}`,
        messageNotFound: (key: string) => `メッセージ '${key}' が見つかりません。`
    },
    "ko": {
        inputboxError: (promptText: string, err: string) => `${promptText} 입력 상자에서 오류 발생: ${err}`,
        quickPickError: (err: string) => `QuickPick에서 오류 발생: ${err}`,
        quickPickYes: () => "예",
        quickPickNo: () => "아니오",
        watermarkView: () => "워터마크 뷰",
        watermarkJsonFileInvalid: () => "워터마크 JSON 파일이 비어 있거나 유효하지 않습니다",
        watermarkName: () => "워터마크 이름",
        watermarkCopyAscii: () => "ASCII 복사",
        watermarkZoomIn: () => "확대",
        watermarkZoomOut: () => "축소",
        watermarkPersonDisplayed: (name: string) => `워터마크 '${name}' 표시됨.`,
        watermarkChosen: (watermark: string[]) => `표시할 워터마크: ${JSON.stringify(watermark)}`,
        watermarkNotFound: () => "워터마크를 찾을 수 없음",
        watermarkCopied: (name: string) => `${name}의 ASCII 아트가 복사되었습니다!`,
        watermarkAuthorName: () => "작성자 이름",
        darlingView: () => "캐릭터 뷰",
        darlingJsonFileInvalid: () => "Darling JSON 파일이 비어 있거나 유효하지 않습니다",
        darlingPersonDisplayed: (name: string) => `캐릭터 '${name}' 표시됨.`,
        darlingCopyAscii: () => "ASCII 복사",
        darlingZoomIn: () => "확대",
        darlingZoomOut: () => "축소",
        darlingType: () => "유형",
        darlingAge: () => "나이",
        darlingHeight: () => "키",
        darlingAlias: () => "별명",
        darlingDescription: () => "설명",
        darlingQuote: () => "인용구",
        darlingMoreInfo: () => "추가 정보",
        darlingImage: () => "이미지",
        darlingCopied: (name: string) => `${name}의 ASCII 아트가 복사되었습니다!`,
        logoView: () => "로고 뷰",
        logoName: () => "로고 이름",
        logoMessage: (logoPath: string) => `파일 (${logoPath})은(는) 원하는 유형이 아니므로 무시됩니다.`,
        logoNoRootDir: () => "로고를 수집할 루트 디렉터리가 제공되지 않았습니다",
        logoRootDirUpdateError: (error: string) => `로고 파일 업데이트 중 오류 발생: ${error}`,
        logoDisplayed: (name: string) => `로고 '${name}' 표시됨.`,
        logoCopied: (logoName: string) => `${logoName}의 ASCII 아트가 복사되었습니다!`,
        logoChosen: (logo: string[]) => `표시할 로고: ${JSON.stringify(logo)}`,
        logoNotFound: () => "로고를 찾을 수 없음",
        logoCopyAscii: () => "ASCII 복사",
        noCommentToShow: () => "표시할 주석이 없습니다.",
        unknown: () => "알 수 없음",
        headerOpenerFound: () => "헤더 시작 발견.",
        headerOpenerAndCloserFound: () => "헤더 시작 및 종료 발견, 검사 후 날짜를 업데이트합니다.",
        headerWriteFailed: () => "파일에 헤더를 쓸 수 없습니다. 로그를 확인하세요.",
        headerWriteSuccess: () => "헤더가 성공적으로 작성되었습니다.",
        headerNotFound: () => "이 문서에서 헤더를 찾을 수 없습니다.",
        headerInjectQuestion: () => "이 문서에서 헤더를 찾을 수 없습니다. 추가하시겠습니까?",
        headerInjectQuestionRefused: () => "파일에 헤더를 추가하지 않기로 결정했습니다.",
        morseConverted: (input: string, final: string) => `변환됨: ${input} → ${final}`,
        morseDecoded: (input: string, final: string) => `복호화됨: ${input} → ${final}`,
        fileLoaded: (absolutePath: string) => `파일 ${absolutePath} 로드 완료!`,
        fileParseError: (filePath: string, error: string) => `파일 내용 (${filePath})을(를) 정상적으로 로드할 수 없습니다. 오류: ${error}.`,
        fileRefreshed: () => "파일 내용을 새로 고치는 중입니다.",
        filePathUpdated: (oldFilePath: string, newFilePath: string) => `경로가 ${oldFilePath}에서 ${newFilePath}로 업데이트되었습니다.`,
        fileUnloaded: (filePath: string) => `파일 ${filePath}이(가) 메모리에서 언로드되었습니다.`,
        fileExcludedActivationDisabled: () => "활성화 비활성화됨, 파일이 제외 목록에 있습니다.",
        fileSaveFailed: () => "파일 저장 실패, 다시 시도하십시오.",
        cwdUpdated: (oldCwd: string, newCwd: string) => `현재 작업 디렉터리가 ${oldCwd}에서 ${newCwd}로 업데이트되었습니다.`,
        cwdDoesNotExist: (cwd: string) => `제공된 작업 디렉터리 ${cwd}가 존재하지 않습니다.`,
        updatingEditionDate: () => "수정일을 업데이트 중입니다.",
        documentLineScanExceeded: (maxScanLength: number) => `파일의 처음 ${maxScanLength}줄을 스캔했지만 헤더를 찾을 수 없습니다.`,
        closedDocument: () => "문서가 닫혀 있어 작업을 중단합니다.",
        emptyDocument: () => "작업할 문서 내용이 없습니다.",
        brokenHeader: () => "손상된 헤더가 감지되었습니다. 새 헤더를 삽입합니다. 이전 것을 삭제하세요.",
        extensionActivated: (moduleName: string) => `🚀 "${moduleName}" 확장이 활성화되었습니다!`,
        helloWorldGreetingsCommand: (moduleName: string) => `Hello World from ${moduleName}!`,
        noActiveEditor: () => "활성 파일이 없습니다!",
        noFocusedEditors: () => "포커스된 파일이 없습니다.",
        noLogoInstanceProvided: () => "제공된 로고 랜덤 인스턴스가 없습니다.",
        randomLogoGatheringFailed: (error: string) => `랜덤 로고 수집 실패, 기본 로고 사용, 오류: "${error}"`,
        ramdomLogoGatheringLogoUndefined: () => "로고 내용이 정의되지 않았습니다.",
        openFileToApplyHeader: () => "헤더를 적용할 파일을 열어주세요.",
        corruptedFileMetaData: () => "필요한 파일 메타데이터가 올바르게 수집되지 않았습니다. 중단합니다.",
        messageWritten: () => "메시지 작성 완료",
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string) =>
            `Hello World! 파일 확장자: ${fileExtension}, 이름: ${fileName}, 경로: ${filePath}, 언어: ${languageId}\n`,
        missingFileError: () => "언어 사전이 없습니다. 주석 적응 기능이 비활성화됩니다.",
        unknownFileStructure: () => "언어 사전 구조를 알 수 없습니다. 주석 적응 기능이 비활성화됩니다.",
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]) => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}.`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string) =>
            `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        identifiedLanguage: (langName: string) => `식별된 언어: ${langName}.`,
        errorDuringFunctionCall: (functionName: string) => `함수 (${functionName}) 호출 중 오류가 발생했습니다. 로그를 확인하세요.`,
        missingLanguageComment: () => "언어 주석이 제공되지 않았습니다. 할당을 건너뜁니다.",
        getHeaderDescription: () => "설명을 입력하세요: ",
        getHeaderTags: () => "이 파일의 태그를 쉼표로 구분하여 입력하세요: ",
        getHeaderPurpose: () => "파일의 목적을 입력하세요: ",
        noProvidedCommentOptions: () => "제공된 주석 옵션이 없습니다.",
        chooseSingleLineCommentOption: () => "아래 옵션에서 원하는 주석 접두사를 선택하세요: ",
        updateAbortedBecauseFileClosedSyncCancelled: () => "파일이 닫혀 있어 업데이트가 중단되었으며 동기화되지 않습니다.",
        updateEditDateMissingBounds: () => "헤더를 업데이트할 수 없습니다: 내부 마커를 찾을 수 없습니다.",
        lastModifiedLineNotFound: () => "헤더에 '마지막 수정일' 라인이 없습니다.",
        lastModifiedUpdated: () => "'마지막 수정일'이 성공적으로 업데이트되었습니다.",
        languageNotFound: (LanguageId: string, fileExtension: string) => `이 문서의 파일 언어를 식별할 수 없습니다. languageID: ${LanguageId}, 파일 확장자: ${fileExtension}`,
        jsonContent: (jsonContentString: String) => `주석 JSON 파일 내용: ${jsonContentString}`,
        messageNotFound: (key: string) => `메시지 '${key}'를 찾을 수 없습니다.`
    },
    "ru": {
        inputboxError: (promptText: string, err: string) => `Ошибка в поле ввода для ${promptText}: ${err}`,
        quickPickError: (err: string) => `Ошибка в quickPick: ${err}`,
        quickPickYes: () => "Да",
        quickPickNo: () => "Нет",
        watermarkView: () => "просмотр водяного знака",
        watermarkJsonFileInvalid: () => "Файл JSON водяного знака пуст или недействителен",
        watermarkName: () => "Название водяного знака",
        watermarkCopyAscii: () => "Скопировать ASCII",
        watermarkZoomIn: () => "Увеличить",
        watermarkZoomOut: () => "Уменьшить",
        watermarkPersonDisplayed: (name: string) => `Водяной знак '${name}' отображен.`,
        watermarkChosen: (watermark: string[]) => `Выбранный водяной знак: ${JSON.stringify(watermark)}`,
        watermarkNotFound: () => "Водяной знак не найден",
        watermarkCopied: (name: string) => `ASCII-арт для ${name} скопирован!`,
        watermarkAuthorName: () => "Имя автора",
        darlingView: () => "просмотр персонажа",
        darlingJsonFileInvalid: () => "Файл JSON персонажа пуст или недействителен",
        darlingPersonDisplayed: (name: string) => `Персонаж '${name}' отображен.`,
        darlingCopyAscii: () => "Скопировать ASCII",
        darlingZoomIn: () => "Увеличить",
        darlingZoomOut: () => "Уменьшить",
        darlingType: () => "Тип",
        darlingAge: () => "Возраст",
        darlingHeight: () => "Рост",
        darlingAlias: () => "Псевдоним",
        darlingDescription: () => "Описание",
        darlingQuote: () => "Цитата",
        darlingMoreInfo: () => "Доп. информация",
        darlingImage: () => "Изображение",
        darlingCopied: (name: string) => `ASCII-арт для ${name} скопирован!`,
        logoView: () => "просмотр логотипа",
        logoName: () => "Название логотипа",
        logoMessage: (logoPath: string) => `Файл (${logoPath}) проигнорирован, так как это не нужный тип.`,
        logoNoRootDir: () => "Не предоставлен корневой каталог для сбора логотипов",
        logoRootDirUpdateError: (error: string) => `Ошибка при обновлении файлов логотипа: ${error}`,
        logoDisplayed: (name: string) => `Логотип '${name}' отображен.`,
        logoCopied: (logoName: string) => `ASCII-арт для ${logoName} скопирован!`,
        logoChosen: (logo: string[]) => `Выбранный логотип: ${JSON.stringify(logo)}`,
        logoNotFound: () => "Логотип не найден",
        logoCopyAscii: () => "Скопировать ASCII",
        noCommentToShow: () => "Нет комментариев для отображения.",
        unknown: () => "Неизвестно",
        headerOpenerFound: () => "Начало заголовка найдено.",
        headerOpenerAndCloserFound: () => "Начало и конец заголовка найдены, выполняется обновление даты после проверки.",
        headerWriteFailed: () => "Не удалось записать заголовок в файл, проверьте логи.",
        headerWriteSuccess: () => "Заголовок успешно записан.",
        headerNotFound: () => "Заголовок в этом документе не найден.",
        headerInjectQuestion: () => "Заголовок в этом документе не найден. Хотите добавить его?",
        headerInjectQuestionRefused: () => "Вы решили не добавлять заголовок в файл.",
        morseConverted: (input: string, final: string) => `Преобразовано: ${input} → ${final}`,
        morseDecoded: (input: string, final: string) => `Декодировано: ${input} → ${final}`,
        fileLoaded: (absolutePath: string) => `Файл ${absolutePath} загружен!`,
        fileParseError: (filePath: string, error: string) => `Содержимое файла (${filePath}) не удалось загрузить. Ошибка: ${error}.`,
        fileRefreshed: () => "Обновление содержимого файла.",
        filePathUpdated: (oldFilePath: string, newFilePath: string) => `Путь обновлен с ${oldFilePath} на ${newFilePath}.`,
        fileUnloaded: (filePath: string) => `Файл ${filePath} выгружен из памяти.`,
        fileExcludedActivationDisabled: () => "Активация отключена, файл находится в списке исключений.",
        fileSaveFailed: () => "Не удалось сохранить файл, попробуйте снова.",
        cwdUpdated: (oldCwd: string, newCwd: string) => `Текущий рабочий каталог обновлен с ${oldCwd} на ${newCwd}.`,
        cwdDoesNotExist: (cwd: string) => `Указанный рабочий каталог ${cwd} не существует.`,
        updatingEditionDate: () => "Обновление даты редактирования.",
        documentLineScanExceeded: (maxScanLength: number) => `Просканировано первые ${maxScanLength} строки файла, заголовок не найден.`,
        closedDocument: () => "Документ закрыт, операция остановлена.",
        emptyDocument: () => "Нет содержимого документа для работы.",
        brokenHeader: () => "Обнаружен поврежденный заголовок, вставляется новый, удалите предыдущий.",
        extensionActivated: (moduleName: string) => `🚀 Расширение "${moduleName}" теперь активно!`,
        helloWorldGreetingsCommand: (moduleName: string) => `Hello World из ${moduleName}!`,
        noActiveEditor: () => "Нет активного файла!",
        noFocusedEditors: () => "Нет файлов в фокусе.",
        noLogoInstanceProvided: () => "Не предоставлен экземпляр рандомизатора логотипа.",
        randomLogoGatheringFailed: (error: string) => `Сбор случайного логотипа не удался, используется логотип по умолчанию, ошибка: "${error}"`,
        ramdomLogoGatheringLogoUndefined: () => "Содержимое логотипа неопределено.",
        openFileToApplyHeader: () => "Пожалуйста, откройте файл, чтобы применить заголовок.",
        corruptedFileMetaData: () => "Не удалось корректно собрать необходимые метаданные файла, прерывание.",
        messageWritten: () => "Сообщение записано",
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string) =>
            `Hello World! Расширение файла: ${fileExtension}, имя: ${fileName}, путь: ${filePath}, язык: ${languageId}\n`,
        missingFileError: () => "Словарь языка отсутствует, адаптация комментариев отключена.",
        unknownFileStructure: () => "Структура словаря языка неизвестна, адаптация комментариев отключена.",
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]) => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}.`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string) =>
            `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        identifiedLanguage: (langName: string) => `Определенный язык: ${langName}.`,
        errorDuringFunctionCall: (functionName: string) => `Произошла ошибка при вызове функции (${functionName}), проверьте логи.`,
        missingLanguageComment: () => "Комментарий для языка не предоставлен, пропуск присвоения.",
        getHeaderDescription: () => "Пожалуйста, предоставьте описание: ",
        getHeaderTags: () => "Введите теги для этого файла через запятую: ",
        getHeaderPurpose: () => "Пожалуйста, укажите назначение файла: ",
        noProvidedCommentOptions: () => "Нет предоставленных опций комментариев.",
        chooseSingleLineCommentOption: () => "Пожалуйста, выберите предпочитаемый префикс комментария из предложенных вариантов: ",
        updateAbortedBecauseFileClosedSyncCancelled: () => "Обновление прервано, так как файл закрыт и не будет синхронизирован.",
        updateEditDateMissingBounds: () => "Не удалось обновить заголовок: внутренние маркеры не найдены.",
        lastModifiedLineNotFound: () => "В заголовке отсутствует строка 'Последнее изменение' для обновления.",
        lastModifiedUpdated: () => "Дата 'Последнее изменение' успешно обновлена.",
        languageNotFound: (LanguageId: string, fileExtension: string) => `Не удалось определить язык файла этого документа, languageID: ${LanguageId}, расширение файла: ${fileExtension}`,
        jsonContent: (jsonContentString: String) => `Содержимое JSON-файла комментариев: ${jsonContentString}`,
        messageNotFound: (key: string) => `Сообщение '${key}' не найдено.`
    },
    "pt-br": {
        inputboxError: (promptText: string, err: string) => `Erro na caixa de entrada para ${promptText}: ${err}`,
        quickPickError: (err: string) => `Erro no quickPick: ${err}`,
        quickPickYes: () => "Sim",
        quickPickNo: () => "Não",
        watermarkView: () => "visualização da marca d'água",
        watermarkJsonFileInvalid: () => "O arquivo JSON da marca d'água está vazio ou inválido",
        watermarkName: () => "Nome da marca d'água",
        watermarkCopyAscii: () => "Copiar ASCII",
        watermarkZoomIn: () => "Aumentar zoom",
        watermarkZoomOut: () => "Diminuir zoom",
        watermarkPersonDisplayed: (name: string) => `Marca d'água '${name}' exibida.`,
        watermarkChosen: (watermark: string[]) => `Marca d'água a ser exibida: ${JSON.stringify(watermark)}`,
        watermarkNotFound: () => "Marca d'água não encontrada",
        watermarkCopied: (name: string) => `ASCII art copiado para ${name}!`,
        watermarkAuthorName: () => "Nome do autor",
        darlingView: () => "visualização do personagem",
        darlingJsonFileInvalid: () => "O arquivo JSON do personagem está vazio ou inválido",
        darlingPersonDisplayed: (name: string) => `Personagem '${name}' exibido.`,
        darlingCopyAscii: () => "Copiar ASCII",
        darlingZoomIn: () => "Aumentar zoom",
        darlingZoomOut: () => "Diminuir zoom",
        darlingType: () => "Tipo",
        darlingAge: () => "Idade",
        darlingHeight: () => "Altura",
        darlingAlias: () => "Apelido",
        darlingDescription: () => "Descrição",
        darlingQuote: () => "Citação",
        darlingMoreInfo: () => "Mais informações",
        darlingImage: () => "Imagem",
        darlingCopied: (name: string) => `ASCII art copiado para ${name}!`,
        logoView: () => "visualização do logotipo",
        logoName: () => "Nome do logotipo",
        logoMessage: (logoPath: string) => `Arquivo (${logoPath}) ignorado, pois não é do tipo esperado.`,
        logoNoRootDir: () => "Nenhum diretório raiz fornecido para coleta de logotipos",
        logoRootDirUpdateError: (error: string) => `Erro ao atualizar arquivos de logotipo: ${error}`,
        logoDisplayed: (name: string) => `Logotipo '${name}' exibido.`,
        logoCopied: (logoName: string) => `ASCII art copiado para ${logoName}!`,
        logoChosen: (logo: string[]) => `Logotipo a ser exibido: ${JSON.stringify(logo)}`,
        logoNotFound: () => "Logotipo não encontrado",
        logoCopyAscii: () => "Copiar ASCII",
        noCommentToShow: () => "Não há comentários para exibir.",
        unknown: () => "Desconhecido",
        headerOpenerFound: () => "Início do cabeçalho encontrado.",
        headerOpenerAndCloserFound: () => "Início e fim do cabeçalho encontrados, atualizando data após verificação.",
        headerWriteFailed: () => "Falha ao escrever o cabeçalho no arquivo, verifique os logs.",
        headerWriteSuccess: () => "Cabeçalho escrito com sucesso.",
        headerNotFound: () => "Nenhum cabeçalho encontrado neste documento.",
        headerInjectQuestion: () => "Nenhum cabeçalho encontrado neste documento. Deseja adicionar um?",
        headerInjectQuestionRefused: () => "Você optou por não adicionar um cabeçalho ao arquivo.",
        morseConverted: (input: string, final: string) => `Convertido: ${input} para ${final}`,
        morseDecoded: (input: string, final: string) => `Decodificado: ${input} para ${final}`,
        fileLoaded: (absolutePath: string) => `Arquivo ${absolutePath} carregado!`,
        fileParseError: (filePath: string, error: string) => `O conteúdo do arquivo (${filePath}) não pôde ser carregado com sucesso. Erro: ${error}.`,
        fileRefreshed: () => "Atualizando o conteúdo do arquivo.",
        filePathUpdated: (oldFilePath: string, newFilePath: string) => `O caminho foi atualizado de ${oldFilePath} para ${newFilePath}.`,
        fileUnloaded: (filePath: string) => `Arquivo ${filePath} descarregado da memória.`,
        fileExcludedActivationDisabled: () => "Ativação desativada, o arquivo está na lista de exclusão.",
        fileSaveFailed: () => "Falha ao salvar o arquivo, por favor tente novamente.",
        cwdUpdated: (oldCwd: string, newCwd: string) => `O diretório de trabalho atual foi atualizado de ${oldCwd} para ${newCwd}.`,
        cwdDoesNotExist: (cwd: string) => `O diretório de trabalho fornecido ${cwd} não existe.`,
        updatingEditionDate: () => "Atualizando a data de edição.",
        documentLineScanExceeded: (maxScanLength: number) => `Verificadas as primeiras ${maxScanLength} linhas do arquivo, mas nenhum cabeçalho encontrado.`,
        closedDocument: () => "O documento está fechado, interrompendo operações.",
        emptyDocument: () => "Não há corpo do documento para trabalhar.",
        brokenHeader: () => "Cabeçalho corrompido detectado, inserindo novo, por favor remova o anterior.",
        extensionActivated: (moduleName: string) => `🚀 "${moduleName}" agora está ativo!`,
        helloWorldGreetingsCommand: (moduleName: string) => `Olá Mundo do ${moduleName}!`,
        noActiveEditor: () => "Nenhum arquivo ativo!",
        noFocusedEditors: () => "Não há arquivos em foco.",
        noLogoInstanceProvided: () => "Nenhuma instância de randomizador de logotipo fornecida.",
        randomLogoGatheringFailed: (error: string) => `Falha na coleta aleatória de logotipos, usando logotipo padrão, erro: "${error}"`,
        ramdomLogoGatheringLogoUndefined: () => "O conteúdo do logotipo está indefinido.",
        openFileToApplyHeader: () => "Por favor, abra um arquivo para aplicar o cabeçalho.",
        corruptedFileMetaData: () => "Os metadados do arquivo não foram coletados corretamente, abortando.",
        messageWritten: () => "Mensagem escrita",
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string) =>
            `Olá mundo! Extensão do arquivo: ${fileExtension}, nome: ${fileName}, caminho: ${filePath}, idioma: ${languageId}\n`,
        missingFileError: () => "O dicionário de idioma está faltando, adaptabilidade de comentário desativada.",
        unknownFileStructure: () => "A estrutura do dicionário de idioma é desconhecida, adaptabilidade de comentário desativada.",
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]) => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}.`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string) =>
            `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        identifiedLanguage: (langName: string) => `Idioma identificado: ${langName}.`,
        errorDuringFunctionCall: (functionName: string) => `Algo deu errado durante a chamada da função (${functionName}), verifique os logs.`,
        missingLanguageComment: () => "Comentário de idioma não fornecido, atribuição ignorada.",
        getHeaderDescription: () => "Por favor, forneça uma descrição: ",
        getHeaderTags: () => "Digite as tags para este arquivo, separadas por vírgulas:",
        getHeaderPurpose: () => "Por favor, forneça o propósito do arquivo:",
        noProvidedCommentOptions: () => "Nenhuma opção de comentário fornecida.",
        chooseSingleLineCommentOption: () => "Por favor, selecione seu prefixo de comentário preferido entre as opções abaixo:",
        updateAbortedBecauseFileClosedSyncCancelled: () => "Atualização abortada porque o arquivo está fechado e não será sincronizado.",
        updateEditDateMissingBounds: () => "Não foi possível atualizar o cabeçalho: marcadores internos não encontrados.",
        lastModifiedLineNotFound: () => "O cabeçalho não contém uma linha 'Última Modificação' para atualizar.",
        lastModifiedUpdated: () => "Data de 'Última Modificação' atualizada com sucesso.",
        languageNotFound: (LanguageId: string, fileExtension: string) => `Não foi possível identificar o idioma do arquivo deste documento, languageID: ${LanguageId}, extensão do arquivo: ${fileExtension}`,
        jsonContent: (jsonContentString: String) => `Conteúdo do arquivo JSON de comentários: ${jsonContentString}`,
        messageNotFound: (key: string) => `Mensagem '${key}' não encontrada.`
    },
    "tr": {
        inputboxError: (promptText: string, err: string) => `${promptText} için inputBox hatası: ${err}`,
        quickPickError: (err: string) => `quickPick hatası: ${err}`,
        quickPickYes: () => "Evet",
        quickPickNo: () => "Hayır",
        watermarkView: () => "filigranGörünümü",
        watermarkJsonFileInvalid: () => "Filigran JSON dosyası boş veya geçersiz",
        watermarkName: () => "Filigran adı",
        watermarkCopyAscii: () => "ASCII'yi Kopyala",
        watermarkZoomIn: () => "Yakınlaştır",
        watermarkZoomOut: () => "Uzaklaştır",
        watermarkPersonDisplayed: (name: string) => `'${name}' filigranı görüntülendi.`,
        watermarkChosen: (watermark: string[]) => `Gösterilecek filigran: ${JSON.stringify(watermark)}`,
        watermarkNotFound: () => "Filigran bulunamadı",
        watermarkCopied: (name: string) => `${name} için ASCII sanatı kopyalandı!`,
        watermarkAuthorName: () => "Yazar adı",
        darlingView: () => "karakterGörünümü",
        darlingJsonFileInvalid: () => "Karakter JSON dosyası boş veya geçersiz",
        darlingPersonDisplayed: (name: string) => `'${name}' karakteri görüntülendi.`,
        darlingCopyAscii: () => "ASCII'yi Kopyala",
        darlingZoomIn: () => "Yakınlaştır",
        darlingZoomOut: () => "Uzaklaştır",
        darlingType: () => "Tür",
        darlingAge: () => "Yaş",
        darlingHeight: () => "Boy",
        darlingAlias: () => "Takma ad",
        darlingDescription: () => "Açıklama",
        darlingQuote: () => "Alıntı",
        darlingMoreInfo: () => "Daha fazla bilgi",
        darlingImage: () => "Resim",
        darlingCopied: (name: string) => `${name} için ASCII sanatı kopyalandı!`,
        logoView: () => "logoGörünümü",
        logoName: () => "Logo adı",
        logoMessage: (logoPath: string) => `Dosya (${logoPath}) göz ardı edildi, çünkü aranan tür değil.`,
        logoNoRootDir: () => "Logo toplamak için kök dizin sağlanmadı",
        logoRootDirUpdateError: (error: string) => `Logo dosyaları güncellenirken bir hata oluştu: ${error}`,
        logoDisplayed: (name: string) => `'${name}' logosu görüntülendi.`,
        logoCopied: (logoName: string) => `${logoName} için ASCII sanatı kopyalandı!`,
        logoChosen: (logo: string[]) => `Gösterilecek logo: ${JSON.stringify(logo)}`,
        logoNotFound: () => "Logo bulunamadı",
        logoCopyAscii: () => "ASCII'yi Kopyala",
        noCommentToShow: () => "Gösterilecek yorum yok.",
        unknown: () => "Bilinmeyen",
        headerOpenerFound: () => "Başlık açılışı bulundu.",
        headerOpenerAndCloserFound: () => "Başlık açılışı ve kapanışı bulundu, denetim sonrası tarih güncellemesine geçiliyor.",
        headerWriteFailed: () => "Başlık dosyaya yazılamadı, günlükleri kontrol edin.",
        headerWriteSuccess: () => "Başlık başarıyla yazıldı.",
        headerNotFound: () => "Bu belgede başlık bulunamadı.",
        headerInjectQuestion: () => "Bu belgede başlık bulunamadı. Eklemek ister misiniz?",
        headerInjectQuestionRefused: () => "Dosyaya başlık eklememeyi seçtiniz.",
        morseConverted: (input: string, final: string) => `Dönüştürüldü: ${input} -> ${final}`,
        morseDecoded: (input: string, final: string) => `Çözüldü: ${input} -> ${final}`,
        fileLoaded: (absolutePath: string) => `Dosya ${absolutePath} yüklendi!`,
        fileParseError: (filePath: string, error: string) => `Dosya içeriği (${filePath}) başarıyla yüklenemedi. Hata: ${error}.`,
        fileRefreshed: () => "Dosya içeriği yenileniyor.",
        filePathUpdated: (oldFilePath: string, newFilePath: string) => `Yol ${oldFilePath}’den ${newFilePath}’e güncellendi.`,
        fileUnloaded: (filePath: string) => `Dosya ${filePath} hafızadan boşaltıldı.`,
        fileExcludedActivationDisabled: () => "Aktivasyon devre dışı, dosya hariç tutma listesinde.",
        fileSaveFailed: () => "Dosya kaydedilemedi, lütfen tekrar deneyin.",
        cwdUpdated: (oldCwd: string, newCwd: string) => `Mevcut çalışma dizini ${oldCwd}’den ${newCwd}’ye güncellendi.`,
        cwdDoesNotExist: (cwd: string) => `Sağlanan çalışma dizini ${cwd} mevcut değil.`,
        updatingEditionDate: () => "Sürüm tarihi güncelleniyor.",
        documentLineScanExceeded: (maxScanLength: number) => `Dosyanın ilk ${maxScanLength} satırı tarandı, başlık bulunamadı.`,
        closedDocument: () => "Belge kapalı, işlemler durduruluyor.",
        emptyDocument: () => "Üzerinde çalışılacak belge yok.",
        brokenHeader: () => "Bozuk başlık tespit edildi, yeni başlık ekleniyor, lütfen öncekini kaldırın.",
        extensionActivated: (moduleName: string) => `🚀 "${moduleName}" artık aktif!`,
        helloWorldGreetingsCommand: (moduleName: string) => `${moduleName}’den Merhaba Dünya!`,
        noActiveEditor: () => "Aktif dosya yok!",
        noFocusedEditors: () => "Odaklanmış dosya yok.",
        noLogoInstanceProvided: () => "Hiçbir logo rastgeleleştirici örneği sağlanmadı.",
        randomLogoGatheringFailed: (error: string) => `Rastgele logo toplama başarısız, varsayılan logo kullanılıyor, hata: "${error}"`,
        ramdomLogoGatheringLogoUndefined: () => "Logo içeriği tanımsız.",
        openFileToApplyHeader: () => "Başlığı uygulamak için bir dosya açın.",
        corruptedFileMetaData: () => "Gerekli dosya meta verileri doğru şekilde alınamadı, işlem durduruldu.",
        messageWritten: () => "Mesaj yazıldı",
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string) =>
            `Merhaba dünya! Bu dosyanın uzantısı: ${fileExtension}, adı: ${fileName}, yolu: ${filePath}, belirlenen dil: ${languageId}\n`,
        missingFileError: () => "Dil sözlüğü eksik, yorum uyumluluğu devre dışı.",
        unknownFileStructure: () => "Dil sözlüğü yapısı bilinmiyor, yorum uyumluluğu devre dışı.",
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]) => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}.`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string) =>
            `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        identifiedLanguage: (langName: string) => `Belirlenen dil: ${langName}.`,
        errorDuringFunctionCall: (functionName: string) => `Fonksiyon (${functionName}) çağrılırken bir hata oluştu, logları kontrol edin.`,
        missingLanguageComment: () => "Dil yorumu sağlanmadı, atlama yapılıyor.",
        getHeaderDescription: () => "Lütfen bir açıklama sağlayın: ",
        getHeaderTags: () => "Bu dosya için etiketleri virgülle ayırarak girin:",
        getHeaderPurpose: () => "Lütfen dosyanın amacını belirtin:",
        noProvidedCommentOptions: () => "Sağlanmış yorum seçeneği yok.",
        chooseSingleLineCommentOption: () => "Aşağıdaki seçeneklerden tercih ettiğiniz yorum ön ekini seçin:",
        updateAbortedBecauseFileClosedSyncCancelled: () => "Dosya kapalı olduğu için güncelleme iptal edildi ve senkronize edilmeyecek.",
        updateEditDateMissingBounds: () => "Başlık güncellenemedi: iç başlık işaretçileri bulunamadı.",
        lastModifiedLineNotFound: () => "Başlıkta güncellenecek 'Son Değişiklik' satırı yok.",
        lastModifiedUpdated: () => "'Son Değişiklik' tarihi başarıyla güncellendi.",
        languageNotFound: (LanguageId: string, fileExtension: string) => `Bu belgenin dosya dili tanımlanamadı, languageID: ${LanguageId}, dosya uzantısı: ${fileExtension}`,
        jsonContent: (jsonContentString: String) => `Yorum JSON dosyasının içeriği: ${jsonContentString}`,
        messageNotFound: (key: string) => `'${key}' mesajı bulunamadı.`
    },
    "pl": {
        inputboxError: (promptText: string, err: string) => `Błąd w inputBox dla ${promptText}: ${err}`,
        quickPickError: (err: string) => `Błąd w quickPick: ${err}`,
        quickPickYes: () => "Tak",
        quickPickNo: () => "Nie",
        watermarkView: () => "widokWatermark",
        watermarkJsonFileInvalid: () => "Plik JSON filigranu jest pusty lub nieprawidłowy",
        watermarkName: () => "Nazwa filigranu",
        watermarkCopyAscii: () => "Kopiuj ASCII",
        watermarkZoomIn: () => "Powiększ",
        watermarkZoomOut: () => "Pomniejsz",
        watermarkPersonDisplayed: (name: string) => `Filigran '${name}' został wyświetlony.`,
        watermarkChosen: (watermark: string[]) => `Filigran do wyświetlenia: ${JSON.stringify(watermark)}`,
        watermarkNotFound: () => "Filigran nie został znaleziony",
        watermarkCopied: (name: string) => `Sztuka ASCII skopiowana dla ${name}!`,
        watermarkAuthorName: () => "Autor",
        darlingView: () => "widokPostaci",
        darlingJsonFileInvalid: () => "Plik JSON postaci jest pusty lub nieprawidłowy",
        darlingPersonDisplayed: (name: string) => `Postać '${name}' została wyświetlona.`,
        darlingCopyAscii: () => "Kopiuj ASCII",
        darlingZoomIn: () => "Powiększ",
        darlingZoomOut: () => "Pomniejsz",
        darlingType: () => "Typ",
        darlingAge: () => "Wiek",
        darlingHeight: () => "Wzrost",
        darlingAlias: () => "Alias",
        darlingDescription: () => "Opis",
        darlingQuote: () => "Cytat",
        darlingMoreInfo: () => "Więcej informacji",
        darlingImage: () => "Obraz",
        darlingCopied: (name: string) => `Sztuka ASCII skopiowana dla ${name}!`,
        logoView: () => "widokLogo",
        logoName: () => "Nazwa logo",
        logoMessage: (logoPath: string) => `Plik (${logoPath}) pominięty, ponieważ nie jest szukanym typem.`,
        logoNoRootDir: () => "Nie podano katalogu głównego do zbierania logotypów",
        logoRootDirUpdateError: (error: string) => `Wystąpił błąd podczas aktualizacji plików logo: ${error}`,
        logoDisplayed: (name: string) => `Logo '${name}' zostało wyświetlone.`,
        logoCopied: (logoName: string) => `Sztuka ASCII skopiowana dla ${logoName}!`,
        logoChosen: (logo: string[]) => `Logo do wyświetlenia: ${JSON.stringify(logo)}`,
        logoNotFound: () => "Logo nie znaleziono",
        logoCopyAscii: () => "Kopiuj ASCII",
        noCommentToShow: () => "Brak komentarzy do wyświetlenia.",
        unknown: () => "Nieznany",
        headerOpenerFound: () => "Znaleziono otwieracz nagłówka.",
        headerOpenerAndCloserFound: () => "Znaleziono otwieracz i zamykacz nagłówka, kontynuowanie aktualizacji daty po kontroli poprawności.",
        headerWriteFailed: () => "Nie udało się zapisać nagłówka do pliku, sprawdź logi.",
        headerWriteSuccess: () => "Nagłówek zapisany pomyślnie.",
        headerNotFound: () => "Nie znaleziono nagłówka w tym dokumencie.",
        headerInjectQuestion: () => "Nie znaleziono nagłówka w tym dokumencie. Czy chcesz dodać jeden?",
        headerInjectQuestionRefused: () => "Zdecydowano nie dodawać nagłówka do pliku.",
        morseConverted: (input: string, final: string) => `Przekonwertowano: ${input} na ${final}`,
        morseDecoded: (input: string, final: string) => `Rozkodowano: ${input} na ${final}`,
        fileLoaded: (absolutePath: string) => `Plik ${absolutePath} został załadowany!`,
        fileParseError: (filePath: string, error: string) => `Zawartość pliku (${filePath}) nie mogła zostać załadowana poprawnie. Błąd: ${error}.`,
        fileRefreshed: () => "Odświeżanie zawartości pliku.",
        filePathUpdated: (oldFilePath: string, newFilePath: string) => `Ścieżka została zaktualizowana z ${oldFilePath} na ${newFilePath}.`,
        fileUnloaded: (filePath: string) => `Plik ${filePath} został usunięty z pamięci.`,
        fileExcludedActivationDisabled: () => "Aktywacja wyłączona, plik znajduje się na liście wykluczeń.",
        fileSaveFailed: () => "Nie udało się zapisać pliku, spróbuj ponownie.",
        cwdUpdated: (oldCwd: string, newCwd: string) => `Bieżący katalog roboczy zaktualizowano z ${oldCwd} na ${newCwd}.`,
        cwdDoesNotExist: (cwd: string) => `Podany katalog roboczy ${cwd} nie istnieje.`,
        updatingEditionDate: () => "Aktualizacja daty edycji.",
        documentLineScanExceeded: (maxScanLength: number) => `Przeskanowano pierwsze ${maxScanLength} linie pliku, ale nie znaleziono nagłówka.`,
        closedDocument: () => "Dokument jest zamknięty, zatrzymywanie operacji.",
        emptyDocument: () => "Brak zawartości dokumentu do pracy.",
        brokenHeader: () => "Wykryto uszkodzony nagłówek, wstrzykiwanie nowego, usuń poprzedni.",
        extensionActivated: (moduleName: string) => `🚀 "${moduleName}" jest teraz aktywny!`,
        helloWorldGreetingsCommand: (moduleName: string) => `Witaj Świecie z ${moduleName}!`,
        noActiveEditor: () => "Brak aktywnego pliku!",
        noFocusedEditors: () => "Brak plików w fokusie.",
        noLogoInstanceProvided: () => "Nie podano instancji losowego loga.",
        randomLogoGatheringFailed: (error: string) => `Losowe zbieranie loga nie powiodło się, użycie domyślnego loga, błąd: "${error}"`,
        ramdomLogoGatheringLogoUndefined: () => "Zawartość loga jest niezdefiniowana.",
        openFileToApplyHeader: () => "Otwórz plik, aby zastosować nagłówek.",
        corruptedFileMetaData: () => "Wymagane metadane pliku nie zostały poprawnie zebrane, przerywanie.",
        messageWritten: () => "Wiadomość zapisana",
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string) =>
            `Witaj świecie! Rozszerzenie tego pliku: ${fileExtension}, nazwa: ${fileName}, ścieżka: ${filePath}, określony język: ${languageId}\n`,
        missingFileError: () => "Słownik językowy jest brakujący, dostosowanie komentarzy jest wyłączone.",
        unknownFileStructure: () => "Struktura słownika językowego jest nieznana, dostosowanie komentarzy jest wyłączone.",
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]) => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}.`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string) =>
            `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        identifiedLanguage: (langName: string) => `Zidentyfikowany język: ${langName}.`,
        errorDuringFunctionCall: (functionName: string) => `Wystąpił błąd podczas wywołania funkcji (${functionName}), sprawdź logi.`,
        missingLanguageComment: () => "Komentarz języka nie został dostarczony, pomijanie przypisania.",
        getHeaderDescription: () => "Podaj opis: ",
        getHeaderTags: () => "Wprowadź tagi dla tego pliku, oddzielone przecinkami:",
        getHeaderPurpose: () => "Podaj cel pliku:",
        noProvidedCommentOptions: () => "Nie dostarczono żadnych opcji komentarza.",
        chooseSingleLineCommentOption: () => "Wybierz preferowany prefiks komentarza z poniższych opcji:",
        updateAbortedBecauseFileClosedSyncCancelled: () => "Aktualizacja przerwana, ponieważ plik jest zamknięty i nie zostanie zsynchronizowany.",
        updateEditDateMissingBounds: () => "Nie można zaktualizować nagłówka: nie znaleziono wewnętrznych znaczników nagłówka.",
        lastModifiedLineNotFound: () => "Nagłówek nie zawiera wiersza 'Ostatnia modyfikacja' do aktualizacji.",
        lastModifiedUpdated: () => "Data 'Ostatnia modyfikacja' została pomyślnie zaktualizowana.",
        languageNotFound: (LanguageId: string, fileExtension: string) => `Nie udało się zidentyfikować języka pliku tego dokumentu, languageID: ${LanguageId}, rozszerzenie pliku: ${fileExtension}`,
        jsonContent: (jsonContentString: String) => `Zawartość pliku JSON komentarza: ${jsonContentString}`,
        messageNotFound: (key: string) => `Nie znaleziono komunikatu '${key}'.`
    },
    "cs": {
        inputboxError: (promptText: string, err: string) => `Chyba v inputBox pro ${promptText}: ${err}`,
        quickPickError: (err: string) => `Chyba v quickPick: ${err}`,
        quickPickYes: () => "Ano",
        quickPickNo: () => "Ne",
        watermarkView: () => "zobrazeníWatermark",
        watermarkJsonFileInvalid: () => "Soubor JSON vodoznaku je prázdný nebo neplatný",
        watermarkName: () => "Název vodoznaku",
        watermarkCopyAscii: () => "Kopírovat ASCII",
        watermarkZoomIn: () => "Přiblížit",
        watermarkZoomOut: () => "Oddálit",
        watermarkPersonDisplayed: (name: string) => `Vodoznak '${name}' zobrazen.`,
        watermarkChosen: (watermark: string[]) => `Vodoznak k zobrazení: ${JSON.stringify(watermark)}`,
        watermarkNotFound: () => "Vodoznak nenalezen",
        watermarkCopied: (name: string) => `ASCII umění zkopírováno pro ${name}!`,
        watermarkAuthorName: () => "Jméno autora",
        darlingView: () => "zobrazeníPostavy",
        darlingJsonFileInvalid: () => "Soubor JSON postavy je prázdný nebo neplatný",
        darlingPersonDisplayed: (name: string) => `Postava '${name}' zobrazena.`,
        darlingCopyAscii: () => "Kopírovat ASCII",
        darlingZoomIn: () => "Přiblížit",
        darlingZoomOut: () => "Oddálit",
        darlingType: () => "Typ",
        darlingAge: () => "Věk",
        darlingHeight: () => "Výška",
        darlingAlias: () => "Přezdívka",
        darlingDescription: () => "Popis",
        darlingQuote: () => "Citát",
        darlingMoreInfo: () => "Více informací",
        darlingImage: () => "Obrázek",
        darlingCopied: (name: string) => `ASCII umění zkopírováno pro ${name}!`,
        logoView: () => "zobrazeníLoga",
        logoName: () => "Název loga",
        logoMessage: (logoPath: string) => `Soubor (${logoPath}) byl ignorován, protože není požadovaného typu.`,
        logoNoRootDir: () => "Nebyl poskytnut žádný kořenový adresář pro sběr log",
        logoRootDirUpdateError: (error: string) => `Došlo k chybě při aktualizaci souborů loga, chyba: ${error}`,
        logoDisplayed: (name: string) => `Logo '${name}' zobrazeno.`,
        logoCopied: (logoName: string) => `ASCII umění zkopírováno pro ${logoName}!`,
        logoChosen: (logo: string[]) => `Logo k zobrazení: ${JSON.stringify(logo)}`,
        logoNotFound: () => "Logo nenalezeno",
        logoCopyAscii: () => "Kopírovat ASCII",
        noCommentToShow: () => "Žádný komentář k zobrazení.",
        unknown: () => "Neznámý",
        headerOpenerFound: () => "Otevírač hlavičky nalezen.",
        headerOpenerAndCloserFound: () => "Otevírač a zavírač hlavičky nalezeny, pokračuje aktualizace data po kontrole správnosti.",
        headerWriteFailed: () => "Nepodařilo se zapsat hlavičku do souboru, zkontrolujte protokoly.",
        headerWriteSuccess: () => "Hlavička úspěšně zapsána.",
        headerNotFound: () => "V tomto dokumentu nebyla nalezena žádná hlavička.",
        headerInjectQuestion: () => "V tomto dokumentu nebyla nalezena žádná hlavička. Chcete ji přidat?",
        headerInjectQuestionRefused: () => "Rozhodli jste se nepřidávat hlavičku do souboru.",
        morseConverted: (input: string, final: string) => `Převedeno: ${input} na ${final}`,
        morseDecoded: (input: string, final: string) => `Dekódováno: ${input} na ${final}`,
        fileLoaded: (absolutePath: string) => `Soubor ${absolutePath} byl načten!`,
        fileParseError: (filePath: string, error: string) => `Obsah souboru (${filePath}) nelze úspěšně načíst. Chyba: ${error}.`,
        fileRefreshed: () => "Obnovování obsahu souboru.",
        filePathUpdated: (oldFilePath: string, newFilePath: string) => `Cesta byla aktualizována z ${oldFilePath} na ${newFilePath}.`,
        fileUnloaded: (filePath: string) => `Soubor ${filePath} byl odstraněn z paměti.`,
        fileExcludedActivationDisabled: () => "Aktivace zakázána, soubor je na seznamu vyloučení.",
        fileSaveFailed: () => "Nepodařilo se uložit soubor, zkuste to znovu.",
        cwdUpdated: (oldCwd: string, newCwd: string) => `Aktuální pracovní adresář byl aktualizován z ${oldCwd} na ${newCwd}.`,
        cwdDoesNotExist: (cwd: string) => `Zadaný pracovní adresář ${cwd} neexistuje.`,
        updatingEditionDate: () => "Aktualizace data edice.",
        documentLineScanExceeded: (maxScanLength: number) => `Prohledáno prvních ${maxScanLength} řádků souboru, ale hlavička nebyla nalezena.`,
        closedDocument: () => "Dokument je uzavřen, operace zastaveny.",
        emptyDocument: () => "Neexistuje žádný obsah dokumentu k práci.",
        brokenHeader: () => "Byla detekována poškozená hlavička, vkládá se nová, odstraňte předchozí.",
        extensionActivated: (moduleName: string) => `🚀 "${moduleName}" je nyní aktivní!`,
        helloWorldGreetingsCommand: (moduleName: string) => `Hello World z ${moduleName}!`,
        noActiveEditor: () => "Žádný aktivní soubor!",
        noFocusedEditors: () => "Žádné soubory nejsou ve fokus.",
        noLogoInstanceProvided: () => "Nebyla poskytnuta instance náhodného loga.",
        randomLogoGatheringFailed: (error: string) => `Shromažďování náhodného loga selhalo, použití výchozího loga, chyba: "${error}"`,
        ramdomLogoGatheringLogoUndefined: () => "Obsah loga není definován.",
        openFileToApplyHeader: () => "Otevřete soubor, na který chcete aplikovat hlavičku.",
        corruptedFileMetaData: () => "Požadovaná metadata souboru nebyla správně shromážděna, přerušení.",
        messageWritten: () => "Zpráva zapsána",
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string) =>
            `Hello world! Přípona tohoto souboru: ${fileExtension}, název: ${fileName}, cesta: ${filePath}, určený jazyk: ${languageId}\n`,
        missingFileError: () => "Slovník jazyků chybí, přizpůsobení komentářů je deaktivováno.",
        unknownFileStructure: () => "Struktura slovníku jazyků je neznámá, přizpůsobení komentářů je deaktivováno.",
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]) => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}.`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string) =>
            `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        identifiedLanguage: (langName: string) => `Identifikovaný jazyk: ${langName}.`,
        errorDuringFunctionCall: (functionName: string) => `Něco se pokazilo během volání funkce (${functionName}), zkontrolujte logy.`,
        missingLanguageComment: () => "Komentář jazyka nebyl poskytnut, přiřazení přeskočeno.",
        getHeaderDescription: () => "Zadejte popis: ",
        getHeaderTags: () => "Zadejte tagy pro tento soubor, oddělené čárkou:",
        getHeaderPurpose: () => "Zadejte účel souboru:",
        noProvidedCommentOptions: () => "Nebyly poskytnuty žádné možnosti komentáře.",
        chooseSingleLineCommentOption: () => "Vyberte preferovaný prefix komentáře z níže uvedených možností:",
        updateAbortedBecauseFileClosedSyncCancelled: () => "Aktualizace přerušena, protože soubor je uzavřen a nebude synchronizován.",
        updateEditDateMissingBounds: () => "Nelze aktualizovat hlavičku: interní markery hlavičky nebyly nalezeny.",
        lastModifiedLineNotFound: () => "Hlavička neobsahuje řádek 'Poslední úprava' k aktualizaci.",
        lastModifiedUpdated: () => "Datum 'Poslední úprava' bylo úspěšně aktualizováno.",
        languageNotFound: (LanguageId: string, fileExtension: string) => `Jazyk souboru tohoto dokumentu nelze identifikovat, languageID: ${LanguageId}, přípona souboru: ${fileExtension}`,
        jsonContent: (jsonContentString: String) => `Obsah JSON souboru komentářů: ${jsonContentString}`,
        messageNotFound: (key: string) => `Zpráva '${key}' nenalezena.`
    },
    "hu": {
        inputboxError: (promptText: string, err: string) => `Hiba az inputBox-nál a(z) ${promptText} esetén: ${err}`,
        quickPickError: (err: string) => `Hiba a quickPick-nál: ${err}`,
        quickPickYes: () => "Igen",
        quickPickNo: () => "Nem",
        watermarkView: () => "vízjelNézet",
        watermarkJsonFileInvalid: () => "A vízjel JSON fájl üres vagy érvénytelen",
        watermarkName: () => "Vízjel neve",
        watermarkCopyAscii: () => "Másolás ASCII",
        watermarkZoomIn: () => "Nagyítás",
        watermarkZoomOut: () => "Kicsinyítés",
        watermarkPersonDisplayed: (name: string) => `Vízjel '${name}' megjelenítve.`,
        watermarkChosen: (watermark: string[]) => `Megjelenítendő vízjel: ${JSON.stringify(watermark)}`,
        watermarkNotFound: () => "Vízjel nem található",
        watermarkCopied: (name: string) => `ASCII művészet másolva ${name} számára!`,
        watermarkAuthorName: () => "Szerző neve",
        darlingView: () => "karakterNézet",
        darlingJsonFileInvalid: () => "A karakter JSON fájl üres vagy érvénytelen",
        darlingPersonDisplayed: (name: string) => `Karakter '${name}' megjelenítve.`,
        darlingCopyAscii: () => "Másolás ASCII",
        darlingZoomIn: () => "Nagyítás",
        darlingZoomOut: () => "Kicsinyítés",
        darlingType: () => "Típus",
        darlingAge: () => "Kor",
        darlingHeight: () => "Magasság",
        darlingAlias: () => "Becenév",
        darlingDescription: () => "Leírás",
        darlingQuote: () => "Idézet",
        darlingMoreInfo: () => "További info",
        darlingImage: () => "Kép",
        darlingCopied: (name: string) => `ASCII művészet másolva ${name} számára!`,
        logoView: () => "logoNézet",
        logoName: () => "Logó neve",
        logoMessage: (logoPath: string) => `Fájl (${logoPath}) figyelmen kívül hagyva, mert nem a keresett típus.`,
        logoNoRootDir: () => "Nincs megadva gyökérkönyvtár a logók gyűjtéséhez",
        logoRootDirUpdateError: (error: string) => `Hiba történt a logófájlok frissítése közben, hiba: ${error}`,
        logoDisplayed: (name: string) => `Logó '${name}' megjelenítve.`,
        logoCopied: (logoName: string) => `ASCII művészet másolva ${logoName} számára!`,
        logoChosen: (logo: string[]) => `Megjelenítendő logó: ${JSON.stringify(logo)}`,
        logoNotFound: () => "Logó nem található",
        logoCopyAscii: () => "Másolás ASCII",
        noCommentToShow: () => "Nincs megjeleníthető komment.",
        unknown: () => "Ismeretlen",
        headerOpenerFound: () => "Fejléc nyitó megtalálva.",
        headerOpenerAndCloserFound: () => "Fejléc nyitó és záró megtalálva, a dátum frissítése következik ellenőrzés után.",
        headerWriteFailed: () => "Nem sikerült írni a fejlécet a fájlba, ellenőrizze a naplókat.",
        headerWriteSuccess: () => "Fejléc sikeresen írva.",
        headerNotFound: () => "Nem található fejléc ebben a dokumentumban.",
        headerInjectQuestion: () => "Nem található fejléc ebben a dokumentumban. Szeretne hozzáadni egyet?",
        headerInjectQuestionRefused: () => "Úgy döntött, hogy nem ad hozzá fejlécet a fájlhoz.",
        morseConverted: (input: string, final: string) => `Átalakítva: ${input} -> ${final}`,
        morseDecoded: (input: string, final: string) => `Dekódolva: ${input} -> ${final}`,
        fileLoaded: (absolutePath: string) => `A fájl ${absolutePath} betöltve!`,
        fileParseError: (filePath: string, error: string) => `A fájl tartalma (${filePath}) nem tölthető be sikeresen. Hiba: ${error}.`,
        fileRefreshed: () => "Fájl tartalmának frissítése.",
        filePathUpdated: (oldFilePath: string, newFilePath: string) => `Az útvonal frissítve lett: ${oldFilePath} -> ${newFilePath}.`,
        fileUnloaded: (filePath: string) => `A fájl ${filePath} eltávolítva a memóriából.`,
        fileExcludedActivationDisabled: () => "Az aktiválás letiltva, a fájl a kizárási listán van.",
        fileSaveFailed: () => "A fájl mentése sikertelen, próbálja újra.",
        cwdUpdated: (oldCwd: string, newCwd: string) => `A munkakönyvtár frissítve lett: ${oldCwd} -> ${newCwd}.`,
        cwdDoesNotExist: (cwd: string) => `A megadott munkakönyvtár ${cwd} nem létezik.`,
        updatingEditionDate: () => "Kiadás dátumának frissítése.",
        documentLineScanExceeded: (maxScanLength: number) => `Az első ${maxScanLength} sor beolvasva, de nem található fejléc.`,
        closedDocument: () => "A dokumentum zárva, a műveletek leállítva.",
        emptyDocument: () => "Nincs dokumentumtartalom, amin dolgozni lehetne.",
        brokenHeader: () => "Sérült fejléc észlelve, új beszúrása folyamatban, kérjük távolítsa el az előzőt.",
        extensionActivated: (moduleName: string) => `🚀 A(z) "${moduleName}" modul most aktív!`,
        helloWorldGreetingsCommand: (moduleName: string) => `Hello World a ${moduleName}-ból!`,
        noActiveEditor: () => "Nincs aktív fájl!",
        noFocusedEditors: () => "Nincsenek fókuszban lévő fájlok.",
        noLogoInstanceProvided: () => "Nem lett logó randomizáló példány megadva.",
        randomLogoGatheringFailed: (error: string) => `A véletlenszerű logógyűjtés sikertelen, alapértelmezett logó használata, hiba: "${error}"`,
        ramdomLogoGatheringLogoUndefined: () => "A logó tartalma nem definiált.",
        openFileToApplyHeader: () => "Nyisson meg egy fájlt a fejléc alkalmazásához.",
        corruptedFileMetaData: () => "A szükséges fájl metaadatok nem lettek megfelelően összegyűjtve, megszakítás.",
        messageWritten: () => "Üzenet írva",
        sayHelloWorldResponse: (fileExtension: string, fileName: string, filePath: string, languageId: string) =>
            `Hello world! A fájl kiterjesztése: ${fileExtension}, neve: ${fileName}, útvonala: ${filePath}, nyelv: ${languageId}\n`,
        missingFileError: () => "A nyelvi szótár hiányzik, a komment alkalmazkodás le van tiltva.",
        unknownFileStructure: () => "A nyelvi szótár szerkezete ismeretlen, a komment alkalmazkodás le van tiltva.",
        arrayNodeContent: (arrayName: string, arrayIndex: number, arrayNode: any[]) => `${arrayName}[${arrayIndex}] = ${JSON.stringify(arrayNode)}.`,
        inputArgs: (documentBody: string, filePath: string, fileName: string, fileExtension: string, languageId: string, documentEOL: string, documentVersion: string) =>
            `this.documentBody = '${documentBody}', this.filePath = '${filePath}', this.fileName = '${fileName}', this.fileExtension = '${fileExtension}', this.languageId = '${languageId}', this.documentEOL = '${documentEOL}', this.documentVersion = '${documentVersion}'`,
        identifiedLanguage: (langName: string) => `Azonosított nyelv: ${langName}.`,
        errorDuringFunctionCall: (functionName: string) => `Hiba történt a ${functionName} függvény hívásakor, ellenőrizze a naplókat.`,
        missingLanguageComment: () => "A nyelvi komment nem lett megadva, a hozzárendelés kihagyva.",
        getHeaderDescription: () => "Adjon meg egy leírást: ",
        getHeaderTags: () => "Adja meg a fájl címkéit, vesszővel elválasztva:",
        getHeaderPurpose: () => "Adja meg a fájl célját:",
        noProvidedCommentOptions: () => "Nincsenek megadott komment opciók.",
        chooseSingleLineCommentOption: () => "Kérjük, válassza ki a kívánt komment prefixet az alábbi lehetőségek közül:",
        updateAbortedBecauseFileClosedSyncCancelled: () => "A frissítés megszakítva, mert a fájl zárva van és nem lesz szinkronizálva.",
        updateEditDateMissingBounds: () => "Nem sikerült frissíteni a fejlécet: a belső jelölők nem találhatók.",
        lastModifiedLineNotFound: () => "A fejléc nem tartalmaz 'Utolsó módosítás' sort a frissítéshez.",
        lastModifiedUpdated: () => "Az 'Utolsó módosítás' dátum sikeresen frissítve.",
        languageNotFound: (LanguageId: string, fileExtension: string) => `A dokumentum nyelve nem azonosítható, languageID: ${LanguageId}, fájlkiterjesztés: ${fileExtension}`,
        jsonContent: (jsonContentString: String) => `A komment JSON fájl tartalma: ${jsonContentString}`,
        messageNotFound: (key: string) => `'${key}' üzenet nem található.`
    }
};
